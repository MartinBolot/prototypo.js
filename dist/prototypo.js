!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),o.prototypo=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/louisremi/Workspace/prototypo.js/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canMutationObserver = typeof window !== 'undefined'
    && window.MutationObserver;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    var queue = [];

    if (canMutationObserver) {
        var hiddenDiv = document.createElement("div");
        var observer = new MutationObserver(function () {
            var queueList = queue.slice();
            queue.length = 0;
            queueList.forEach(function (fn) {
                fn();
            });
        });

        observer.observe(hiddenDiv, { attributes: true });

        return function nextTick(fn) {
            if (!queue.length) {
                hiddenDiv.setAttribute('yes', 'no');
            }
            queue.push(fn);
        };
    }

    if (canPost) {
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/home/louisremi/Workspace/prototypo.js/node_modules/deptree/index.js":[function(require,module,exports){
var DepTree = function() {
  this.nodes = {}; 
};

DepTree.prototype.add = function(node, dependants) {
  var self = this;

  if (!dependants) {
    dependants = [];
  } else if (!(dependants instanceof Array)) {
    dependants = [dependants];
  }

  this.nodes[node] = dependants;
};


DepTree.prototype.resolveNode = function(node, resolved, processing) {

  var self = this;

  resolved = resolved || [];
  processing = processing || {};
  var deps = this.nodes[node] || [];

  processing[node] = true;

  deps.forEach(function(dep) {
    if (resolved.indexOf(dep) != -1) {
      return;
    }
    if (processing[dep]) {
      throw new Error('Circular dependency: '+dep);
    }
    self.resolveNode(dep, resolved, processing);
  });

  if (resolved.indexOf(node) == -1) {
    processing[node] = false;
    resolved.push(node);
  }
  return resolved;
};

DepTree.prototype.resolve = function() {

  var resolved = [];
  for (var node in this.nodes) {
    this.resolveNode(node, resolved);
  }

  return resolved;

};


module.exports = DepTree;

},{}],"/home/louisremi/Workspace/prototypo.js/node_modules/plumin.js/dist/plumin.js":[function(require,module,exports){
(function (process,global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.plumin=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.opentype=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// Run-time checking of preconditions.

'use strict';

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
exports.argument = function (predicate, message) {
    if (!predicate) {
        throw new Error(message);
    }
};

// Precondition function that checks if the given assertion is true.
// If not, it will throw an error.
exports.assert = exports.argument;

},{}],2:[function(_dereq_,module,exports){
// Drawing utility functions.

'use strict';

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

exports.line = line;

},{}],3:[function(_dereq_,module,exports){
// Glyph encoding

'use strict';

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

// This is the encoding used for fonts created from scratch.
// It loops through all glyphs and finds the appropriate unicode value.
// Since it's linear time, other encodings will be faster.
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function (c) {
    var code, glyphs, i, glyph, j;
    code = c.charCodeAt(0);
    glyphs = this.font.glyphs;
    if (glyphs) {
        for (i = 0; i < glyphs.length; i += 1) {
            glyph = glyphs[i];
            for (j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    } else {
        return null;
    }
};

function CmapEncoding(cmap) {
    this.cmap = cmap;
}

CmapEncoding.prototype.charToGlyphIndex = function (c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

CffEncoding.prototype.charToGlyphIndex = function (s) {
    var code, charName;
    code = s.charCodeAt(0);
    charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

function GlyphNames(post) {
    var i;
    switch (post.version) {
    case 1:
        this.names = exports.standardNames.slice();
        break;
    case 2:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] < exports.standardNames.length) {
                this.names[i] = exports.standardNames[post.glyphNameIndex[i]];
            } else {
                this.names[i] = post.names[post.glyphNameIndex[i] - exports.standardNames.length];
            }
        }
        break;
    case 2.5:
        this.names = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            this.names[i] = exports.standardNames[i + post.glyphNameIndex[i]];
        }
        break;
    case 3:
        this.names = [];
        break;
    }
}

GlyphNames.prototype.nameToGlyphIndex = function (name) {
    return this.names.indexOf(name);
};

GlyphNames.prototype.glyphIndexToName = function (gid) {
    return this.names[gid];
};

function addGlyphNames(font) {
    var glyphIndexMap, charCodes, i, c, glyphIndex, glyph;
    glyphIndexMap = font.tables.cmap.glyphIndexMap;
    charCodes = Object.keys(glyphIndexMap);
    for (i = 0; i < charCodes.length; i += 1) {
        c = charCodes[i];
        glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs[glyphIndex];
        glyph.addUnicode(parseInt(c));
    }
    for (i = 0; i < font.glyphs.length; i += 1) {
        glyph = font.glyphs[i];
        if (font.cffEncoding) {
            glyph.name = font.cffEncoding.charset[i];
        } else {
            glyph.name = font.glyphNames.glyphIndexToName(i);
        }
    }
}

exports.cffStandardStrings = cffStandardStrings;
exports.cffStandardEncoding = cffStandardEncoding;
exports.cffExpertEncoding = cffExpertEncoding;
exports.standardNames = standardNames;
exports.DefaultEncoding = DefaultEncoding;
exports.CmapEncoding = CmapEncoding;
exports.CffEncoding = CffEncoding;
exports.GlyphNames = GlyphNames;
exports.addGlyphNames = addGlyphNames;

},{}],4:[function(_dereq_,module,exports){
// The Font object

'use strict';

var path = _dereq_('./path');
var sfnt = _dereq_('./tables/sfnt');
var encoding = _dereq_('./encoding');

// A Font represents a loaded OpenType font file.
// It contains a set of glyphs and methods to draw text on a drawing context,
// or to get a path representing the text.
function Font(options) {
    options = options || {};
    // OS X will complain if the names are empty, so we put a single space everywhere by default.
    this.familyName = options.familyName || ' ';
    this.styleName = options.styleName || ' ';
    this.designer = options.designer || ' ';
    this.designerURL = options.designerURL || ' ';
    this.manufacturer = options.manufacturer || ' ';
    this.manufacturerURL = options.manufacturerURL || ' ';
    this.license = options.license || ' ';
    this.licenseURL = options.licenseURL || ' ';
    this.version = options.version || 'Version 0.1';
    this.description = options.description || ' ';
    this.copyright = options.copyright || ' ';
    this.trademark = options.trademark || ' ';
    this.unitsPerEm = options.unitsPerEm || 1000;
    this.ascender = options.ascender;
    this.descender = options.descender;
    this.supported = true;
    this.glyphs = options.glyphs || [];
    this.encoding = new encoding.DefaultEncoding(this);
    this.tables = {};
}

// Check if the font has a glyph for the given character.
Font.prototype.hasChar = function (c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

// Convert the given character to a single glyph index.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyphIndex = function (s) {
    return this.encoding.charToGlyphIndex(s);
};

// Convert the given character to a single Glyph object.
// Note that this function assumes that there is a one-to-one mapping between
// the given character and a glyph; for complex scripts this might not be the case.
Font.prototype.charToGlyph = function (c) {
    var glyphIndex, glyph;
    glyphIndex = this.charToGlyphIndex(c);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

// Convert the given text to a list of Glyph objects.
// Note that there is no strict one-to-one mapping between characters and
// glyphs, so the list of returned glyphs can be larger or smaller than the
// length of the given string.
Font.prototype.stringToGlyphs = function (s) {
    var i, c, glyphs;
    glyphs = [];
    for (i = 0; i < s.length; i += 1) {
        c = s[i];
        glyphs.push(this.charToGlyph(c));
    }
    return glyphs;
};

Font.prototype.nameToGlyphIndex = function (name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

Font.prototype.nameToGlyph = function (name) {
    var glyphIndex, glyph;
    glyphIndex = this.nametoGlyphIndex(name);
    glyph = this.glyphs[glyphIndex];
    if (!glyph) {
        glyph = this.glyphs[0]; // .notdef
    }
    return glyph;
};

Font.prototype.glyphIndexToName = function (gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }
    return this.glyphNames.glyphIndexToName(gid);
};

// Retrieve the value of the kerning pair between the left glyph (or its index)
// and the right glyph (or its index). If no kerning pair is found, return 0.
// The kerning value gets added to the advance width when calculating the spacing
// between glyphs.
Font.prototype.getKerningValue = function (leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    var gposKerning = this.getGposKerningValue;
    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :
        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);
};

// Helper function that invokes the given callback for each glyph in the given text.
// The callback gets `(glyph, x, y, fontSize, options)`.
Font.prototype.forEachGlyph = function (text, x, y, fontSize, options, callback) {
    var kerning, fontScale, glyphs, i, glyph, kerningValue;
    if (!this.supported) {
        return;
    }
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || {};
    kerning = options.kerning === undefined ? true : options.kerning;
    fontScale = 1 / this.unitsPerEm * fontSize;
    glyphs = this.stringToGlyphs(text);
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        callback(glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }
        if (kerning && i < glyphs.length - 1) {
            kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }
    }
};

// Create a Path object that represents the given text.
//
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
//
// Returns a Path object.
Font.prototype.getPath = function (text, x, y, fontSize, options) {
    var fullPath = new path.Path();
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        var path = glyph.getPath(x, y, fontSize);
        fullPath.extend(path);
    });
    return fullPath;
};

// Draw the text on the given drawing context.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.draw = function (ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

// Draw the points of all glyphs in the text.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawPoints = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawPoints(ctx, x, y, fontSize);
    });
};

// Draw lines indicating important font measurements for all glyphs in the text.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - A 2D drawing context, like Canvas.
// text - The text to create.
// x - Horizontal position of the beginning of the text. (default: 0)
// y - Vertical position of the *baseline* of the text. (default: 0)
// fontSize - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`. (default: 72)
// Options is an optional object that contains:
// - kerning - Whether to take kerning information into account. (default: true)
Font.prototype.drawMetrics = function (ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function (glyph, x, y, fontSize) {
        glyph.drawMetrics(ctx, x, y, fontSize);
    });
};

// Validate
Font.prototype.validate = function () {
    var warnings = [];
    var font = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertStringAttribute(attrName) {
        assert(font[attrName] && font[attrName].trim().length > 0, 'No ' + attrName + ' specified.');
    }

    // Identification information
    assertStringAttribute('familyName');
    assertStringAttribute('weightName');
    assertStringAttribute('manufacturer');
    assertStringAttribute('copyright');
    assertStringAttribute('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
Font.prototype.toTables = function () {
    return sfnt.fontToTable(this);
};

Font.prototype.toBuffer = function () {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }
    return buffer;
};

// Initiate a download of the OpenType font.
Font.prototype.download = function () {
    var fileName = this.familyName.replace(/\s/g, '') + '-' + this.styleName + '.otf';
    var buffer = this.toBuffer();

    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    window.requestFileSystem(window.TEMPORARY, buffer.byteLength, function (fs) {
        fs.root.getFile(fileName, {create: true}, function (fileEntry) {
            fileEntry.createWriter(function (writer) {
                var dataView = new DataView(buffer);
                var blob = new Blob([dataView], {type: 'font/opentype'});
                writer.write(blob);

                 writer.addEventListener('writeend', function () {
                    // Navigating to the file will download it.
                    location.href = fileEntry.toURL();
                 }, false);
            });
        });
    }, function (err) {
        throw err;
    });
};

exports.Font = Font;

},{"./encoding":3,"./path":8,"./tables/sfnt":23}],5:[function(_dereq_,module,exports){
// The Glyph object

'use strict';

var check = _dereq_('./check');
var draw = _dereq_('./draw');
var path = _dereq_('./path');

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
function Glyph(options) {
    this.font = options.font || null;
    this.index = options.index || 0;
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];
    this.xMin = options.xMin || 0;
    this.yMin = options.yMin || 0;
    this.xMax = options.xMax || 0;
    this.yMax = options.yMax || 0;
    this.advanceWidth = options.advanceWidth || 0;
    this.path = options.path || null;
}

Glyph.prototype.addUnicode = function (unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }
    this.unicodes.push(unicode);
};

// Convert the glyph to a Path we can draw on a drawing context.
//
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.getPath = function (x, y, fontSize) {
    var scale, p, commands, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    scale = 1 / this.font.unitsPerEm * fontSize;
    p = new path.Path();
    commands = this.path.commands;
    for (var i = 0; i < commands.length; i += 1) {
        cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                               x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * scale), y + (-cmd.y1 * scale),
                      x + (cmd.x2 * scale), y + (-cmd.y2 * scale),
                      x + (cmd.x * scale), y + (-cmd.y * scale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }
    return p;
};

// Split the glyph into contours.
// This function is here for backwards compatibility, and to
// provide raw access to the TrueType glyph outlines.
Glyph.prototype.getContours = function () {
    var contours, currentContour, i, pt;
    if (this.points === undefined) {
        return [];
    }
    contours = [];
    currentContour = [];
    for (i = 0; i < this.points.length; i += 1) {
        pt = this.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

// Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
Glyph.prototype.getMetrics = function () {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }
        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }
        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }
    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: 0
    };
    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

// Draw the glyph on the given context.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.draw = function (ctx, x, y, fontSize) {
    this.getPath(x, y, fontSize).draw(ctx);
};

// Draw the points of the glyph.
// On-curve points will be drawn in blue, off-curve points will be drawn in red.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawPoints = function (ctx, x, y, fontSize) {

    function drawCircles(l, x, y, scale) {
        var j, PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }
        ctx.closePath();
        ctx.fill();
    }

    var scale, i, blueCircles, redCircles, path, cmd;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;

    blueCircles = [];
    redCircles = [];
    path = this.path;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }
        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }
        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

// Draw lines indicating important font measurements.
// Black lines indicate the origin of the coordinate system (point 0,0).
// Blue lines indicate the glyph bounding box.
// Green line indicates the advance width of the glyph.
//
// ctx - The drawing context.
// x - Horizontal position of the glyph. (default: 0)
// y - Vertical position of the *baseline* of the glyph. (default: 0)
// fontSize - Font size, in pixels (default: 72).
Glyph.prototype.drawMetrics = function (ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.font.unitsPerEm * fontSize;
    ctx.lineWidth = 1;
    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);
    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (this.xMin * scale), -10000, x + (this.xMin * scale), 10000);
    draw.line(ctx, x + (this.xMax * scale), -10000, x + (this.xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-this.yMin * scale), 10000, y + (-this.yMin * scale));
    draw.line(ctx, -10000, y + (-this.yMax * scale), 10000, y + (-this.yMax * scale));
    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (this.advanceWidth * scale), -10000, x + (this.advanceWidth * scale), 10000);
};

exports.Glyph = Glyph;

},{"./check":1,"./draw":2,"./path":8}],6:[function(_dereq_,module,exports){
// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2014 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global ArrayBuffer, DataView, Uint8Array, XMLHttpRequest  */

'use strict';

var encoding = _dereq_('./encoding');
var _font = _dereq_('./font');
var glyph = _dereq_('./glyph');
var parse = _dereq_('./parse');
var path = _dereq_('./path');

var cmap = _dereq_('./tables/cmap');
var cff = _dereq_('./tables/cff');
var glyf = _dereq_('./tables/glyf');
var gpos = _dereq_('./tables/gpos');
var head = _dereq_('./tables/head');
var hhea = _dereq_('./tables/hhea');
var hmtx = _dereq_('./tables/hmtx');
var kern = _dereq_('./tables/kern');
var loca = _dereq_('./tables/loca');
var maxp = _dereq_('./tables/maxp');
var _name = _dereq_('./tables/name');
var os2 = _dereq_('./tables/os2');
var post = _dereq_('./tables/post');

// File loaders /////////////////////////////////////////////////////////

// Convert a Node.js Buffer to an ArrayBuffer
function toArrayBuffer(buffer) {
    var i,
        arrayBuffer = new ArrayBuffer(buffer.length),
        data = new Uint8Array(arrayBuffer);

    for (i = 0; i < buffer.length; i += 1) {
        data[i] = buffer[i];
    }

    return arrayBuffer;
}

function loadFromFile(path, callback) {
    var fs = _dereq_('fs');
    fs.readFile(path, function (err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, toArrayBuffer(buffer));
    });
}

function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function () {
        if (request.status !== 200) {
            return callback('Font could not be loaded: ' + request.statusText);
        }
        return callback(null, request.response);
    };
    request.send();
}

// Public API ///////////////////////////////////////////////////////////

// Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
// If the file could not be parsed (most likely because it contains Postscript outlines)
// we return an empty Font object with the `supported` flag set to `false`.
function parseBuffer(buffer) {
    var font, data, version, numTables, i, p, tag, offset, hmtxOffset, glyfOffset, locaOffset,
        cffOffset, kernOffset, gposOffset, indexToLocFormat, numGlyphs, locaTable,
        shortVersion;
    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.

    font = new _font.Font();
    data = new DataView(buffer, 0);

    version = parse.getFixed(data, 0);
    if (version === 1.0) {
        font.outlinesFormat = 'truetype';
    } else {
        version = parse.getTag(data, 0);
        if (version === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType version ' + version);
        }
    }

    numTables = parse.getUShort(data, 4);

    // Offset into the table records.
    p = 12;
    for (i = 0; i < numTables; i += 1) {
        tag = parse.getTag(data, p);
        offset = parse.getULong(data, p + 8);
        switch (tag) {
        case 'cmap':
            font.tables.cmap = cmap.parse(data, offset);
            font.encoding = new encoding.CmapEncoding(font.tables.cmap);
            if (!font.encoding) {
                font.supported = false;
            }
            break;
        case 'head':
            font.tables.head = head.parse(data, offset);
            font.unitsPerEm = font.tables.head.unitsPerEm;
            indexToLocFormat = font.tables.head.indexToLocFormat;
            break;
        case 'hhea':
            font.tables.hhea = hhea.parse(data, offset);
            font.ascender = font.tables.hhea.ascender;
            font.descender = font.tables.hhea.descender;
            font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
            break;
        case 'hmtx':
            hmtxOffset = offset;
            break;
        case 'maxp':
            font.tables.maxp = maxp.parse(data, offset);
            font.numGlyphs = numGlyphs = font.tables.maxp.numGlyphs;
            break;
        case 'name':
            font.tables.name = _name.parse(data, offset);
            font.familyName = font.tables.name.fontFamily;
            font.styleName = font.tables.name.fontSubfamily;
            break;
        case 'OS/2':
            font.tables.os2 = os2.parse(data, offset);
            break;
        case 'post':
            font.tables.post = post.parse(data, offset);
            font.glyphNames = new encoding.GlyphNames(font.tables.post);
            break;
        case 'glyf':
            glyfOffset = offset;
            break;
        case 'loca':
            locaOffset = offset;
            break;
        case 'CFF ':
            cffOffset = offset;
            break;
        case 'kern':
            kernOffset = offset;
            break;
        case 'GPOS':
            gposOffset = offset;
            break;
        }
        p += 16;
    }

    if (glyfOffset && locaOffset) {
        shortVersion = indexToLocFormat === 0;
        locaTable = loca.parse(data, locaOffset, numGlyphs, shortVersion);
        font.glyphs = glyf.parse(data, glyfOffset, locaTable, font);
        hmtx.parse(data, hmtxOffset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
        encoding.addGlyphNames(font);
    } else if (cffOffset) {
        cff.parse(data, cffOffset, font);
        encoding.addGlyphNames(font);
    } else {
        font.supported = false;
    }

    if (font.supported) {
        if (kernOffset) {
            font.kerningPairs = kern.parse(data, kernOffset);
        } else {
            font.kerningPairs = {};
        }
        if (gposOffset) {
            gpos.parse(data, gposOffset, font);
        }
    }

    return font;
}

// Asynchronously load the font from a URL or a filesystem. When done, call the callback
// with two arguments `(err, font)`. The `err` will be null on success,
// the `font` is a Font object.
//
// We use the node.js callback convention so that
// opentype.js can integrate with frameworks like async.js.
function load(url, callback) {
    var isNode = typeof window === 'undefined';
    var loadFn = isNode ? loadFromFile : loadFromUrl;
    loadFn(url, function (err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font = parseBuffer(arrayBuffer);
        if (!font.supported) {
            return callback('Font is not supported (is this a Postscript font?)');
        }
        return callback(null, font);
    });
}

exports.Font = _font.Font;
exports.Glyph = glyph.Glyph;
exports.Path = path.Path;
exports.parse = parseBuffer;
exports.load = load;

},{"./encoding":3,"./font":4,"./glyph":5,"./parse":7,"./path":8,"./tables/cff":10,"./tables/cmap":11,"./tables/glyf":12,"./tables/gpos":13,"./tables/head":14,"./tables/hhea":15,"./tables/hmtx":16,"./tables/kern":17,"./tables/loca":18,"./tables/maxp":19,"./tables/name":20,"./tables/os2":21,"./tables/post":22,"fs":undefined}],7:[function(_dereq_,module,exports){
// Parsing utility functions

'use strict';

// Retrieve an unsigned byte from the DataView.
exports.getByte = function getByte(dataView, offset) {
    return dataView.getUint8(offset);
};

exports.getCard8 = exports.getByte;

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
exports.getUShort = function (dataView, offset) {
    return dataView.getUint16(offset, false);
};

exports.getCard16 = exports.getUShort;

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
exports.getShort = function (dataView, offset) {
    return dataView.getInt16(offset, false);
};

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
exports.getULong = function (dataView, offset) {
    return dataView.getUint32(offset, false);
};

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
exports.getFixed = function (dataView, offset) {
    var decimal, fraction;
    decimal = dataView.getInt16(offset, false);
    fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
};

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
exports.getTag = function (dataView, offset) {
    var tag = '', i;
    for (i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }
    return tag;
};

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
exports.getOffset = function (dataView, offset, offSize) {
    var i, v;
    v = 0;
    for (i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }
    return v;
};

// Retrieve a number of bytes from start offset to the end offset from the DataView.
exports.getBytes = function (dataView, startOffset, endOffset) {
    var bytes, i;
    bytes = [];
    for (i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }
    return bytes;
};

// Convert the list of bytes to a string.
exports.bytesToString = function (bytes) {
    var s, i;
    s = '';
    for (i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }
    return s;
};

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function () {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function () {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function () {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};
Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function () {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function () {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseFixed = function () {
    var v = exports.getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function (count) {
    var offsets = new Array(count),
        dataView = this.data,
        offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = exports.getUShort(dataView, offset);
        offset += 2;
    }
    this.relativeOffset += count * 2;
    return offsets;
};

Parser.prototype.parseString = function (length) {
    var dataView = this.data,
        offset = this.offset + this.relativeOffset,
        string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }
    return string;
};

Parser.prototype.parseTag = function () {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
Parser.prototype.parseLongDateTime = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset + 4);
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseFixed = function() {
    var v = exports.getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v / 65536;
};

Parser.prototype.parseVersion = function() {
    var major = exports.getUShort(this.data, this.offset + this.relativeOffset);
    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // This returns the correct number if minor = 0xN000 where N is 0-9
    var minor = exports.getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    return major + minor / 0x1000 / 10;
};

Parser.prototype.skip = function (type, amount) {
    if (amount === undefined) {
        amount = 1;
    }
    this.relativeOffset += typeOffsets[type] * amount;
};

exports.Parser = Parser;

},{}],8:[function(_dereq_,module,exports){
// Geometric objects

'use strict';

// A bézier path containing a set of path commands similar to a SVG path.
// Paths can be drawn on a context using `draw`.
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

Path.prototype.moveTo = function (x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

Path.prototype.lineTo = function (x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

Path.prototype.curveTo = Path.prototype.bezierCurveTo = function (x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function (x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

Path.prototype.close = Path.prototype.closePath = function () {
    this.commands.push({
        type: 'Z'
    });
};

// Add the given path or list of commands to the commands of this path.
Path.prototype.extend = function (pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    }
    Array.prototype.push.apply(this.commands, pathOrCommands);
};

// Draw the path to a 2D context.
Path.prototype.draw = function (ctx) {
    var i, cmd;
    ctx.beginPath();
    for (i = 0; i < this.commands.length; i += 1) {
        cmd = this.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }
    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }
    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

// Convert the Path to a string of path data instructions
// See http://www.w3.org/TR/SVG/paths.html#PathData
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toPathData = function (decimalPlaces) {
    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }
            s += floatToString(v);
        }
        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }
    return d;
};

// Convert the path to a SVG <path> element, as a string.
// Parameters:
// - decimalPlaces: The amount of decimal places for floating-point values (default: 2)
Path.prototype.toSVG = function (decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill & this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }
    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }
    svg += '/>';
    return svg;
};

exports.Path = Path;

},{}],9:[function(_dereq_,module,exports){
// Table metadata

'use strict';

var check = _dereq_('./check');
var encode = _dereq_('./types').encode;
var sizeOf = _dereq_('./types').sizeOf;

function Table(tableName, fields, options) {
    var i;
    for (i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this[field.name] = field.value;
    }
    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (i = 0; i < optionKeys.length; i += 1) {
            var k = optionKeys[i];
            var v = options[k];
            if (this[k] !== undefined) {
                this[k] = v;
            }
        }
    }
}

Table.prototype.sizeOf = function () {
    var v = 0;
    for (var i = 0; i < this.fields.length; i += 1) {
        var field = this.fields[i];
        var value = this[field.name];
        if (value === undefined) {
            value = field.value;
        }
        if (typeof value.sizeOf === 'function') {
            v += value.sizeOf();
        } else {
            var sizeOfFunction = sizeOf[field.type];
            check.assert(typeof sizeOfFunction === 'function', 'Could not find sizeOf function for field' + field.name);
            v += sizeOfFunction(value);
        }
    }
    return v;
};

Table.prototype.encode = function () {
    return encode.TABLE(this);
};

exports.Table = Table;

},{"./check":1,"./types":24}],10:[function(_dereq_,module,exports){
// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

'use strict';

var encoding = _dereq_('../encoding');
var _glyph = _dereq_('../glyph');
var parse = _dereq_('../parse');
var path = _dereq_('../path');
var table = _dereq_('../table');

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets, objects, count, endOffset, offsetSize, objectOffset, pos, i, value;
    offsets = [];
    objects = [];
    count = parse.getCard16(data, start);
    if (count !== 0) {
        offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        pos = start + 3;
        for (i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }
        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }
    for (i = 0; i < offsets.length - 1; i += 1) {
        value = parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }
        objects.push(value);
    }
    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s, eof, lookup, b, n1, n2;
    s = '';
    eof = 15;
    lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        b = parser.parseByte();
        n1 = b >> 4;
        n2 = b & 15;

        if (n1 === eof) {
            break;
        }
        s += lookup[n1];

        if (n2 === eof) {
            break;
        }
        s += lookup[n2];
    }
    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1, b2, b3, b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }
    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }
    if (b0 === 30) {
        return parseFloatOperand(parser);
    }
    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }
    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }
    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }
    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o, key, values, i, value;
    o = {};
    for (i = 0; i < entries.length; i += 1) {
        key = entries[i][0];
        values = entries[i][1];
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }
        if (o.hasOwnProperty(key)) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }
        o[key] = value;
    }
    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    var parser, entries, operands, op;
    start = start !== undefined ? start : 0;
    parser = new parse.Parser(data, start);
    entries = [];
    operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        op = parser.parseByte();
        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }
            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }
    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = encoding.cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }
    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var i, m, value, newDict;
    newDict = {};
    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (i = 0; i < meta.length; i += 1) {
        m = meta[i];
        value = dict[m.op];
        if (value === undefined) {
            value = m.value !== undefined ? m.value : null;
        }
        if (m.type === 'SID') {
            value = getCFFString(strings, value);
        }
        newDict[m.name] = value;
    }
    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {name: 'fontMatrix', op: 1207, type: ['real', 'real', 'real', 'real', 'real', 'real'], value: [0.001, 0, 0, 0.001, 0, 0]},
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict;
    dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict;
    dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var parser, format, charset, i, sid, count;
    parser = new parse.Parser(data, start);
    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    charset = ['.notdef'];

    format = parser.parseCard8();
    if (format === 0) {
        for (i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (i = 0; i <= count; i += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var enc, parser, format, nCodes, i, code, nRanges, first, nLeft, j;
    enc = {};
    parser = new parse.Parser(data, start);
    format = parser.parseCard8();
    if (format === 0) {
        nCodes = parser.parseCard8();
        for (i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        nRanges = parser.parseCard8();
        code = 1;
        for (i = 0; i < nRanges; i += 1) {
            first = parser.parseCard8();
            nLeft = parser.parseCard8();
            for (j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }
    return new encoding.CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(code, font, index) {
    var p, glyph, stack, nStems, haveWidth, width, x, y, c1x, c1y, c2x, c2y, v;
    p = new path.Path();
    stack = [];
    nStems = 0;
    haveWidth = false;
    width = font.defaultWidthX;
    x = y = 0;

    function parseStems() {
        var hasWidthArg;
        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + font.nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse(code) {
        var i, b1, b2, b3, b4, codeIndex, subrCode;
        i = 0;
        while (i < code.length) {
            v = code[i];
            i += 1;
            switch (v) {
            case 1: // hstem
                parseStems();
                break;
            case 3: // vstem
                parseStems();
                break;
            case 4: // vmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                p.moveTo(x, y);
                break;
            case 5: // rlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 6: // hlineto
                while (stack.length > 0) {
                    x += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 7: // vlineto
                while (stack.length > 0) {
                    y += stack.shift();
                    p.lineTo(x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    x += stack.shift();
                    p.lineTo(x, y);
                }
                break;
            case 8: // rrcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 10: // callsubr
                codeIndex = stack.pop() + font.subrsBias;
                subrCode = font.subrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 11: // return
                return;
            case 12: // escape
                v = code[i];
                i += 1;
                break;
            case 14: // endchar
                if (stack.length > 0 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                p.closePath();
                break;
            case 18: // hstemhm
                parseStems();
                break;
            case 19: // hintmask
            case 20: // cntrmask
                parseStems();
                i += (nStems + 7) >> 3;
                break;
            case 21: // rmoveto
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 22: // hmoveto
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + font.nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                p.moveTo(x, y);
                break;
            case 23: // vstemhm
                parseStems();
                break;
            case 24: // rcurveline
                while (stack.length > 2) {
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                x += stack.shift();
                y += stack.shift();
                p.lineTo(x, y);
                break;
            case 25: // rlinecurve
                while (stack.length > 6) {
                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                p.curveTo(c1x, c1y, c2x, c2y, x, y);
                break;
            case 26: // vvcurveto
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 27: // hhcurveto
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 28: // shortint
                b1 = code[i];
                b2 = code[i + 1];
                stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                i += 2;
                break;
            case 29: // callgsubr
                codeIndex = stack.pop() + font.gsubrsBias;
                subrCode = font.gsubrs[codeIndex];
                if (subrCode) {
                    parse(subrCode);
                }
                break;
            case 30: // vhcurveto
                while (stack.length > 0) {
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            case 31: // hvcurveto
                while (stack.length > 0) {
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    y = c2y + stack.shift();
                    x = c2x + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    if (stack.length === 0) {
                        break;
                    }
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + (stack.length === 1 ? stack.shift() : 0);
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                }
                break;
            default:
                if (v < 32) {
                    console.log('Glyph ' + index + ': unknown operator ' + v);
                } else if (v < 247) {
                    stack.push(v - 139);
                } else if (v < 251) {
                    b1 = code[i];
                    i += 1;
                    stack.push((v - 247) * 256 + b1 + 108);
                } else if (v < 255) {
                    b1 = code[i];
                    i += 1;
                    stack.push(-(v - 251) * 256 - b1 - 108);
                } else {
                    b1 = code[i];
                    b2 = code[i + 1];
                    b3 = code[i + 2];
                    b4 = code[i + 3];
                    i += 4;
                    stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                }
            }
        }
    }

    parse(code);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.path = p;
    glyph.advanceWidth = width;
    return glyph;
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }
    return bias;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    var header, nameIndex, topDictIndex, stringIndex, globalSubrIndex, topDict, privateDictOffset, privateDict,
        subrOffset, subrIndex, charString, charStringsIndex, charset, i;
    font.tables.cff = {};
    header = parseCFFHeader(data, start);
    nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictData = new DataView(new Uint8Array(topDictIndex.objects[0]).buffer);
    topDict = parseCFFTopDict(topDictData, stringIndex.objects);
    font.tables.cff.topDict = topDict;

    privateDictOffset = start + topDict['private'][1];
    privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict['private'][0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        subrOffset = privateDictOffset + privateDict.subrs;
        subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) { // Standard encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) { // Expert encoding
        font.cffEncoding = new encoding.CffEncoding(encoding.cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }
    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = [];
    for (i = 0; i < font.nGlyphs; i += 1) {
        charString = charStringsIndex.objects[i];
        font.glyphs.push(parseCFFCharstring(charString, font, i));
    }
}


// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var i, sid;
    // Is the string in the CFF standard strings?
    i = encoding.cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }
    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + encoding.cffStandardStrings.length;
    } else {
        sid = encoding.cffStandardStrings.length + strings.length;
        strings.push(s);
    }
    return sid;
}

function makeHeader() {
    return new table.Table('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Table('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }
    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {}, i, entry, value;
    for (i = 0; i < meta.length; i += 1) {
        entry = meta[i];
        value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }
            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }
    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Table('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Table('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Table('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }
    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Table('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Table('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }
    return t;
}

function glyphToOps(glyph) {
    var ops = [], path = glyph.path, x, y, i, cmd, dx, dy, dx1, dy1, dx2, dy2;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    x = 0;
    y = 0;
    for (i = 0; i < path.commands.length; i += 1) {
        cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bézier curves, so convert the quad to a bézier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;
            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            }
        }

        if (cmd.type === 'M') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'L') {
            dx = cmd.x - x;
            dy = cmd.y - y;
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'C') {
            dx1 = cmd.x1 - x;
            dy1 = cmd.y1 - y;
            dx2 = cmd.x2 - cmd.x1;
            dy2 = cmd.y2 - cmd.y1;
            dx = cmd.x - cmd.x2;
            dy = cmd.y - cmd.y2;
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = cmd.x;
            y = cmd.y;
        } else if (cmd.type === 'Z') {
            // Contours are closed automatically.
        }
    }
    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Table('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }
    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Table('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makePrivateDictIndex(privateDict) {
    var t = new table.Table('Private DICT INDEX', [
        {name: 'privateDicts', type: 'INDEX', value: []}
    ]);
    t.privateDicts = [{name: 'privateDict_0', type: 'TABLE', value: privateDict}];
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'TABLE'},
        {name: 'nameIndex', type: 'TABLE'},
        {name: 'topDictIndex', type: 'TABLE'},
        {name: 'stringIndex', type: 'TABLE'},
        {name: 'globalSubrIndex', type: 'TABLE'},
        {name: 'charsets', type: 'TABLE'},
        {name: 'charStringsIndex', type: 'TABLE'},
        {name: 'privateDictIndex', type: 'TABLE'}
    ]);

    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyphNames.push(glyphs[i].name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    var privateDict = makePrivateDict(privateAttrs, strings);
    t.privateDictIndex = makePrivateDictIndex(privateDict);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;
    attrs.encoding = 0; // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

exports.parse = parseCFFTable;
exports.make = makeCFFTable;

},{"../encoding":3,"../glyph":5,"../parse":7,"../path":8,"../table":9}],11:[function(_dereq_,module,exports){
// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

'use strict';

var check = _dereq_('../check');
var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var version, numTables, offset, platformId, encodingId, format, segCount,
        endCountParser, startCountParser, idDeltaParser, idRangeOffsetParser, glyphIndexOffset,
        endCount, startCount, i, c, idDelta, idRangeOffset, p, glyphIndex;
    var cmap = {};
    cmap.version = version = parse.getUShort(data, start);
    check.argument(version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numtables = numTables = parse.getUShort(data, start + 2);
    offset = -1;
    for (i = 0; i < numTables; i += 1) {
        platformId = parse.getUShort(data, start + 4 + (i * 8));
        encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 1 || encodingId === 0)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }
    if (offset === -1) {
        // There is no cmap table in the font that we support, so return null.
        // This font will be marked as unsupported.
        return null;
    }

    p = new parse.Parser(data, start + offset);
    cmap.format = format = p.parseUShort();
    check.argument(format === 4, 'Only format 4 cmap tables are supported.');
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();
    // segCount is stored x 2.
    cmap.segCount = segCount = p.parseUShort() >> 1;
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};

    endCountParser = new parse.Parser(data, start + offset + 14);
    startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (i = 0; i < segCount - 1; i += 1) {
        endCount = endCountParser.parseUShort();
        startCount = startCountParser.parseUShort();
        idDelta = idDeltaParser.parseShort();
        idRangeOffset = idRangeOffsetParser.parseUShort();
        for (c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);
                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;
                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }
            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

function makeCmapTable(glyphs) {
    var i, j, glyph;
    var t = new table.Table('cmap', [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: 1},
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: 12},
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        for (j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }
    }
    addTerminatorSegment(t);

    var segCount;
    segCount = t.segments.length;
    t.segCountX2 = segCount * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

     // Set up parallel segment arrays.
    var endCounts = [],
        startCounts = [],
        idDeltas = [],
        idRangeOffsets = [],
        glyphIds = [];

    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];
        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
        if (segment.glyphId !== undefined) {
            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
        }
    }
    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;
    return t;
}

exports.parse = parseCmapTable;
exports.make = makeCmapTable;

},{"../check":1,"../parse":7,"../table":9}],12:[function(_dereq_,module,exports){
// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

'use strict';

var check = _dereq_('../check');
var _glyph = _dereq_('../glyph');
var parse = _dereq_('../parse');
var path = _dereq_('../path');

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }
        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }
    return v;
}

// Parse a TrueType glyph.
function parseGlyph(data, start, index, font) {
    var p, glyph, flag, i, j, flags,
        endPointIndices, numberOfCoordinates, repeatCount, points, point, px, py,
        component, moreComponents;
    p = new parse.Parser(data, start);
    glyph = new _glyph.Glyph({font: font, index: index});
    glyph.numberOfContours = p.parseShort();
    glyph.xMin = p.parseShort();
    glyph.yMin = p.parseShort();
    glyph.xMax = p.parseShort();
    glyph.yMax = p.parseShort();
    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        endPointIndices = glyph.endPointIndices = [];
        for (i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (i = 0; i < glyph.instructionLength; i += 1) {
            glyph.instructions.push(p.parseByte());
        }

        numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (i = 0; i < numberOfCoordinates; i += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                repeatCount = p.parseByte();
                for (j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i += 1;
                }
            }
        }
        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            points = [];
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;
                    points.push(point);
                }
                px = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                py = 0;
                for (i = 0; i < numberOfCoordinates; i += 1) {
                    flag = flags[i];
                    point = points[i];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }
            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            component = {
                glyphIndex: p.parseUShort(),
                 xScale: 1,
                 scale01: 0,
                 scale10: 0,
                 yScale: 1,
                 dx: 0,
                 dy: 0
             };
            if ((flags & 1) > 0) {
                // The arguments are words
                component.dx = p.parseShort();
                component.dy = p.parseShort();
            } else {
                // The arguments are bytes
                component.dx = p.parseChar();
                component.dy = p.parseChar();
            }
            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
    }
    return glyph;
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints, i, pt, newPt;
    newPoints = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }
    return newPoints;
}


function getContours(points) {
    var contours, currentContour, i, pt;
    contours = [];
    currentContour = [];
    for (i = 0; i < points.length; i += 1) {
        pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }
    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p, contours, i, realFirstPoint, j, contour, pt, firstPt,
        prevPt, midPt, curvePt, lastPt;
    p = new path.Path();
    if (!points) {
        return p;
    }
    contours = getContours(points);
    for (i = 0; i < contours.length; i += 1) {
        contour = contours[i];
        firstPt = contour[0];
        lastPt = contour[contour.length - 1];
        if (firstPt.onCurve) {
            curvePt = null;
            // The first point will be consumed by the moveTo command,
            // so skip it in the loop.
            realFirstPoint = true;
        } else {
            if (lastPt.onCurve) {
                // If the first point is off-curve and the last point is on-curve,
                // start at the last point.
                firstPt = lastPt;
            } else {
                // If both first and last points are off-curve, start at their middle.
                firstPt = { x: (firstPt.x + lastPt.x) / 2, y: (firstPt.y + lastPt.y) / 2 };
            }
            curvePt = firstPt;
            // The first point is synthesized, so don't skip the real first point.
            realFirstPoint = false;
        }
        p.moveTo(firstPt.x, firstPt.y);

        for (j = realFirstPoint ? 1 : 0; j < contour.length; j += 1) {
            pt = contour[j];
            prevPt = j === 0 ? firstPt : contour[j - 1];
            if (prevPt.onCurve && pt.onCurve) {
                // This is a straight line.
                p.lineTo(pt.x, pt.y);
            } else if (prevPt.onCurve && !pt.onCurve) {
                curvePt = pt;
            } else if (!prevPt.onCurve && !pt.onCurve) {
                midPt = { x: (prevPt.x + pt.x) / 2, y: (prevPt.y + pt.y) / 2 };
                p.quadraticCurveTo(prevPt.x, prevPt.y, midPt.x, midPt.y);
                curvePt = pt;
            } else if (!prevPt.onCurve && pt.onCurve) {
                // Previous point off-curve, this point on-curve.
                p.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                curvePt = null;
            } else {
                throw new Error('Invalid state.');
            }
        }
        if (firstPt !== lastPt) {
            // Connect the last and first points
            if (curvePt) {
                p.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
            } else {
                p.lineTo(firstPt.x, firstPt.y);
            }
        }
    }
    p.closePath();
    return p;
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs, i, j, offset, nextOffset, glyph,
        component, componentGlyph, transformedPoints;
    glyphs = [];
    // The last element of the loca table is invalid.
    for (i = 0; i < loca.length - 1; i += 1) {
        offset = loca[i];
        nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(parseGlyph(data, start + offset, i, font));
        } else {
            glyphs.push(new _glyph.Glyph({font: font, index: i}));
        }
    }
    // Go over the glyphs again, resolving the composite glyphs.
    for (i = 0; i < glyphs.length; i += 1) {
        glyph = glyphs[i];
        if (glyph.isComposite) {
            for (j = 0; j < glyph.components.length; j += 1) {
                component = glyph.components[j];
                componentGlyph = glyphs[component.glyphIndex];
                if (componentGlyph.points) {
                    transformedPoints = transformPoints(componentGlyph.points, component);
                    glyph.points = glyph.points.concat(transformedPoints);
                }
            }
        }
        glyph.path = getPath(glyph.points);
    }
    return glyphs;
}

exports.parse = parseGlyfTable;

},{"../check":1,"../glyph":5,"../parse":7,"../path":8}],13:[function(_dereq_,module,exports){
// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

'use strict';

var check = _dereq_('../check');
var parse = _dereq_('../parse');

// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.
// These lists are unused by now, this function is just the basis for a real parsing.
function parseTaggedListTable(data, start) {
    var p = new parse.Parser(data, start),
        n = p.parseUShort(),
        list = [];
    for (var i = 0; i < n; i++) {
        list[p.parseTag()] = { offset: p.parseUShort() };
    }
    return list;
}

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// Format 1 is a simple list of glyph ids,
// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.
function parseCoverageTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort(),
        count =  p.parseUShort();
    if (format === 1) {
        return p.parseUShortList(count);
    }
    else if (format === 2) {
        var i, begin, end, index, coverage = [];
        for (; count--;) {
            begin = p.parseUShort();
            end = p.parseUShort();
            index = p.parseUShort();
            for (i = begin; i <= end; i++) {
                coverage[index++] = i;
            }
        }
        return coverage;
    }
}

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// Returns a function that gets a class value from a glyph ID.
function parseClassDefTable(data, start) {
    var p = new parse.Parser(data, start),
        format = p.parseUShort();
    if (format === 1) {
        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.
        var startGlyph = p.parseUShort(),
            glyphCount = p.parseUShort(),
            classes = p.parseUShortList(glyphCount);
        return function(glyphID) {
            return classes[glyphID - startGlyph] || 0;
        };
    }
    else if (format === 2) {
        // Format 2 defines multiple groups of glyph indices that belong to the same class.
        var rangeCount = p.parseUShort(),
            startGlyphs = [],
            endGlyphs = [],
            classValues = [];
        for (var i = 0; i < rangeCount; i++) {
            startGlyphs[i] = p.parseUShort();
            endGlyphs[i] = p.parseUShort();
            classValues[i] = p.parseUShort();
        }
        return function(glyphID) {
            var l, c, r;
            l = 0;
            r = startGlyphs.length - 1;
            while (l < r) {
                c = (l + r + 1) >> 1;
                if (glyphID < startGlyphs[c]) {
                    r = c - 1;
                } else {
                    l = c;
                }
            }
            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {
                return classValues[l] || 0;
            }
            return 0;
        };
    }
}

// Parse a pair adjustment positioning subtable, format 1 or format 2
// The subtable is returned in the form of a lookup function.
function parsePairPosSubTable(data, start) {
    var p = new parse.Parser(data, start);
    var format, coverageOffset, coverage, valueFormat1, valueFormat2,
        sharedPairSets, firstGlyph, secondGlyph, value1, value2;
    // This part is common to format 1 and format 2 subtables
    format = p.parseUShort();
    coverageOffset = p.parseUShort();
    coverage = parseCoverageTable(data, start+coverageOffset);
    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph
    // Only valueFormat1=4 and valueFormat2=0 is supported.
    valueFormat1 = p.parseUShort();
    valueFormat2 = p.parseUShort();
    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;
    sharedPairSets = {};
    if (format === 1) {
        // Pair Positioning Adjustment: Format 1
        var pairSetCount, pairSetOffsets, pairSetOffset, sharedPairSet, pairValueCount, pairSet;
        pairSetCount = p.parseUShort();
        pairSet = [];
        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index
        pairSetOffsets = p.parseOffset16List(pairSetCount);
        for (firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {
            pairSetOffset = pairSetOffsets[firstGlyph];
            sharedPairSet = sharedPairSets[pairSetOffset];
            if (!sharedPairSet) {
                // Parse a pairset table in a pair adjustment subtable format 1
                sharedPairSet = {};
                p.relativeOffset = pairSetOffset;
                pairValueCount = p.parseUShort();
                for (; pairValueCount--;) {
                    secondGlyph = p.parseUShort();
                    if (valueFormat1) value1 = p.parseShort();
                    if (valueFormat2) value2 = p.parseShort();
                    // We only support valueFormat1 = 4 and valueFormat2 = 0,
                    // so value1 is the XAdvance and value2 is empty.
                    sharedPairSet[secondGlyph] = value1;
                }
            }
            pairSet[coverage[firstGlyph]] = sharedPairSet;
        }
        return function(leftGlyph, rightGlyph) {
            var pairs = pairSet[leftGlyph];
            if (pairs) return pairs[rightGlyph];
        };
    }
    else if (format === 2) {
        // Pair Positioning Adjustment: Format 2
        var classDef1Offset, classDef2Offset, class1Count, class2Count, i, j,
            getClass1, getClass2, kerningMatrix, kerningRow, covered;
        classDef1Offset = p.parseUShort();
        classDef2Offset = p.parseUShort();
        class1Count = p.parseUShort();
        class2Count = p.parseUShort();
        getClass1 = parseClassDefTable(data, start+classDef1Offset);
        getClass2 = parseClassDefTable(data, start+classDef2Offset);

        // Parse kerning values by class pair.
        kerningMatrix = [];
        for (i = 0; i < class1Count; i++) {
            kerningRow = kerningMatrix[i] = [];
            for (j = 0; j < class2Count; j++) {
                if (valueFormat1) value1 = p.parseShort();
                if (valueFormat2) value2 = p.parseShort();
                // We only support valueFormat1 = 4 and valueFormat2 = 0,
                // so value1 is the XAdvance and value2 is empty.
                kerningRow[j] = value1;
            }
        }

        // Convert coverage list to a hash
        covered = {};
        for(i = 0; i < coverage.length; i++) covered[coverage[i]] = 1;

        // Get the kerning value for a specific glyph pair.
        return function(leftGlyph, rightGlyph) {
            if (!covered[leftGlyph]) return;
            var class1 = getClass1(leftGlyph),
                class2 = getClass2(rightGlyph),
                kerningRow = kerningMatrix[class1];
                
            if (kerningRow) {
                return kerningRow[class2];
            }
        };
    }
}

// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).
function parseLookupTable(data, start) {
    var p = new parse.Parser(data, start);
    var table, lookupType, lookupFlag, useMarkFilteringSet, subTableCount, subTableOffsets, subtables, i;
    lookupType = p.parseUShort();
    lookupFlag = p.parseUShort();
    useMarkFilteringSet = lookupFlag & 0x10;
    subTableCount = p.parseUShort();
    subTableOffsets = p.parseOffset16List(subTableCount);
    table = {
        lookupType: lookupType,
        lookupFlag: lookupFlag,
        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1
    };
    // LookupType 2, Pair adjustment
    if (lookupType === 2) {
        subtables = [];
        for (i = 0; i < subTableCount; i++) {
            subtables.push(parsePairPosSubTable(data, start + subTableOffsets[i]));
        }
        // Return a function which finds the kerning values in the subtables.
        table.getKerningValue = function(leftGlyph, rightGlyph) {
            for (var i = subtables.length; i--;) {
                var value = subtables[i](leftGlyph, rightGlyph);
                if (value !== undefined) return value;
            }
            return 0;
        };
    }
    return table;
}

// Parse the `GPOS` table which contains, among other things, kerning pairs.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm
function parseGposTable(data, start, font) {
    var p, tableVersion, lookupListOffset, scriptList, i, featureList, lookupCount,
        lookupTableOffsets, lookupListAbsoluteOffset, table;

    p = new parse.Parser(data, start);
    tableVersion = p.parseFixed();
    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');

    // ScriptList and FeatureList - ignored for now
    scriptList = parseTaggedListTable(data, start+p.parseUShort());
    // 'kern' is the feature we are looking for.
    featureList = parseTaggedListTable(data, start+p.parseUShort());

    // LookupList
    lookupListOffset = p.parseUShort();
    p.relativeOffset = lookupListOffset;
    lookupCount = p.parseUShort();
    lookupTableOffsets = p.parseOffset16List(lookupCount);
    lookupListAbsoluteOffset = start + lookupListOffset;
    for (i = 0; i < lookupCount; i++) {
        table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);
        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;
    }
}

exports.parse = parseGposTable;

},{"../check":1,"../parse":7}],14:[function(_dereq_,module,exports){
// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

'use strict';

var check = _dereq_('../check');
var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {},
        p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();     // 50
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: 0},
        {name: 'modified', type: 'LONGDATETIME', value: 0},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

exports.parse = parseHeadTable;
exports.make = makeHeadTable;

},{"../check":1,"../parse":7,"../table":9}],15:[function(_dereq_,module,exports){
// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

'use strict';

var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {},
        p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseHheaTable;
exports.make = makeHheaTable;

},{"../parse":7,"../table":9}],16:[function(_dereq_,module,exports){
// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

'use strict';

var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var p, i, glyph, advanceWidth, leftSideBearing;
    p = new parse.Parser(data, start);
    for (i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }
        glyph = glyphs[i];
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }
    return t;
}

exports.parse = parseHmtxTable;
exports.make = makeHmtxTable;




},{"../parse":7,"../table":9}],17:[function(_dereq_,module,exports){
// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

'use strict';

var check = _dereq_('../check');
var parse = _dereq_('../parse');

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var pairs, p, tableVersion, subTableVersion, nPairs,
        i, leftIndex, rightIndex, value;
    pairs = {};
    p = new parse.Parser(data, start);
    tableVersion = p.parseUShort();
    check.argument(tableVersion === 0, 'Unsupported kern table version.');
    // Skip nTables.
    p.skip('uShort', 1);
    subTableVersion = p.parseUShort();
    check.argument(subTableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subTableLength, subTableCoverage
    p.skip('uShort', 2);
    nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (i = 0; i < nPairs; i += 1) {
        leftIndex = p.parseUShort();
        rightIndex = p.parseUShort();
        value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

exports.parse = parseKernTable;

},{"../check":1,"../parse":7}],18:[function(_dereq_,module,exports){
// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

'use strict';

var parse = _dereq_('../parse');

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p, parseFn, glyphOffsets, glyphOffset, i;
    p = new parse.Parser(data, start);
    parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    glyphOffsets = [];
    for (i = 0; i < numGlyphs + 1; i += 1) {
        glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }
        glyphOffsets.push(glyphOffset);
    }
    return glyphOffsets;
}

exports.parse = parseLocaTable;

},{"../parse":7}],19:[function(_dereq_,module,exports){
// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

'use strict';

var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {},
        p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }
    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

exports.parse = parseMaxpTable;
exports.make = makeMaxpTable;

},{"../parse":7,"../table":9}],20:[function(_dereq_,module,exports){
// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

'use strict';

var encode = _dereq_('../types').encode;
var parse = _dereq_('../parse');
var table = _dereq_('../table');

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'licence',                // 13
    'licenceURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

// Parse the naming `name` table
// Only Windows Unicode English names are supported.
// Format 1 additional fields are not supported
function parseNameTable(data, start) {
    var name = {},
        p = new parse.Parser(data, start);
    name.format = p.parseUShort();
    var count = p.parseUShort(),
        stringOffset = p.offset + p.parseUShort();
    var platformID, encodingID, languageID, nameID, property, byteLength,
        offset, str, i, j, codePoints;
    var unknownCount = 0;
    for(i = 0; i < count; i++) {
        platformID = p.parseUShort();
        encodingID = p.parseUShort();
        languageID = p.parseUShort();
        nameID = p.parseUShort();
        property = nameTableNames[nameID];
        byteLength = p.parseUShort();
        offset = p.parseUShort();
        // platformID - encodingID - languageID standard combinations :
        // 1 - 0 - 0 : Macintosh, Roman, English
        // 3 - 1 - 0x409 : Windows, Unicode BMP (UCS-2), en-US
        if (platformID === 3 && encodingID === 1 && languageID === 0x409) {
            codePoints = [];
            var length = byteLength/2;
            for(j = 0; j < length; j++, offset += 2) {
                codePoints[j] = parse.getShort(data, stringOffset+offset);
            }
            str = String.fromCharCode.apply(null, codePoints);
            if (property) {
                name[property] = str;
            }
            else {
                unknownCount++;
                name['unknown'+unknownCount] = str;
            }
        }

    }
    if (name.format === 1) {
        name.langTagCount = p.parseUShort();
    }
    return name;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Table('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

function addMacintoshNameRecord(t, recordID, s, offset) {
    // Macintosh, Roman, English
    var stringBytes = encode.STRING(s);
    t.records.push(makeNameRecord(1, 0, 0, recordID, stringBytes.length, offset));
    t.strings.push(stringBytes);
    offset += stringBytes.length;
    return offset;
}

function addWindowsNameRecord(t, recordID, s, offset) {
    // Windows, Unicode BMP (UCS-2), US English
    var utf16Bytes = encode.UTF16(s);
    t.records.push(makeNameRecord(3, 1, 0x0409, recordID, utf16Bytes.length, offset));
    t.strings.push(utf16Bytes);
    offset += utf16Bytes.length;
    return offset;
}

function makeNameTable(options) {
    var i, s;
    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: 0},
        {name: 'stringOffset', type: 'USHORT', value: 0}
    ]);
    t.records = [];
    t.strings = [];
    var offset = 0;
    // Add Macintosh records first
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addMacintoshNameRecord(t, i, s, offset);
        }
    }
    // Then add Windows records
    for (i = 0; i < nameTableNames.length; i += 1) {
        if (options[nameTableNames[i]] !== undefined) {
            s = options[nameTableNames[i]];
            offset = addWindowsNameRecord(t, i, s, offset);
        }
    }

    t.count = t.records.length;
    t.stringOffset = 6 + t.count * 12;
    for (i = 0; i < t.records.length; i += 1) {
        t.fields.push({name: 'record_' + i, type: 'TABLE', value: t.records[i]});
    }
    for (i = 0; i < t.strings.length; i += 1) {
        t.fields.push({name: 'string_' + i, type: 'LITERAL', value: t.strings[i]});
    }
    return t;
}

exports.parse = parseNameTable;
exports.make = makeNameTable;

},{"../parse":7,"../table":9,"../types":24}],21:[function(_dereq_,module,exports){
// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

'use strict';

var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {},
        p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }
    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }
    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }
    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 0},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 0},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 0},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 0},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

exports.parse = parseOS2Table;
exports.make = makeOS2Table;

},{"../parse":7,"../table":9}],22:[function(_dereq_,module,exports){
// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

'use strict';

var encoding = _dereq_('../encoding');
var parse = _dereq_('../parse');
var table = _dereq_('../table');

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {},
        p = new parse.Parser(data, start),
        i, nameLength;
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
    case 1:
        post.names = encoding.standardNames.slice();
        break;
    case 2:
        post.numberOfGlyphs = p.parseUShort();
        post.glyphNameIndex = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.glyphNameIndex[i] = p.parseUShort();
        }
        post.names = [];
        for (i = 0; i < post.numberOfGlyphs; i++) {
            if (post.glyphNameIndex[i] >= encoding.standardNames.length) {
                nameLength = p.parseChar();
                post.names.push(p.parseString(nameLength));
            }
        }
        break;
    case 2.5:
        post.numberOfGlyphs = p.parseUShort();
        post.offset = new Array(post.numberOfGlyphs);
        for (i = 0; i < post.numberOfGlyphs; i++) {
            post.offset[i] = p.parseChar();
        }
        break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

exports.parse = parsePostTable;
exports.make = makePostTable;

},{"../encoding":3,"../parse":7,"../table":9}],23:[function(_dereq_,module,exports){
// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

'use strict';

var check = _dereq_('../check');
var table = _dereq_('../table');

var cmap = _dereq_('./cmap');
var cff = _dereq_('./cff');
var head = _dereq_('./head');
var hhea = _dereq_('./hhea');
var hmtx = _dereq_('./hmtx');
var maxp = _dereq_('./maxp');
var _name = _dereq_('./name');
var os2 = _dereq_('./os2');
var post = _dereq_('./post');

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }
    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }
    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Table('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'TABLE', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'TABLE', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function (r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs[glyphIndex];
            return glyph.getMetrics();
        }
    }
    return notFoundMetrics;
}

// Return the smallest and largest unicode values of the characters in this font.
// For most fonts the smallest value would be 20 (space).
function charCodeBounds(glyphs) {
    var minCode, maxCode;
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        if (glyph.unicode >= 20) {
            if (minCode === undefined) {
                minCode = glyph.unicode;
            } else if (glyph.unicode < minCode) {
                minCode = glyph.unicode;
            }
            if (maxCode === undefined) {
                maxCode = glyph.unicode;
            } else if (glyph.unicode > maxCode) {
                maxCode = glyph.unicode;
            }
        }
    }
    return [minCode, maxCode];
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }
    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs[i];
        // Skip non-important characters.
        if (glyph.name === '.notdef') continue;
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }
    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender !== undefined ? font.ascender : globals.yMax;
    globals.descender = font.descender !== undefined ? font.descender : globals.yMin;

    var headTable = head.make({
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax
    });

    var hheaTable = hhea.make({
        // Adding a little here makes OS X Quick Look happy
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var codeBounds = charCodeBounds(font.glyphs);
    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: 500, // Medium FIXME Make this configurable
        usWidthClass: 5, // Medium (normal) FIXME Make this configurable
        usFirstCharIndex: codeBounds[0],
        usLastCharIndex: codeBounds[1],
        ulUnicodeRange1: 0x00000001, // Basic Latin
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.ascender,
        usWinDescent: -globals.descender,
        ulCodePageRange1: 0x00000001, // Basic Latin
        sxHeight: metricsForChar(font, 'xyvw', {yMax: 0}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });


    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var fullName = font.familyName + ' ' + font.styleName;
    var postScriptName = font.familyName.replace(/\s/g, '') + '-' + font.styleName;
    var nameTable = _name.make({
        copyright: font.copyright,
        fontFamily: font.familyName,
        fontSubfamily: font.styleName,
        uniqueID: font.manufacturer + ':' + fullName,
        fullName: fullName,
        version: font.version,
        postScriptName: postScriptName,
        trademark: font.trademark,
        manufacturer: font.manufacturer,
        designer: font.designer,
        description: font.description,
        manufacturerURL: font.manufacturerURL,
        designerURL: font.designerURL,
        license: font.license,
        licenseURL: font.licenseURL,
        preferredFamily: font.familyName,
        preferredSubfamily: font.styleName
    });
    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.version,
        fullName: fullName,
        familyName: font.familyName,
        weightName: font.styleName,
        postScriptName: postScriptName
    });
    // Order the tables according to the the OpenType specification 1.4.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];

    var sfntTable = makeSfntTable(tables);

    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    headTable.checkSumAdjustment = 0xB1B0AFBA - checkSum;

    // Build the font again, now with the proper checkSum.
    sfntTable = makeSfntTable(tables);

    return sfntTable;
}

exports.computeCheckSum = computeCheckSum;
exports.make = makeSfntTable;
exports.fontToTable = fontToSfntTable;

},{"../check":1,"../table":9,"./cff":10,"./cmap":11,"./head":14,"./hhea":15,"./hmtx":16,"./maxp":19,"./name":20,"./os2":21,"./post":22}],24:[function(_dereq_,module,exports){
// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

/* global WeakMap */

'use strict';

var check = _dereq_('./check');

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

var decode = {};
var encode = {};
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function () {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

// Convert an 8-bit unsigned integer to a list of 1 byte.
encode.BYTE = function (v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};

sizeOf.BYTE = constant(1);

// Convert a 8-bit signed integer to a list of 1 byte.
encode.CHAR = function (v) {
    return [v.charCodeAt(0)];
};

sizeOf.BYTE = constant(1);

// Convert an ASCII string to a list of bytes.
encode.CHARARRAY = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.CHARARRAY = function (v) {
    return v.length;
};

// Convert a 16-bit unsigned integer to a list of 2 bytes.
encode.USHORT = function (v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.USHORT = constant(2);

// Convert a 16-bit signed integer to a list of 2 bytes.
encode.SHORT = function (v) {
    // Two's complement
    if (v >= LIMIT16){
        v = - ( 2 * LIMIT16 - v);
    }
    return [(v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.SHORT = constant(2);

// Convert a 24-bit unsigned integer to a list of 3 bytes.
encode.UINT24 = function (v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.UINT24 = constant(3);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.ULONG = function (v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.ULONG = constant(4);

// Convert a 32-bit unsigned integer to a list of 4 bytes.
encode.LONG = function (v) {
     // Two's complement
    if (v >= LIMIT32){
        v = - ( 2 * LIMIT32 - v);
    }
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;


// FIXME Implement LONGDATETIME
encode.LONGDATETIME = function () {
    return [0, 0, 0, 0, 0, 0, 0, 0];
};

sizeOf.LONGDATETIME = constant(8);

// Convert a 4-char tag to a list of 4 bytes.
encode.TAG = function (v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
encode.NUMBER = function (v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131 ) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

sizeOf.NUMBER = function (v) {
    return encode.NUMBER(v).length;
};

// Convert a signed number between -32768 and +32767 to a three-byte value.
// This ensures we always use three bytes, but is not the most compact format.
encode.NUMBER16 = function (v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER16 = constant(2);

// Convert a signed number between -(2^31) and +(2^31-1) to a four-byte value.
// This is useful if you want to be sure you always use four bytes,
// at the expense of wasting a few bytes for smaller numbers.
encode.NUMBER32 = function (v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

sizeOf.NUMBER32 = constant(4);

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

// Convert a ASCII string to a list of UTF16 bytes.
encode.UTF16 = function (v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b.push(0);
        b.push(v.charCodeAt(i));
    }
    return b;
};

sizeOf.UTF16 = function (v) {
    return v.length * 2;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
encode.INDEX = function (l) {
    var offSize, offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
        dataSize, i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offets, then again to encode the offsets using the fitting data type.
    offset = 1; // First offset is always 1.
    offsets = [offset];
    data = [];
    dataSize = 0;
    for (i = 0; i < l.length; i += 1) {
        v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        dataSize += v.length;
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    encodedOffsets = [];
    offSize = (1 + Math.floor(Math.log(dataSize)/Math.log(2)) / 8) | 0;
    offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (i = 0; i < offsets.length; i += 1) {
        encodedOffset = offsetEncoder(offsets[i]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }
    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

sizeOf.INDEX = function (v) {
    return encode.INDEX(v).length;
};

// Convert an object to a CFF DICT structure.
// The keys should be numeric.
// The values should be objects containing name / type / value.
encode.DICT = function (m) {
    var d = [],
        keys = Object.keys(m),
        length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

sizeOf.DICT = function (m) {
    return encode.DICT(m).length;
};

encode.OPERATOR = function (v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

encode.OPERAND = function (v, type) {
    var d, i;
    d = [];
    if (Array.isArray(type)) {
        for (i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else {
            // FIXME Add support for booleans
            d = d.concat(encode.NUMBER(v));
        }
    }
    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();
// Convert a list of CharString operations to bytes.
encode.CHARSTRING = function (ops) {
    if ( wmm && wmm.has( ops ) ) {
        return wmm.get( ops );
    }

    var d = [],
        length = ops.length,
        op,
        i;

    for (i = 0; i < length; i += 1) {
        op = ops[i];
        d = d.concat( encode[op.type](op.value) );
    }

    if ( wmm ) {
        wmm.set( ops, d );
    }

    return d;
};

sizeOf.CHARSTRING = function (ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

// Convert an object containing name / type / value to bytes.
encode.OBJECT = function (v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

// Convert a table object to bytes.
// A table contains a list of fields containing the metadata (name, type and default value).
// The table itself has the field values set as attributes.
encode.TABLE = function (table) {
    var d = [],
        length = table.fields.length,
        i;

    for (i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type);
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }
        var bytes = encodingFunction(value);
        d = d.concat(bytes);
    }
    return d;
};

// Merge in a list of bytes.
encode.LITERAL = function (v) {
    return v;
};

sizeOf.LITERAL = function (v) {
    return v.length;
};


exports.decode = decode;
exports.encode = encode;
exports.sizeOf = sizeOf;

},{"./check":1}]},{},[6])(6)
});

},{}],2:[function(_dereq_,module,exports){
/*!
 * Paper.js v0.9.21 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Mon Jan 26 16:22:06 2015 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

		  var noCanvas =
			  ( typeof process === 'object' && process.browser !== true ) ||
			  ( typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope );

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && (!exclude || !exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var orig = props._filtering || props;
			for (var key in orig) {
				if (orig.hasOwnProperty(key) && !(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			function checkKeys(o1, o2) {
				for (var i in o1)
					if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
						return false;
				return true;
			}
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				if (obj1.length !== obj2.length)
					return false;
				for (var i = 0, l = obj1.length; i < l; i++) {
					if (!Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			if (obj1 && typeof obj1 === 'object'
					&& obj2 && typeof obj2 === 'object') {
				if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
					return false;
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)
							&& !Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				for (var i in obj)
					if (obj.hasOwnProperty(i))
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data) {
			var res = json;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (!isDictionary) {
					if (_data.dictionary && json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
				}
				res = [];
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data));
				if (isDictionary) {
					_data.dictionary = res[0];
				} else if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var entry = this._eventTypes[type];
			if (entry) {
				var handlers = this._callbacks = this._callbacks || {};
				handlers = handlers[type] = handlers[type] || [];
				if (handlers.indexOf(func) === -1) {
					handlers.push(func);
					if (entry.install && handlers.length == 1)
						entry.install.call(this, type);
				}
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (entry && handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false
					&& event && event.stop) {
				event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var entry = this._eventTypes[type],
					func = entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if ( noCanvas ) {
			return;
		}
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}

		if (!this.browser) {
			var browser = proto.browser = {};
			navigator.userAgent.toLowerCase().replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
				function(all, n, v1, v2, rv) {
					if (!browser.chrome) {
						var v = n === 'opera' ? v2 : v1;
						if (n === 'trident') {
							v = rv;
							n = 'msie';
						}
						browser.version = v;
						browser.versionNumber = parseFloat(v);
						browser.name = n;
						browser[n] = true;
					}
				}
			);
			if (browser.chrome)
				delete browser.webkit;
			if (browser.atom)
				delete browser.chrome;
		}
	},

	version: '0.9.21',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		cos = Math.cos,
		PI = Math.PI,
		TOLERANCE = 1e-6,
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var count = 0,
				x1, x2 = Infinity,
				B = b,
				D;
			b /= 2;
			D = b * b - a * c;
			if (abs(D) < MACHINE_EPSILON) {
				var pow = Math.pow,
					gmC = pow(abs(a*b*c), 1/3);
				if (gmC < 1e-8) {
					/*
					 * we multiply with a factor to normalize the
					 * coefficients. The factor is just the nearest exponent
					 * of 10, big enough to raise all the coefficients to
					 * nearly [-1, +1] range.
					 */
					var mult = pow(10, abs(
						Math.floor(Math.log(gmC) * Math.LOG10E)));
					if (!isFinite(mult))
						mult = 0;
					a *= mult;
					b *= mult;
					c *= mult;
					D = b * b - a * c;
				}
			}
			if (abs(a) < MACHINE_EPSILON) {
				if (abs(B) < MACHINE_EPSILON)
					return abs(c) < MACHINE_EPSILON ? -1 : 0;
				x1 = -c / B;
			} else {
				if (D >= -MACHINE_EPSILON) {
					D = D < 0 ? 0 : D;
					var R = sqrt(D);
					if (b >= MACHINE_EPSILON && b <= MACHINE_EPSILON) {
						x1 = abs(a) >= abs(c) ? R / a : -c / R;
						x2 = -x1;
					} else {
						var q = -(b + (b < 0 ? -1 : 1) * R);
						x1 = q / a;
						x2 = c / q;
					}
				}
			}
			if (isFinite(x1) && (min == null || x1 >= min && x1 <= max))
				roots[count++] = x1;
			if (x2 !== x1
					&& isFinite(x2) && (min == null || x2 >= min && x2 <= max))
				roots[count++] = x2;
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var x, b1, c2, count = 0;
			if (a === 0) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (d === 0) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				var ec = 1 + MACHINE_EPSILON,
					x0, q, qd, t, r, s, tmp;
				x = -(b / a) / 3;
				tmp = a * x,
				b1 = tmp + b,
				c2 = b1 * x + c,
				qd = (tmp + b1) * x + c2,
				q = c2 * x + d;
				t = q /a;
				r = pow(abs(t), 1/3);
				s = t < 0 ? -1 : 1;
				t = -qd / a;
				r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
				x0 = x - s * r;
				if (x0 !== x) {
					do {
						x = x0;
						tmp = a * x,
						b1 = tmp + b,
						c2 = b1 * x + c,
						qd = (tmp + b1) * x + c2,
						q = c2 * x + d;
						x0 = qd === 0 ? x : x - q / qd / ec;
						if (x0 === x) {
							x = x0;
							break;
						}
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
			if (isFinite(x) && (count === 0 || x !== roots[count - 1])
					&& (min == null || x >= min && x <= max))
				roots[count++] = x;
			return count;
		}
	};
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isColinear: function(point) {
		return Math.abs(this.cross(point)) < 1e-12;
	},

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 1e-12;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true, Base.pick(recursively, true),
					_setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = avx * bvy - avy * bvx;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if (isInfinite || 0 <= ta && ta <= 1 && 0 <= tb && tb <= 1)
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy;
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			return Numerical.isZero(vx)
					? vy >= 0 ? px - x : x - px
					: Numerical.isZero(vy)
						? vx >= 0 ? y - py : py - y
						: (vx * (y - py) - vy * (x - px)) / Math.sqrt(vx * vx + vy * vy);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	insertChild: function(index, item, _preserve) {
		if (item instanceof Layer) {
			item._remove(false, true);
			Base.splice(this.layers, [item], index, 0);
			item._setProject(this, true);
			if (this._changes)
				item._changed(5);
			if (!this._activeLayer)
				this._activeLayer = item;
		} else if (item instanceof Item) {
			(this._activeLayer
				|| this.insertChild(index, new Layer(Item.NO_INSERT)))
					.insertChild(index, item, _preserve);
		} else {
			item = null;
		}
		return item;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = Symbol._id = (Symbol._id || 0) + 1;
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this.definition.equals(symbol.definition)
				|| false;
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = Item._id = (Item._id || 0) + 1;
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, parent: true }, true);
		return hasProps;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments);
		this._position = undefined;
	},

	_pivot: null,

	getRegistration: '#getPivot',
	setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		var cacheParent = this._parent || this._parentSymbol;
		if (cacheParent) {
			var id = cacheItem._id,
				ref = cacheParent._boundsCache = cacheParent._boundsCache || {
					ids: {},
					list: []
				};
			if (!ref.ids[id]) {
				ref.list.push(cacheItem);
				ref.ids[id] = cacheItem;
			}
		}
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++) {
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function(matrix) {
		this._matrix.initialize(matrix);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(transform) {
		if (this._applyMatrix = this._canApplyMatrix && !!transform)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert) {
		copy.setStyle(this._style);
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				copy.addChild(this._children[i].clone(false), true);
		}
		if (insert || insert === undefined)
			copy.insertAbove(this);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide', '_applyMatrix'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		copy._matrix.initialize(this._matrix);
		copy._data = this._data ? Base.clone(this._data) : null;
		copy.setSelected(this._selected);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(),
				_matrix || item._matrix).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.000001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		if (typeof name === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param) {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect =	bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: rect,
					overlapping: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param.items,
				inside = param.inside,
				overlapping = param.overlapping;
			matrix = inside && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (inside) {
					var bounds = child.getBounds(childMatrix);
					if (!inside.intersects(bounds))
						continue;
					if (!(inside && inside.contains(bounds)) && !(overlapping
							&& overlapping.intersects(child, childMatrix)))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = item ? this.insertChildren(index, [item], _preserve) : null;
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					var shift = item._parent === this && item._index < index;
					if (item._remove(false, true) && shift)
						index--;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertSibling: function(index, item, _preserve) {
		return this._parent
				? this._parent.insertChild(index, item, _preserve)
				: null;
	},

	insertAbove: function(item, _preserve) {
		return item._insertSibling(item._index + 1, this, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return item._insertSibling(item._index, this, _preserve);
	},

	sendToBack: function() {
		return (this._parent || this instanceof Layer && this._project)
				.insertChild(0, this);
	},

	bringToFront: function() {
		return (this._parent || this instanceof Layer && this._project)
				.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix, _applyRecursively,
			_setApplyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
					&& ((!_matrix.isIdentity() || matrix)
						|| _applyMatrix && _applyRecursively && this._children);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix,
					_applyRecursively, _setApplyMatrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true, applyRecursively,
						setApplyMatrix);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2;
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notifySelf, notifyParent) {
		if (this._parent)
			return _remove.base.call(this, notifySelf, notifyParent);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent) {
				project._needsUpdate = true;
			}
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insertSibling: function _insertSibling(index, item, _preserve) {
		return !this._parent
				? this._project.insertChild(index, item, _preserve)
				: _insertSibling.base.call(this, index, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.setStyle(this._style);
		path.transform(this._matrix);
		if (insert || insert === undefined)
			path.insertAbove(this);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rect' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size)
			this._size = new Size();
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setImage(copyCanvas);
		}
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this.setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
		} else {
			this._image = image;
			this._canvas = null;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

			image = document.getElementById(src) || new Image();

		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, {
				load: loaded
			});
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getElement: function() {
		return this._canvas || this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		ctx.drawImage(this.getElement(),
				-this._size.width / 2, -this._size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isLinear() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	isLinear: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	setLinear: function(linear) {
		if (linear) {
			this._handleIn.set(0, 0);
			this._handleOut.set(0, 0);
		} else {
		}
	},

	isColinear: function(segment) {
		var next1 = this.getNext(),
			next2 = segment.getNext();
		return this._handleOut.isZero() && next1._handleIn.isZero()
				&& segment._handleOut.isZero() && next2._handleIn.isZero()
				&& next1._point.subtract(this._point).isColinear(
					next2._point.subtract(segment._point));
	},

	isOrthogonal: function() {
		var prev = this.getPrevious(),
			next = this.getNext();
		return prev._handleOut.isZero() && this._handleIn.isZero()
			&& this._handleOut.isZero() && next._handleIn.isZero()
			&& this._point.subtract(prev._point).isOrthogonal(
					next._point.subtract(this._point));
	},

	isArc: function() {
		var next = this.getNext(),
			handle1 = this._handleOut,
			handle2 = next._handleIn,
			kappa = 0.5522847498307936;
		if (handle1.isOrthogonal(handle2)) {
			var from = this._point,
				to = next._point,
				corner = new Line(from, handle1, true).intersect(
						new Line(to, handle2, true), true);
			return corner && Numerical.isZero(handle1.getLength() /
					corner.subtract(from).getLength() - kappa)
				&& Numerical.isZero(handle2.getLength() /
					corner.subtract(to).getLength() - kappa);
		}
		return false;
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	interpolate: function(segment0, segment1, coef) {
		var dxPoint = segment1._point._x - segment0._point._x,
			dyPoint = segment1._point._y - segment0._point._y,
			dxHandleIn = segment1._handleIn._x - segment0._handleIn._x,
			dyHandleIn = segment1._handleIn._y - segment0._handleIn._y,
			dxHandleOut = segment1._handleOut._x - segment0._handleOut._x,
			dyHandleOut = segment1._handleOut._y - segment0._handleOut._y;

		this._point._x = segment0._point._x + dxPoint * coef;
		this._point._y = segment0._point._y + dyPoint * coef;
		this._handleIn._x = segment0._handleIn._x + dxHandleIn * coef;
		this._handleIn._y = segment0._handleIn._y + dyHandleIn * coef;
		this._handleOut._x = segment0._handleOut._x + dxHandleOut * coef;
		this._handleOut._y = segment0._handleOut._y + dyHandleOut * coef;

		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	isLinear: function() {
		return this._segment1._handleOut.isZero()
				&& this._segment2._handleIn.isZero();
	},

	getIntersections: function(curve) {
		return Curve.filterIntersections(Curve.getIntersections(
				this.getValues(), curve.getValues(), this, curve, []));
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.000001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this;
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	evaluate: function(v, t, type) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.000001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance && c1x === p1x && c1y === p1y
						|| t > 1 - tolerance && c2x === p2x && c2y === p2y) {
					x = c2x - c1x;
					y = c2y - c1y;
				} else if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by;
					return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b,
			isZero = Numerical.isZero;
		if (isZero(a) && isZero(b))
			a = b = 0;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.000001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs, 0, 1),
			sy = Curve.solveCubic(v, 1, y, tys, 0, 1),
			tx, ty;
		for (var cx = 0;  sx == -1 || cx < sx;) {
			if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
				for (var cy = 0; sy == -1 || cy < sy;) {
					if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
						if (sx == -1) tx = ty;
						else if (sy == -1) ty = tx;
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx == -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return v;
	},

	isLinear: function(v) {
		var isZero = Numerical.isZero;
		return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getEdgeSum: function(v) {
		return	  (v[0] - v[2]) * (v[3] + v[1])
				+ (v[2] - v[4]) * (v[5] + v[3])
				+ (v[4] - v[6]) * (v[7] + v[5]);
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.000001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve.evaluate(values, isParameter
					? offset : Curve.getParameterAt(values, offset, 0), index);
		};
		this[name] = function(parameter) {
			return Curve.evaluate(this.getValues(), parameter, index);
		};
	},
{
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		if (!isParameter)
			offset = this.getParameterAt(offset);
		return offset >= 0 && offset <= 1 && new CurveLocation(this, offset);
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(
						Curve.evaluate(values, t, 0), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.000001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.evaluate(values, minT, 0);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

}),
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (Math.abs(offset) >= rangeLength)
				return forward ? b : a;
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 16,
					0.000001);
		}
	};
}, new function() {
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 32)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.000001,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin <= tolerance && recursion > 3) {
			tMaxNew = tMinNew = (tMax + tMin) / 2;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.5 && tDiff > 0.5) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.evaluate(v2, t2, 0),
						curve1, t1, Curve.evaluate(v1, t1, 0));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		} else if (tDiff > 0) {
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold)
				return px + (threshold - py) * (qx - px) / (qy - py);
			px = qx;
			py = qy;
		}
		return null;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.evaluate(rvc, tc, 0).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, c1, c2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2),
				c1p1 = c1.getPoint1(),
				c1p2 = c1.getPoint2(),
				c2p1 = c2.getPoint1(),
				c2p2 = c2.getPoint2(),
				tolerance = 0.000001;
			if (c1p1.isClose(c2p1, tolerance))
				addLocation(locations, include, c1, 0, c1p1, c2, 0, c1p1);
			if (c1p1.isClose(c2p2, tolerance))
				addLocation(locations, include, c1, 0, c1p1, c2, 1, c1p1);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, c1, c2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			if (c1p2.isClose(c2p1, tolerance))
				addLocation(locations, include, c1, 1, c1p2, c2, 0, c1p2);
			if (c1p2.isClose(c2p2, tolerance))
				addLocation(locations, include, c1, 1, c1p2, c2, 1, c1p2);
			return locations;
		},

		filterIntersections: function(locations, _expand) {
			var last = locations.length - 1,
				tMax = 1 - 0.000001;
			for (var i = last; i >= 0; i--) {
				var loc = locations[i],
					next = loc._curve.getNext(),
					next2 = loc._curve2.getNext();
				if (next && loc._parameter >= tMax) {
					loc._parameter = 0;
					loc._curve = next;
				}
				if (next2 && loc._parameter2 >= tMax) {
					loc._parameter2 = 0;
					loc._curve2 = next2;
				}
			}

			function compare(loc1, loc2) {
				var path1 = loc1.getPath(),
					path2 = loc2.getPath();
				return path1 === path2
						? (loc1.getIndex() + loc1.getParameter())
								- (loc2.getIndex() + loc2.getParameter())
						: path1._id - path2._id;
			}

			if (last > 0) {
				locations.sort(compare);
				for (var i = last; i > 0; i--) {
					if (locations[i].equals(locations[i - 1])) {
						locations.splice(i, 1);
						last--;
					}
				}
			}
			if (_expand) {
				for (var i = last; i >= 0; i--)
					locations.push(locations[i].getIntersection());
				locations.sort(compare);
			}
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
		this._curve = curve;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
		this._parameter = parameter;
		this._point = point;
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function(_uncached) {
		if (!this._curve || _uncached) {
			this._curve = this._segment1.getCurve();
			if (this._curve.getParameterOf(this._point) == null)
				this._curve = this._segment2.getPrevious().getCurve();
		}
		return this._curve;
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			var param = this._parameter2;
			this._intersection = intersection = new CurveLocation(
					this._curve2, param, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getOffset: function() {
		var path = this.getPath();
		return path ? path._getOffset(this) : this.getCurveOffset();
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getParameter: function(_uncached) {
		if ((this._parameter == null || _uncached) && this._point) {
			var curve = this.getCurve(_uncached);
			this._parameter = curve && curve.getParameterOf(this._point);
		}
		return this._parameter;
	},

	getPoint: function(_uncached) {
		if ((!this._point || _uncached) && this._parameter != null) {
			var curve = this.getCurve(_uncached);
			this._point = curve && curve.getPointAt(this._parameter, true);
		}
		return this._point;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(true);
		return curve && curve.divide(this.getParameter(true), true);
	},

	split: function() {
		var curve = this.getCurve(true);
		return curve && curve.split(this.getParameter(true), true);
	},

	equals: function(loc) {
		var abs = Math.abs,
			tolerance = 0.000001;
		return this === loc
				|| loc
					&& this._curve === loc._curve
					&& this._curve2 === loc._curve2
					&& abs(this._parameter - loc._parameter) <= tolerance
					&& abs(this._parameter2 - loc._parameter2) <= tolerance
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
}, Base.each(['getTangent', 'getNormal', 'getCurvature'], function(name) {
	var get = name + 'At';
	this[name] = function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve[get](parameter, true);
	};
}, {}));

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _matrix, _expand) {
		if (this === path)
			path = null;
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? (_matrix || path._matrix).orNullIfIdentity()
				: matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			tMin = 0.000001,
			tMax = 1 - tMin;
		if (path && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= tMax) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= tMin && t <= tMax;
						}
				);
			}
		}
		return Curve.filterIntersections(locations, _expand);
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				if (move && previous && previous !== 'z')
					this.closePath(true);
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (this._curves && !(flags & 16)) {
				for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isPolygon: function() {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if (!this._segments[i].isLinear())
				return false;
		}
		return true;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.evaluate(pos, 0)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return null;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			if (!arg)
				return null
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.000001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.equals(last2._point))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	interpolate: function(path0, path1, coef) {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if ( !path0._segments[i] || !path1._segments[i] ) {
				break;
			}

			this._segments[i].interpolate(
				path0._segments[i],
				path1._segments[i],
				coef
			);
		}

		this._changed(9);
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isColinear(i, j) {
			return segments[i].isColinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (this.isPolygon() && segments.length === 4
				&& isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			shape.setStyle(this._style);
			if (insert || insert === undefined)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset;
			return curves[index].getLocationAt(offset - index, true);
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}), new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() {

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					epsilon = 1e-12,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < epsilon)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++)
			sum += Curve.getEdgeSum(Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]));
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isColinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().normalize(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	reduce: function reduce() {
		if (this._children.length === 0) {
			var path = new Path(Item.NO_INSERT);
			path.insertAbove(this);
			path.setStyle(this._style);
			this.remove();
			return path;
		} else {
			return reduce.base.call(this);
		}
	},

	interpolate: function(compoundpath0, compoundpath1, coef) {
		for (var i = 0, l = this._children.length; i < l; i++) {
			if ( !compoundpath0._children[i] || !compoundpath1._children[i] ) {
				break;
			}

			this._children[i].interpolate(
				compoundpath0._children[i],
				compoundpath1._children[i],
				coef
			);
		}
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : mx, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
}, new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	var operators = {
		unite: function(w) {
			return w === 1 || w === 0;
		},

		intersect: function(w) {
			return w === 2;
		},

		subtract: function(w) {
			return w === 1;
		},

		exclude: function(w) {
			return w === 1;
		}
	};

	function computeBoolean(path1, path2, operation) {
		var operator = operators[operation];
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true,
					true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (_path2 && /^(subtract|exclude)$/.test(operation)
				^ (_path2.isClockwise() !== _path1.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, null, true));

		var chain = [],
			segments = [],
			monoCurves = [],
			tolerance = 0.000001;

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = 0;
			var startSeg = segment,
				totalLength = 0,
				windingSum = 0;
			do {
				var length = segment.getCurve().getLength();
				chain.push({ segment: segment, length: length });
				totalLength += length;
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * (j + 1) / 4;
				for (k = 0, m = chain.length; k < m; k++) {
					var node = chain[k],
						curveLength = node.length;
					if (length <= curveLength) {
						if (length <= tolerance
								|| curveLength - length <= tolerance)
							length = curveLength / 2;
						var curve = node.segment.getCurve(),
							pt = curve.getPointAt(length),
							hor = curve.isLinear() && Math.abs(curve
									.getTangentAt(0.5, true).y) <= tolerance,
							path = curve._path;
						if (path._parent instanceof CompoundPath)
							path = path._parent;
						windingSum += operation === 'subtract' && _path2
							&& (path === _path1 && _path2._getWinding(pt, hor)
							|| path === _path2 && !_path1._getWinding(pt, hor))
							? 0
							: getWinding(pt, monoCurves, hor);
						break;
					}
					length -= curveLength;
				}
			}
			var winding = Math.round(windingSum / 3);
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j].segment._winding = winding;
		}
		var result = new CompoundPath(Item.NO_INSERT);
		result.insertAbove(path1);
		result.addChildren(tracePaths(segments, operator), true);
		result = result.reduce();
		result.setStyle(path1._style);
		return result;
	}

	function splitPath(intersections) {
		var tMin = 0.000001,
			tMax = 1 - tMin,
			linearHandles;

		function resetLinear() {
			for (var i = 0, l = linearHandles.length; i < l; i++)
				linearHandles[i].set(0, 0);
		}

		for (var i = intersections.length - 1, curve, prev; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prev && prev._curve === loc._curve && prev._parameter > 0) {
				t /= prev._parameter;
			} else {
				curve = loc._curve;
				if (linearHandles)
					resetLinear();
				linearHandles = curve.isLinear() ? [
						curve._segment1._handleOut,
						curve._segment2._handleIn
					] : null;
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
				if (linearHandles)
					linearHandles.push(segment._handleOut, segment._handleIn);
			} else {
				segment = t < tMin
					? curve._segment1
					: t > tMax
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			prev = loc;
		}
		if (linearHandles)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var tolerance = 0.000001,
			tMin = tolerance,
			tMax = 1 - tMin,
			px = point.x,
			py = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = py - tolerance,
				yAfter = py + tolerance;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y = Curve.evaluate(values, roots[j], 0).y;
						if (y < yBefore && y > yTop) {
							yTop = y;
						} else if (y > yAfter && y < yBottom) {
							yBottom = y;
						}
					}
				}
			}
			yTop = (yTop + py) / 2;
			yBottom = (yBottom + py) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(px, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(px, yBottom), curves);
		} else {
			var xBefore = px - tolerance,
				xAfter = px + tolerance;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding,
					next = curve.next,
					prevT,
					prevX;
				if (winding && (winding === 1
						&& py >= values[1] && py <= values[7]
						|| py >= values[7] && py <= values[1])
					&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
					var t = roots[0],
						x = Curve.evaluate(values, t, 0).x,
						slope = Curve.evaluate(values, t, 1).y;
					if (!(t > tMax
							&& (i === l - 1 || curve.next !== curves[i + 1])
							&& abs(Curve.evaluate(curve.next.values, 0, 0).x -x)
								<= tolerance
						|| i > 0 && curve.previous === curves[i - 1]
							&& abs(prevX - x) < tolerance
							&& prevT > tMax && t < tMin)) {
						if (Numerical.isZero(slope) && !Curve.isLinear(values)
								|| t < tMin && slope * Curve.evaluate(
									curve.previous.values, 1, 1).y < 0
								|| t > tMax && slope * Curve.evaluate(
									curve.next.values, 0, 1).y < 0) {
							if (testContains && x >= xBefore && x <= xAfter) {
								++windLeft;
								++windRight;
							}
						} else if (x <= xBefore) {
							windLeft += winding;
						} else if (x >= xAfter) {
							windRight += winding;
						}
					}
					prevT = t;
					prevX = x;
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		var paths = [],
			tMin = 0.000001,
			tMax = 1 - tMin;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false,
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? tMin : tMax, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(tMax, true),
							t4 = c4.getTangentAt(tMin, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isPolygon() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, 'unite');
		},

		intersect: function(path) {
			return computeBoolean(this, path, 'intersect');
		},

		subtract: function(path) {
			return computeBoolean(this, path, 'subtract');
		},

		exclude: function(path) {
			return computeBoolean(this, path, 'exclude');
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					tolerance = 0.000001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, tolerance,
						1 - tolerance);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		if (children.length > 0) {
			this.addChildren(children);
			var clockwise = children[0].isClockwise();
			for (var i = 1, l = children.length; i < l; i++) {
				var point = children[i].getInteriorPoint(),
					counters = 0;
				for (var j = i - 1; j >= 0; j--) {
					if (children[j].contains(point))
						counters++;
				}
				children[i].setClockwise(counters % 2 === 0 && clockwise);
			}
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 0.000001) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	evaluate: function(offset, type) {
		var param = this.getParameterAt(offset);
		return Curve.evaluate(this.curves[param.index], param.value, type);
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset) {
			return this.evaluate(offset, index);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		var points = this.points = [],
			segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				points.push(point);
				prev = point;
			}
		}

		if (path._closed) {
			this.closed = true;
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}

		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length,
			segments = this.segments = length > 0
					? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());

		if (this.closed) {
			segments.shift();
			segments.pop();
		}

		return segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1);
		epsilon *= segLength;
		if (alpha1 < epsilon || alpha2 < epsilon) {
			alpha1 = alpha2 = segLength / 3;
		}

		return [pt1, pt1.add(tan1.normalize(alpha1)),
				pt2.add(tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.000001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy, insert) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy, insert);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				value = parser.call(this, value);
				if (value != null) {
					this._components[index] = value;
					this._changed();
				}
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (type === 'gradient')
				this._id = Color._id = (Color._id || 0) + 1;
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = Gradient._id = (Gradient._id || 0) + 1;
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = typeof window === 'object' &&
			DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	if ( typeof window === 'object' ) {
		DomEvent.add(window, {
			focus: function() {
				focused = true;
			},
			blur: function() {
				focused = false;
			}
		});
	}

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if ( !noCanvas ) {
			if (!this._pixelRatio)
				this._pixelRatio = window.devicePixelRatio || 1;
			this._id = element.getAttribute('id');
			if (this._id == null)
				element.setAttribute('id', this._id = 'view-' + View._id++);
			DomEvent.add(element, this._viewEvents);
			var none = 'none';
			DomElement.setPrefixed(element.style, {
				userSelect: none,
				touchAction: none,
				touchCallout: none,
				contentZooming: none,
				userDrag: none,
				tapHighlightColor: 'rgba(0,0,0,0)'
			});

			function getSize(name) {
				return element[name] || parseInt(element.getAttribute(name), 10);
			}

			function getCanvasSize() {
				var size = DomElement.getSize(element);
				return size.isNaN() || size.isZero()
						? new Size(getSize('width'), getSize('height'))
						: size;
			}

			if (PaperScope.hasAttribute(element, 'resize')) {
				var that = this;
				DomEvent.add(window, this._windowEvents = {
					resize: function() {
						that.setViewSize(getCanvasSize());
					}
				});
			}
			this._setViewSize(size = getCanvasSize());
			if (PaperScope.hasAttribute(element, 'stats')
					&& typeof Stats !== 'undefined') {
				this._stats = new Stats();
				var stats = this._stats.domElement,
					style = stats.style,
					offset = DomElement.getOffset(element);
				style.position = 'absolute';
				style.left = offset.x + 'px';
				style.top = offset.y + 'px';
				document.body.appendChild(stats);
			}

		} else {
			if (!this._pixelRatio)
				this._pixelRatio = 1;
			this._id = 'view-' + View._id++;
			size = new Size(element.width, element.height);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
}, new function() {
	if ( noCanvas ) {
		return;
	}

	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if ( !noCanvas ) {
			if (!(canvas instanceof HTMLCanvasElement)) {
				var size = Size.read(arguments);
				if (size.isZero())
					throw new Error(
							'Cannot create CanvasView with the provided argument: '
							+ [].slice.call(arguments, 1));
				canvas = CanvasProvider.getCanvas(size);
			}
			this._context = canvas.getContext('2d');
		}
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (!noCanvas && !/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var element = this._element,
			pixelRatio = this._pixelRatio,
			width = size.width,
			height = size.height;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var ctx = this._context,
			prevFont = ctx.font;
		ctx.font = size + ' serif';
		size = parseFloat(ctx.font);
		ctx.font = prevFont;
		return size;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		var project = this._project;
		if (!project || !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() {

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {
	if ( noCanvas ) {
		return;
	}

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command',
		224: 'command'
	},

	specialChars = {
		9: true,
		13: true,
		32: true
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {},
	keyMap = {},
	downCode;

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers)
			modifiers[name] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.emit(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._minDistance > this._maxDistance) {
			this._maxDistance = this._minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = distance;
		this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				var maxDist = maxDistance != null ? maxDistance : 0;
				if (maxDist != 0) {
					if (distance > maxDist) {
						point = this._point.add(vector.normalize(maxDist));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.emit(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback) {
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, true);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if ( noCanvas ) {
			return { getContext: function() {} };
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	if ( noCanvas ) {
		return;
	}

	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		if (options.matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (item.isPolygon()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data  !== '{}')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			applyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot) {
			definitions = {};
			if (applyMatrix && item)
				item.matrix.apply(true, true);
		}
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	Key: Key
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

},{}],3:[function(_dereq_,module,exports){
var paper = _dereq_('../node_modules/paper/dist/paper-core.js');

function Collection( args ) {
	// already a Collection? Job's done
	if ( arguments.length === 1 && args instanceof Collection ) {
		return args;

	} else if ( arguments.length > 1 || !Array.isArray( args ) ) {
		args = [].slice.call( arguments, 0 );
	}

	this.length = 0;

	args.forEach(function( arg ) {
		// unwrap any collection
		if ( arg instanceof Collection ) {
			for ( var i = -1; ++i < arg.length; ) {
				this[this.length++] = arg[i];
			}

		} else {
			this[this.length++] = arg;
		}

	}, this);

	return this;
}

Collection.prototype.forEach = function(cb, scope) {
	for ( var i = -1; ++i < this.length; ) {
		cb.call(scope || this[i], this[i], i, this);
	}

	return this;
};

Collection.prototype.prop = function(name, val) {
	var i;

	// object setter
	if ( typeof name === 'object' ) {
		for ( i = -1; ++i < this.length; ) {
			this[i].set( name );
		}

		return this;
	}

	// getter
	if ( val === undefined ) {
		return this[0][name];
	}

	// simple setter
	for ( i = -1; ++i < this.length; ) {
		this[i][name] = val;
	}

	return this;
};

function wrapConstructor( constructor, prototype, useConstructed ) {
	return function wrapper() {
		var c,
			tmp,
			arr = [];

		// constructor used with new
		if ( this instanceof wrapper ) {
			// proxy to paper native constructor
			c = Object.create(prototype);
			tmp = constructor.apply(c, arguments);
			return useConstructed ?
				tmp:
				c;

		// without new, build a collection
		} else {
			if ( Array.isArray( arguments[0] ) ) {
				arguments[0].forEach(function(params, i) {
					arr.push( Object.create(prototype) );
					c = constructor.call( arr[i], params );
					if ( useConstructed ) {
						arr[i] = c;
					}
				});

			} else {
				arr.push( Object.create(prototype) );
				c = constructor.apply( arr[0], arguments );
				if ( useConstructed ) {
					arr[0] = c;
				}
			}

			return new Collection( arr );
		}
	};
}

var rconstructor = /(^|\.)[A-Z][A-z]+$/;
function constructorFilter( name ) {
	return typeof this[name] === 'function' && rconstructor.test(name);
}

// unwrap a collection or array of collection
function unwrapArg( arr, id, isPlural ) {
	// unwrap a single collection
	if ( arr && arr[id] instanceof Collection ) {
		arr[id] = isPlural ?
			[].slice.call( arr[id], 0 ):
			arr[id][0];

	// unwrap an array of collection
	} else if ( arr && arr[id].length && arr[id][0] instanceof Collection ) {
		for ( i = -1; ++i < arr[id].length; ) {
			arr[id][i] = arr[id][i][0];
		}
	}
}

function unwrapArgs() {
	var isPlural = this.isPlural,
		args = [].slice.call( arguments, 0 ),
		arr,
		id,
		i;

	// first arg is an object and might have a collection or array of collection
	// Todo: objects should be unwrapped recursively
	if ( args[0] && args[0].constructor === Object ) {
		if ( 'children' in args[0] ) {
			id = 'children';

		} else if ( 'segments' in args[0] ) {
			id = 'segments';

		} else if ( 'nodes' in args[0] ) {
			id = 'nodes';
		}

		unwrapArg( args[0], id, true );

	// otherwise unwrap each arg
	} else {
		for ( i = -1; ++i < args.length; ) {
			// if the method is plural (addChildren) and we're unwrapping
			// the last argument, we want to keep it in an array
			unwrapArg( args, i, i === args.length -1 && isPlural );
		}
	}

	return args;
}

Collection.proxy = function( paper ) {
	var plumin = this;

	plumin.paper = paper;

	var methodNames = {};
	Object.getOwnPropertyNames( paper.PaperScope.prototype )
		.filter( constructorFilter, paper.PaperScope.prototype )
		.forEach(function(name, i) {
			plumin[name] = wrapConstructor( this[name], this[name].prototype );

			// we don't want to proxy methods of Collection
			if ( name === 'Collection' ) {
				return;
			}

			Object.getOwnPropertyNames( this[name].prototype ).forEach(function(name, i) {
				// collect unique method names (first test avoids getters)
				if ( !Object.getOwnPropertyDescriptor(this, name).get &&
						typeof this[name] === 'function' ) {

					methodNames[name] = true;
				}

			}, this[name].prototype);

		}, paper.PaperScope.prototype);

	Object.keys( paper.PaperScope.prototype.Path )
		.filter( constructorFilter, paper.PaperScope.prototype.Path )
		.forEach(function(name) {
			plumin.Path[name] = wrapConstructor( this[name], this.prototype, true );

		}, paper.PaperScope.prototype.Path );

	Object.keys( paper.PaperScope.prototype.Shape )
		.filter( constructorFilter, paper.PaperScope.prototype.Shape )
		.forEach(function(name) {
			plumin.Shape[name] = wrapConstructor( this[name], this.prototype, true );

		}, paper.PaperScope.prototype.Shape );

	// proxy the most commonly used method of paper
	// do it only after proxying constructors otherwise it's overwritten
	plumin.setup = paper.setup.bind(paper);

	// proxy all methods from every constructor
	// by default methods aren't chainable
	Object.keys( methodNames ).sort().forEach(function(name) {
		// please oh please, don't overwrite my constructor, I need it.
		if ( name === 'constructor' ) {
			return;
		}

		Collection.prototype[name] = function() {
			var args = unwrapArgs.apply(null, arguments),
				i,
				result;

			for ( i = -1; ++i < this.length; ) {
				result = this[i][name].apply(this[i], args);
			}

			// by default methods aren't chainable
			// return the last result
			return result;
		};
	});

		// addChild( item ) and other methods with similar signatures
		// that we want to make chainable
	var chain = [
			'set',
			'setX',
			'setY',
			'insertAbove',
			'insertBelow',
			'sendToBack',
			'bringToFront',
			'remove',
			'removeChildren',
			'reverseChildren',

			'translate',
			'rotate',
			'scale',
			'shear',
			'skew',
			'transform',
			'fitBounds',
			'emit',

			'activate',

			'setPixel',

			'smooth',
			'moveTo',
			'lineTo',
			'cubicCurveTo',
			'quadraticCurveTo',
			'curveTo',
			'arcTo',
			'closePath',
			'moveBy',
			'lineBy',
			'cubicCurveBy',
			'quadraticCurveBy',
			'curveBy',
			'arcBy',

			'removeSegments',
			'simplify',
			'reverse',

			// Rectangle
			'include',
			'expand',
			'scale',
		// ],
		// createAndChain = [
			'addChild',
			'insertChild',
			'addChildren',
			'insertChildren',
			'replaceWith',

			'appendTop',
			'appendBottom',

			'add',
			'insert',
			'addSegments',
			'insertSegments',
			'addNode',
			'addNodes',
			'insertNodes',

			'addGlyph',
			'addGlyphs',

			'addContour',
			'insertContour',
			'addContours',
			'insertContours',
			'addAnchor',
			'addAnchors',
			'addComponent',
			'addComponents',

			'addUnicode',
			'prepareOt',
			'addToFonts',
			'download'
		],
		plural = [
			'addChildren',
			'insertChildren',
			'addSegments',
			'insertSegments',
			'addNodes',
			'insertNodes',
			'addGlyphs',
			'addAnchors',
			'addContours',
			'insertContours',
			'addComponents'
		],
		mathPoinFn = [
			'round',
			'ceil',
			'floor',
			'abs'
		],
		booleanPathOp = [
			'unite',
			'intersect',
			'subtract',
			'exclude',
			'divide'
		];

	chain.forEach(function(name) {
		Collection.prototype[name] = function() {
			var args = unwrapArgs.apply(
					{ isPlural: plural.indexOf(name) !== -1 },
					arguments
				),
				i;

			for ( i = -1; ++i < this.length; ) {
				this[i][name].apply(this[i], args);
			}

			// make method chainable
			return this;
		};
	});

	// singular chainable method
};

module.exports = Collection;
},{"../node_modules/paper/dist/paper-core.js":2}],4:[function(_dereq_,module,exports){
var opentype = _dereq_('../node_modules/opentype.js/dist/opentype.js'),
	Glyph = _dereq_('./Glyph.js');

function Font( args ) {
	if ( !args ) {
		args = {};
	}

	if ( !args.styleName ) {
		args.styleName = 'Regular';
	}

	if ( !args.unitsPerEm ) {
		args.unitsPerEm = 1024;
	}

	this.ot = new opentype.Font( args );

	this.glyphs = [];
	this.glyphMap = {};
	this.charMap = {};
	this.altMap = {};
	this._subset = false;

	this.addGlyph(new Glyph({
		name: '.notdef',
		unicode: 0
	}));

	if ( args && args.glyphs ) {
		this.addGlyphs( args.glyphs );
	}

	if ( typeof window === 'object' && window.document ) {
		// work around https://bugzilla.mozilla.org/show_bug.cgi?id=1100005
		// by using fonts.delete in batch, every 1 second
		if ( document.fonts ) {
			this.addedFonts = [];

			setInterval(function() {
				while ( this.addedFonts.length > 1 ) {
					document.fonts.delete( this.addedFonts.shift() );
				}
			}.bind(this), 1000);

		} else {
			document.head.appendChild(
				this.styleElement = document.createElement('style')
			);
			// let's find the corresponding CSSStyleSheet
			// (would be much easier with Array#find)
			this.styleSheet = document.styleSheets[
				[].map.call(document.styleSheets, function(ss) {
					return ss.ownerNode;
				}).indexOf(this.styleElement)
			];
		}
	}
}

Font.prototype.addGlyph = function( glyph ) {
	this.glyphs.push( glyph );
	this.glyphMap[glyph.name] = glyph;

	if ( glyph.ot.unicode === undefined ) {
		return glyph;
	}

	// build the default cmap
	// if multiple glyphs share the same unicode, use the glyph where unicode and name are equal
	if ( !this.charMap[glyph.ot.unicode] ||
			( glyph.name.length === 1 && glyph.name.charCodeAt(0) === glyph.ot.unicode ) ) {

		this.charMap[glyph.ot.unicode] = glyph;
	}

	// build the alternates map
	if ( !this.altMap[glyph.ot.unicode] ) {
		this.altMap[glyph.ot.unicode] = [];
	}
	this.altMap[glyph.ot.unicode].push( glyph );

	return glyph;
};

Font.prototype.addGlyphs = function( glyphs ) {
	return glyphs.forEach(function( glyph ) {
		this.addGlyph(glyph);

	}, this);
};

Object.defineProperty( Font.prototype, 'subset', {
	get: function() {
		return this._subset;
	},
	set: function( set ) {
		if ( set === false ) {
			return ( this._subset = false );
		}

		return ( this._subset = (typeof set === 'string' ? set.split('') : set)
			.filter(function(e, i, arr) {
				return arr.lastIndexOf(e) === i;
			})
			.map(function(e) {
				return e.charCodeAt(0);
			})
			.sort()
		);
	}
});

Font.prototype.getGlyphSubset = function( set ) {
	if ( set !== undefined ) {
		this.subset = set;
	}

	// reuse last subset if possible
	if ( this._lastSubset && this._lastSubset[0] === ( this._subset || [] ).join() ) {
		return this._lastSubset[1];
	}

	// memoize last subset
	this._lastSubset = [
		( this._subset || [] ).join(),
		this.glyphs.filter(function( glyph ) {
			if ( this._subset === false &&
					( glyph.ot.unicode !== undefined ||
					( glyph.ot.unicodes && glyph.ot.unicodes.length ) ) ) {

				return true;
			}

			if ( this._subset && this._subset.indexOf( glyph.ot.unicode ) !== -1 ) {
				return true;
			}

			// TODO: handle multiple unicodes

			return false;
		}, this)
	];

	return this._lastSubset[1];
};

Font.prototype.interpolate = function( font0, font1, coef, set ) {
	this.getGlyphSubset( set ).map(function( glyph ) {
		glyph.interpolate(
			font0.glyphMap[glyph.name],
			font1.glyphMap[glyph.name],
			coef
		);
	});

	// TODO: evaluate if taking subsetting into account makes kerning
	// interpolation faster or slower.
	if ( this.ot.kerningPairs ) {
		for ( var i in this.ot.kerningPairs ) {
			this.ot.kerningPairs[i] =
				font0.ot.kerningPairs[i] +
				( font1.ot.kerningPairs[i] - font0.ot.kerningPairs[i] ) * coef;
		}
	}

	this.ot.ascender =
		font0.ot.ascender + ( font1.ot.ascender - font0.ot.ascender ) * coef;
	this.ot.descender =
		font0.ot.descender + ( font1.ot.descender - font0.ot.descender ) * coef;

	return this;
};

Font.prototype.updateOTCommands = function( set ) {
	this.ot.glyphs = this.getGlyphSubset( set ).map(function( glyph ) {
		return glyph.updateOTCommands();
	});

	return this;
};

Font.prototype.importOT = function( otFont ) {
	this.ot = otFont;

	otFont.glyphs.forEach(function( otGlyph ) {
		var glyph = new Glyph({
				name: otGlyph.name,
				unicode: otGlyph.unicode
			});

		this.addGlyph( glyph );
		glyph.importOT( otGlyph );

	}, this);

	return this;
};

if ( typeof window === 'object' && window.document ) {

	var _URL = window.URL || window.webkitURL;
	Font.prototype.addToFonts = document.fonts ?
		// CSS font loading, lightning fast
		function( buffer ) {
			var fontface = new FontFace(
				this.ot.familyName,
				buffer || this.ot.toBuffer()
			);

			document.fonts.add( fontface );
			this.addedFonts.push( fontface );

			return this;
		}:
		function( buffer ) {
			var url = _URL.createObjectURL(
					new Blob(
						[ new DataView( buffer || this.ot.toBuffer() ) ],
						{type: 'font/opentype'}
					)
				);

			if ( this.fontObjectURL ) {
				_URL.revokeObjectURL( this.fontObjectURL );
				this.styleSheet.deleteRule(0);
			}

			this.styleSheet.insertRule(
				'@font-face { font-family: "' + this.ot.familyName + '"; src: url(' + url + '); }',
				0
			);
			this.fontObjectURL = url;

			return this;
		};

	Font.prototype.download = function( buffer ) {
		var reader = new FileReader();

		reader.onloadend = function() {
			window.location = reader.result;
		};

		reader.readAsDataURL(new Blob(
			[ new DataView( buffer || this.ot.toBuffer() ) ],
			{type: 'font/opentype'}
		));

		return this;
	};

}

module.exports = Font;
},{"../node_modules/opentype.js/dist/opentype.js":1,"./Glyph.js":5}],5:[function(_dereq_,module,exports){
var opentype = _dereq_('../node_modules/opentype.js/dist/opentype.js'),
	paper = _dereq_('../node_modules/paper/dist/paper-core.js');

function Glyph( args ) {
	paper.CompoundPath.prototype.constructor.apply( this );

	if ( args && typeof args.unicode === 'string' ) {
		args.unicode = args.unicode.charCodeAt(0);
	}

	this.ot = new opentype.Glyph( args );
	this.ot.path = new opentype.Path();

	this.name = args.name;
	// workaround opentype 'unicode === 0' bug
	this.ot.unicode = args.unicode;

	//this.contours = ( args && args.contours ) || [];
	this.anchors = ( args && args.anchors ) || [];
	this.components = ( args && args.components ) || [];
	this.parentAnchors = ( args && args.parentAnchors ) || [];

	// default fill color needed to display the glyph in a canvas
	this.fillColor = new paper.Color(0,0,0);
	// but each individual glyph must be explicitely made visible
	this.visible = false;
}

Glyph.prototype = Object.create(paper.CompoundPath.prototype);
Glyph.prototype.constructor = Glyph;

// Todo: handle unicode updates
Object.defineProperty(Glyph.prototype, 'unicode', {
	set: function( code ) {
		this.ot.unicode = typeof code === 'string' ?
			code.charCodeAt(0):
			code;
	},
	get: function() {
		return this.ot.unicode;
	}
});

// proxy *Child/*Children methods to *Contour/*Contours
// This has the added benefit of preventing CompoundPath#insertChildren
// from arbitrarily changing the direction of paths
Object.getOwnPropertyNames( paper.Item.prototype )
	.forEach(function(name, i) {
		// exclude getters and non-methods
		if ( Object.getOwnPropertyDescriptor(this, name).get ||
				typeof this[name] !== 'function' ) {
			return;
		}

		if ( name.indexOf('Children') !== -1 ) {
			this[name.replace('Children', 'Contours')] = this[name];

		} else if ( name.indexOf('Child') !== -1 ) {
			this[name.replace('Child', 'Contour')] = this[name];
		}

	}, paper.Item.prototype);

// Fix two problems with CompoundPath#insertChildren:
// - it arbitrarily changes the direction of paths
// - it seems that it doesn't handle CompoundPath arguments
Glyph.prototype.insertChildren = function(index, items, _preserve) {
	if ( Array.isArray( items ) ) {
		// flatten items to handle CompoundPath children
		items = [].concat.apply([], items.map(function(item) {
			return item instanceof paper.Path ? item : item.children;
		}));
	}

	return paper.Item.prototype.insertChildren.call(this, index, items, _preserve, paper.Path);
};

// proxy .children to .contours
Object.defineProperty(
	Glyph.prototype,
	'contours',
	Object.getOwnPropertyDescriptor( paper.Item.prototype, 'children' )
);

Glyph.prototype.addComponent = function( item ) {
	this.addChild( item );
	this.components.push( item );
	return item;
};

Glyph.prototype.addComponents = function( components ) {
	return components.forEach(function(component) {
		this.addComponent(component);
	}, this);
};

Glyph.prototype.addAnchor = function( item ) {
	this.anchors.push( item );
	return item;
};

Glyph.prototype.addAnchors = function( anchors ) {
	return anchors.forEach(function(anchor) {
		this.addAnchor(anchor);
	}, this);
};

Glyph.prototype.addParentAnchor = function( item ) {
	this.parentAnchors.push( item );
	return item;
};

Glyph.prototype.addUnicode = function( code ) {
	this.ot.addUnicode( code );

	return this;
};

Glyph.prototype.interpolate = function( glyph0, glyph1, coef ) {
	for (var i = 0, l = this.contours.length; i < l; i++) {
		// The number of children should be the same everywhere,
		// but we're going to try our best anyway
		if ( !glyph0.contours[i] || !glyph1.contours[i] ) {
			break;
		}

		this.contours[i].interpolate(
			glyph0.contours[i],
			glyph1.contours[i],
			coef
		);

		this.ot.advanceWidth =
			glyph0.ot.advanceWidth +
			( glyph1.ot.advanceWidth - glyph0.ot.advanceWidth ) * coef;
		this.ot.leftSideBearing =
			glyph0.ot.leftSideBearing +
			( glyph1.ot.leftSideBearing - glyph0.ot.leftSideBearing ) * coef;
		this.ot.xMax =
			glyph0.ot.xMax + ( glyph1.ot.xMax - glyph0.ot.xMax ) * coef;
		this.ot.xMin =
			glyph0.ot.xMin + ( glyph1.ot.xMin - glyph0.ot.xMin ) * coef;
		this.ot.yMax =
			glyph0.ot.yMax + ( glyph1.ot.yMax - glyph0.ot.yMax ) * coef;
		this.ot.yMin =
			glyph0.ot.yMin + ( glyph1.ot.yMin - glyph0.ot.yMin ) * coef;
	}

	return this;
};

Glyph.prototype.updateOTCommands = function( path ) {
	if ( !path ) {
		this.ot.path.commands = [];
		path = this.ot.path;
	}

	this.contours.forEach(function( contour ) {
		contour.updateOTCommands( this.ot.path );
	}, this);

	return this.ot;
};

Glyph.prototype.importOT = function( otGlyph ) {
	var current;
	this.ot = otGlyph;

	if ( !otGlyph.path || !otGlyph.path.commands ) {
		return;
	}

	this.ot.path.commands.forEach(function(command) {
		switch ( command.type ) {
			case 'M':
				current = new paper.Path();
				this.addContour( current );

				current.moveTo( command );
				break;
			case 'L':
				current.lineTo( command );
				break;
			case 'C':
				current.cubicCurveTo(
					[command.x1, command.y1],
					[command.x2, command.y2],
					command
				);
				break;
			case 'Q':
				current.quadraticCurveTo(
					[command.x1, command.y1],
					command
				);
				break;
			case 'Z':
				// When the glyph has no contour,
				// they contain a single Z command in
				// opentype.js.
				// TODO: see how we should handle that
				if ( current ) {
					current.closePath();
				}
				break;
		}
	}, this);

	return this;
};

module.exports = Glyph;
},{"../node_modules/opentype.js/dist/opentype.js":1,"../node_modules/paper/dist/paper-core.js":2}],6:[function(_dereq_,module,exports){
var paper = _dereq_('../node_modules/paper/dist/paper-core.js');

Object.defineProperty( paper.Segment.prototype, 'x', {
	get: function() {
		return this.point.x;
	},
	set: function( value ) {
		this.point.x = value;
	}
});

Object.defineProperty( paper.Segment.prototype, 'y', {
	get: function() {
		return this.point.y;
	},
	set: function( value ) {
		this.point.y = value;
	}
});

module.exports = paper.Segment;
},{"../node_modules/paper/dist/paper-core.js":2}],7:[function(_dereq_,module,exports){
/* Extend the Path prototype to add OpenType conversion
 * and alias *segments methods and properties to *nodes
 */
var paper = _dereq_('../node_modules/paper/dist/paper-core.js'),
	proto = paper.PaperScope.prototype.Path.prototype;

// alias *Segments methods to *Nodes equivalents
['add', 'insert', 'remove'].forEach(function(name) {
	proto[name + 'Nodes'] =
		proto[name + 'Segments'];
});

// alias .segments to .nodes
Object.defineProperties(proto, {
	nodes: Object.getOwnPropertyDescriptor( proto, 'segments' ),
	firstNode: Object.getOwnPropertyDescriptor( proto, 'firstSegment' ),
	lastNode: Object.getOwnPropertyDescriptor( proto, 'lastSegment' )
});

proto.updateOTCommands = function( path ) {
	path.commands.push({
		type: 'M',
		x: Math.round( this._segments[0].point.x ) || 0,
		y: Math.round( this._segments[0].point.y ) || 0
	});

	this.curves.forEach(function( curve ) {
		if ( curve.isLinear() ) {
			path.commands.push({
				type: 'L',
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});

		} else {
			path.commands.push({
				type: 'C',
				x1: Math.round( curve.point1.x + curve.handle1.x ) || 0,
				y1: Math.round( curve.point1.y + curve.handle1.y ) || 0,
				x2: Math.round( curve.point2.x + curve.handle2.x ) || 0,
				y2: Math.round( curve.point2.y + curve.handle2.y ) || 0,
				x: Math.round( curve.point2.x ) || 0,
				y: Math.round( curve.point2.y ) || 0
			});
		}
	});

	return path;
};

module.exports = paper.Path;
},{"../node_modules/paper/dist/paper-core.js":2}],8:[function(_dereq_,module,exports){
var opentype = _dereq_('../node_modules/opentype.js/dist/opentype.js'),
	paper = _dereq_('../node_modules/paper/dist/paper-core.js'),
	Font = _dereq_('./Font.js'),
	Glyph = _dereq_('./Glyph.js'),
	Path = _dereq_('./Path.js'),
	Node = _dereq_('./Node.js'),
	Collection = _dereq_('./Collection.js');

paper.PaperScope.prototype.Font = Font;
paper.PaperScope.prototype.Glyph = Glyph;
paper.PaperScope.prototype.Path = Path;
paper.PaperScope.prototype.Node = Node;
paper.PaperScope.prototype.Collection = Collection;

function plumin( arg ) {
	if ( arguments.length === 1 && arg instanceof Collection ) {
		return arg;
	}

	var c = Object.create( Collection.prototype );
	Collection.apply( c, arguments );
	return c;
}

plumin.opentype = opentype;

plumin.proxy = Collection.proxy.bind(plumin);
plumin.proxy(paper);

module.exports = plumin;
},{"../node_modules/opentype.js/dist/opentype.js":1,"../node_modules/paper/dist/paper-core.js":2,"./Collection.js":3,"./Font.js":4,"./Glyph.js":5,"./Node.js":6,"./Path.js":7}]},{},[8])(8)
});



//# sourceMappingURL=plumin.js.map
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":"/home/louisremi/Workspace/prototypo.js/node_modules/browserify/node_modules/process/browser.js"}],"/home/louisremi/Workspace/prototypo.js/src/Utils.js":[function(require,module,exports){
(function (global){
(function (global){
(function (global){
var plumin = require('../node_modules/plumin.js/dist/plumin.js'),
	paper = plumin.paper,
	DepTree = require('../node_modules/deptree/index.js');

var Utils = {};

// create Glyph instance and all its child items: anchors, contours and components
Utils.glyphFromSrc = function( glyphSrc ) {
	var glyph = new paper.Glyph({
		name: glyphSrc.name,
		unicode: glyphSrc.unicode
	});
	glyph.src = glyphSrc;
	Utils.mergeStatic( glyph, glyphSrc );

	if ( glyphSrc.anchors ) {
		glyphSrc.anchors.forEach(function(anchorSrc) {
			var anchor = new paper.Node();
			anchor.src = anchorSrc;
			Utils.mergeStatic( anchor, anchorSrc );

			glyph.addAnchor( anchor );
		});
	}

	if ( glyphSrc.contours ) {
		glyphSrc.contours.forEach(function(contourSrc) {
			var contour = new paper.Path();
			contour.src = contourSrc;
			Utils.mergeStatic( contour, contourSrc );

			glyph.addContour( contour );

			// TODO: handle oncurve/offcurve points
			contourSrc.nodes.forEach(function(nodeSrc) {
				var node = new paper.Node();
				node.src = nodeSrc;
				Utils.mergeStatic( node, nodeSrc );

				contour.add( node );
			});
		});
	}

	return glyph;
};

Utils.propFromPath = function( path, length, context ) {
	for ( var i = -1; ++i < length; ) {
		context = context[ path[i] ];
	}

	return context;
};

Utils.mergeStatic = function( obj, src ) {
	for ( var i in src ) {
		if ( typeof src[i] !== 'object' ) {
			obj[i] = src[i];
		}
	}
};

Utils.createUpdaters = function( leaf ) {
	if ( leaf.constructor === Object &&
			( typeof leaf._operation === 'string' || typeof leaf._operation === 'function' ) ) {

		var args = ['propName', 'contours', 'anchors', 'parentAnchors', 'Utils']
				.concat( leaf._parameters || [] )
				.concat( typeof leaf._operation === 'string' ?
					'return ' + leaf._operation:
					leaf._operation.toString()
						.replace(/function\s*()\s*\{(.*?)\}$/, '$1').trim()
				);

		return ( leaf._updater = Function.apply( null, args ) );
	}

	if ( leaf.constructor === Object ) {
		for ( var i in leaf ) {
			Utils.createUpdaters( leaf[i] );
		}
	}

	if ( leaf.constructor === Array ) {
		leaf.forEach(function(child) {
			Utils.createUpdaters( child );
		});
	}
};

// convert the glyph source from the ufo object model to the paper object model
// this is the inverse operation done by jsufonify
Utils.ufoToPaper = function( src ) {
	if ( src.anchor ) {
		src.anchors = src.anchor;
		delete src.anchor;
	}

	if ( src.outline && src.outline.contour ) {
		src.contours = src.outline.contour;
		delete src.outline.contour;
	}

	src.contours.forEach(function(contour) {
		if ( contour.point ) {
			contour.nodes = contour.point;
			delete contour.point;
		}
	});

	if ( src.outline && src.outline.component ) {
		src.components = src.outline.component;
		delete src.outline.contour;
	}

	if ( src.lib && src.lib.transformList ) {
		src.transformList = src.lib.transformList;
		delete src.lib.transformList;
	}
};

// Useless right now, we do it in Glyph.prototype.update in prototypo.js
Utils.updateAttr = function( attr, params, glyph ) {
	var args = [ glyph.contours, glyph.anchors, glyph.parentAnchors, Utils ];
	( attr._parameters || [] ).forEach(function(name) {
		args.push( params[name] );
	});
	return attr._updater.apply( {}, args );
};

Utils.solveDependencyTree = function( leafSrc, path, excludeList ) {
	if ( !excludeList ) {
		excludeList = [];
	}

	var depTree = new DepTree();

	Utils.excludeList( leafSrc, null, excludeList );

	Utils.dependencyTree( leafSrc, null, excludeList, depTree );

	return depTree.resolve();
};

Utils.excludeList = function( leafSrc, path, excludeList ) {
	for ( var i in leafSrc ) {
		var attr = leafSrc[i],
			currPath = path ? path + '.' + i : i;

		if ( typeof attr !== 'object' ) {
			// static props are immediatly available, exclude them from the tree
			excludeList.push( currPath );

		// recurse
		} else if ( !attr._dependencies && !attr._operation ) {
			Utils.excludeList( attr, currPath, excludeList );
		}
	}
};

Utils.dependencyTree = function( leafSrc, path, excludeList, depTree ) {
	for ( var i in leafSrc ) {
		var attr = leafSrc[i],
			currPath = path ? path + '.' + i : i;

		if ( typeof attr === 'object' ) {
			// objects with updater functions have dependencies
			if ( attr._dependencies ) {
				var deps = attr._dependencies.filter(function(dep) {
					return excludeList.indexOf( dep ) === -1;
				});
				deps = Utils.expandDependencies( deps, excludeList );
				depTree.add(currPath, deps);
			}

			if ( !attr._dependencies && !attr._operation ) {
				Utils.dependencyTree( attr, currPath, excludeList, depTree );
			}
		}
	}

	return depTree;
};

var rpoint = /\.point$/,
	rnode = /\.nodes\.\d+$/;
Utils.expandDependencies = function( deps, excludeList ) {
	deps = deps.map(function(dep) {
		var deps;

		if ( rpoint.test(dep) ) {
			dep = dep.replace(rpoint, '');

			deps = [
				dep + '.x',
				dep + '.y'
			];

		} else if ( rnode.test(dep) ) {
			deps = [
				dep + '.x',
				dep + '.y',
				dep + '.expand'
			];

		} else {
			return dep;
		}

		return deps.filter(function(dep) {
			return excludeList.indexOf( dep ) === -1;
		});
	});

	// flatten deps array
	return [].concat.apply([], deps);
};

// The following function should be useless, thanks to paper
Utils.lineLineIntersection = function( p1, p2, p3, p4 ) {
	var x1 = p1.x,
		y1 = p1.y,
		x2 = p2.x,
		y2 = p2.y,
		x3 = p3.x,
		y3 = p3.y,
		x4 = p4.x,
		y4 = p4.y,
		d = (x1-x2) * (y3-y4) - (y1-y2) * (x3-x4);

	if ( d === 0 ) {
		// fail silently
		return [0, 0];
	}

	return new Float32Array([
		( (x1*y2 - y1*x2) * (x3-x4) - (x1-x2) * (x3*y4 - y3*x4) ) / d,
		( (x1*y2 - y1*x2) * (y3-y4) - (y1-y2) * (x3*y4 - y3*x4) ) / d
	]);
};

// Object.mixin polyfill for IE9+
if ( !global.Object.mixin ) {
	global.Object.mixin = function( target, source ) {
		var props = Object.getOwnPropertyNames(source),
			p,
			descriptor,
			length = props.length;

		for (p = 0; p < length; p++) {
			descriptor = Object.getOwnPropertyDescriptor(source, props[p]);
			try {
				Object.defineProperty(target, props[p], descriptor);
			} catch (e) {
				// in node, some properties cannot be redefiend and we're ok with it
			}
		}

		return target;
	};
}

module.exports = Utils;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../node_modules/deptree/index.js":"/home/louisremi/Workspace/prototypo.js/node_modules/deptree/index.js","../node_modules/plumin.js/dist/plumin.js":"/home/louisremi/Workspace/prototypo.js/node_modules/plumin.js/dist/plumin.js"}],"/home/louisremi/Workspace/prototypo.js/src/naive.js":[function(require,module,exports){
var plumin = require('../node_modules/plumin.js/dist/plumin.js'),
	paper = plumin.paper,
	Utils = require('./Utils.js');

var naive = {};

// default method to expand skeletons:
// derives two additional node from every node with an .expand object
naive.expandSkeletons = function( glyph ) {
	glyph.contours.forEach(function( contour, i ) {
		if ( contour.skeleton !== true ) {
			return;
		}

		var leftContour,
			rightContour,
			leftNodes = [],
			rightNodes = [],
			firstNode,
			lastNode;

		contour.nodes.forEach(function( node, j ) {
			// TODO: a node should be able to specify two arbitrary expanded nodes
			var left = new paper.Node(),
				right = new paper.Node();

			leftNodes.push(left);
			rightNodes.unshift(right);
			node.expandedTo = [left, right];
			left.expandedFrom = right.expandedFrom = node;

			left.src = {
				_dependencies: ['contours.' + i + '.nodes.' + j],
				_parameters: ['width'],
				_updater: naive.expandedNodeUpdater('left')
			};
			right.src = {
				_dependencies: ['contours.' + i + '.nodes.' + j],
				_parameters: ['width'],
				_updater: naive.expandedNodeUpdater('right')
			};
			node.src.expandedTo = [left.src, right.src];

		});

		if ( !contour.expandedTo && !contour.closed ) {
			leftContour = new paper.Path({
				closed: true,
				segments: leftNodes.concat(rightNodes)
			});
			contour.expandedTo = [leftContour];
			leftContour.expandedFrom = contour;
			glyph.addContour(leftContour);

			firstNode = contour.firstNode;
			lastNode = contour.lastNode;

			firstNode.expandedTo[0].type = 'corner';
			firstNode.expandedTo[1].type = 'corner';
			lastNode.expandedTo[0].type = 'corner';
			lastNode.expandedTo[1].type = 'corner';

			firstNode.expandedTo[0].typeOut = 'line';
			firstNode.expandedTo[1].typeIn = 'line';
			lastNode.expandedTo[0].typeOut = 'line';
			lastNode.expandedTo[1].typeIn = 'line';

		} else if ( !contour.expandedTo && contour.closed ) {
			leftContour = new paper.Path({
				closed: true,
				segments: leftNodes
			});
			rightContour = new paper.Path({
				closed: true,
				segments: rightNodes
			});
			contour.expandedTo = [
				leftContour,
				rightContour
			];
			leftContour.expandedFrom = rightContour.expandedFrom = contour;
			glyph.addContours([
				leftContour,
				rightContour
			]);
		}
	});
};

// Calculate expanded node position
// and copy properties from skeleton, according to the side
naive.expandedNodeUpdater = function( side ) {
	return function( propName, contours, anchors, parentAnchors, Utils, _width ) {
		var node = this[propName],
			origin = node.expandedFrom,
			expand = origin.expand,
			width = expand && expand.width !== undefined ?
				expand.width: _width,
			coef = expand && expand.distr !== undefined ?
				( side === 'left' ? expand.distr : 1 - expand.distr ):
				0.5,
			angle = ( side === 'left' ? Math.PI : 0 ) +
				( expand && expand.angle !== undefined ?
					expand.angle:
					( origin._dirOut !== undefined ?
						origin._dirOut - Math.PI / 2:
						origin._dirIn + Math.PI / 2
					)
				);

		// position
		node.point.x = origin.point.x + ( width * coef * Math.cos( angle ) );
		node.point.y = origin.point.y + ( width * coef * Math.sin( angle ) );

		// node type
		if ( origin.type !== undefined ) {
			node.type = origin.type;
		}

		// direction type
		if ( origin.typeIn !== undefined ) {
			node[ side === 'left' ? 'typeIn' : 'typeOut' ] = origin.typeIn;
		}
		if ( origin.typeOut !== undefined ) {
			node[ side === 'left' ? 'typeOut' : 'typeIn' ] = origin.typeOut;
		}

		// direction
		if ( origin._dirIn !== undefined ) {
			node[ side === 'left' ? '_dirIn' : '_dirOut' ] = origin._dirIn;

			if ( node.type === 'smooth' ) {
				node[ side === 'left' ? '_dirOut' : '_dirIn' ] = origin._dirIn + Math.PI;
			}
		}
		if ( origin._dirOut !== undefined ) {
			node[ side === 'left' ? '_dirOut' : '_dirIn' ] = origin._dirOut;

			if ( node.type === 'smooth' ) {
				node[ side === 'left' ? '_dirIn' : '_dirOut' ] = origin._dirOut + Math.PI;
			}
		}
		// use angle if direction isn't already defined
		if ( node._dirIn === undefined ) {
			node._dirIn = ( origin.angle || 0 ) +
				( side === 'left' ? 0 : Math.PI ) - Math.PI / 2;
		}
		if ( node._dirOut === undefined ) {
			node._dirOut = ( origin.angle || 0 ) +
				( side === 'left' ? 0 : Math.PI ) + Math.PI / 2;
		}

		// tension
		node.tensionIn = origin[ 'tension' + side === 'left' ? 'In' : 'Out' ] !== undefined ?
			origin[ 'tension' + side === 'left' ? 'In' : 'Out' ]:
			origin.tension !== undefined ? origin.tension : 1;
		node.tensionOut = origin[ 'tension' + side === 'left' ? 'Out' : 'In' ] !== undefined ?
			origin[ 'tension' + side === 'left' ? 'Out' : 'In' ]:
			origin.tension !== undefined ? origin.tension : 1;
	};
};

// Make sure 'line' types are set on both side of segments
// and if a smooth node is used in a straight segment, update the directions appropriately
// this can only be done once the types of all nodes have been updated
// can be renamed #prepareLines if no other operation is added
naive.prepareContour = function( path ) {
	path.nodes.forEach(function(node) {
		if ( node.typeIn === 'line' && node.previous ) {
			node.previous.typeOut = 'line';

			if ( node.type === 'smooth' ) {
				node._dirIn = node.point.getAngleInRadians( node.previous.point );
				node._dirOut = node._dirIn + Math.PI;
			}
		}

		if ( node.typeOut === 'line' && node.next ) {
			node.next.typeIn = 'line';

			if ( node.type === 'smooth' ) {
				node._dirOut = node.point.getAngleInRadians( node.next.point );
				node._dirIn = node._dirOut + Math.PI;
			}
		}
	});
};

// sets the position of control points
// can be renamed #updateControls if no other operation is added
naive.updateContour = function( path, params ) {
	var curviness = params.curviness || 2/3;

	path.nodes.forEach(function(node) {
		var start = node,
			end,
			startCtrl,
			endCtrl,
			startType,
			endType,
			startTension,
			endTension,
			startDir,
			endDir,
			lli;

		if ( !node.next ) {
			return;

		} else {
			end = node.next;
			startCtrl = start.handleOut;
			endCtrl = end.handleIn;

			startType = start.typeOut;
			endType = end.typeIn;
		}

		if ( startType === 'line' || endType === 'line' ) {
			startCtrl.x = 0;
			startCtrl.y = 0;
			endCtrl.x = 0;
			endCtrl.y = 0;

			return;
		}

		startTension = start.tensionOut !== undefined ?
			start.tensionOut:
			start.tension !== undefined ? start.tension : 1;
		endTension = end.tensionIn !== undefined ?
			end.tensionIn:
			end.tension !== undefined ? end.tension : 1;

		startDir = start._dirOut !== undefined ?
			start._dirOut:
			start.type === 'smooth' ? start._dirIn + Math.PI : 0;
		endDir = end._dirIn !== undefined ?
			end._dirIn:
			end.type === 'smooth' ? end._dirOut - Math.PI : 0;

		if ( start.point.x === 0 ) {
			lli = [ 0, end.point.y - Math.tan( endDir ) * end.point.x ];

		} else if ( end.point.x === 0 ) {
			lli = [ 0, start.point.y - Math.tan( startDir ) * start.point.x ];

		} else {
			lli = Utils.lineLineIntersection(
				start.point,
				{ x: 0, y: start.point.y - Math.tan( startDir ) * start.point.x },
				end.point,
				{ x: 0, y: end.point.y - Math.tan( endDir ) * end.point.x }
			);
		}

		startCtrl.x = start.point.x + ( lli[0] - start.point.x ) * curviness * startTension;
		startCtrl.y = start.point.y + ( lli[1] - start.point.y ) * curviness * startTension;
		endCtrl.x = end.point.x + ( lli[0] - end.point.x ) * curviness * endTension;
		endCtrl.y = end.point.y + ( lli[1] - end.point.y ) * curviness * endTension;
	});
};

var rdeg = /deg$/;
Object.defineProperties(paper.PaperScope.prototype.Segment.prototype, {
	expand: {
		get: function() {
			return this._expand;
		},
		set: function( expand ) {
			if ( typeof expand.angle === 'string' && rdeg.test( expand.angle ) ) {
				expand.angle = parseFloat(expand.angle) * ( Math.PI * 2 / 360 );
			}

			this._expand = expand;
		}
	},
	dirIn: {
		get: function() {
			return this._dirIn;
		},
		set: function( dir ) {
			if ( typeof dir === 'string' && rdeg.test( dir ) ) {
				this._dirIn = parseFloat(dir) * ( Math.PI * 2 / 360 );
			} else {
				this._dirIn = dir;
			}
		}
	},
	dirOut: {
		get: function() {
			return this._dirOut;
		},
		set: function( dir ) {
			if ( typeof dir === 'string' && rdeg.test( dir ) ) {
				this._dirOut = parseFloat(dir) * ( Math.PI * 2 / 360 );
			} else {
				this._dirOut = dir;
			}
		}
	}
});

module.exports = naive;
},{"../node_modules/plumin.js/dist/plumin.js":"/home/louisremi/Workspace/prototypo.js/node_modules/plumin.js/dist/plumin.js","./Utils.js":"/home/louisremi/Workspace/prototypo.js/src/Utils.js"}],"/home/louisremi/Workspace/prototypo.js/src/prototypo.js":[function(require,module,exports){
/*jshint -W098 */
var plumin = require('../node_modules/plumin.js/dist/plumin.js'),
	paper = plumin.paper,
	Utils = require('./Utils.js'),
	naive = require('./naive.js');

function ParametricFont( src ) {
	var fontinfo,
		font,
		name,
		glyphSrc,
		glyph;

	// TODO: this block is only here for backward compat
	// and should be removed at some point in the future
	if ( !src.fontinfo ) {
		src.fontinfo = src.info;
	}

	font = new paper.Font( src.fontinfo );

	font.src = src;

	for ( name in src.glyphs ) {
		glyphSrc = src.glyphs[name];

		Utils.ufoToPaper( glyphSrc );

		Utils.createUpdaters( glyphSrc );

		glyph = Utils.glyphFromSrc( glyphSrc );

		font.addGlyph( glyph );

		naive.expandSkeletons( glyph );

		glyph.solvingOrder = Utils.solveDependencyTree( glyphSrc ).map(function(path) {
			return path.split('.');
		});
	}

	return font;
}

plumin.ParametricFont = ParametricFont;
plumin.Utils = Utils;
plumin.Utils.naive = naive;

paper.PaperScope.prototype.Font.prototype.update = function( params, set ) {
	return this.getGlyphSubset( set ).map(function( glyph ) {
		return glyph.update( params, this );
	}, this);
};

paper.PaperScope.prototype.Glyph.prototype.update = function( params ) {
	this.solvingOrder.forEach(function(path) {
		var propName = path[path.length -1],
			src = Utils.propFromPath( path, path.length, this.src ),
			obj = Utils.propFromPath( path, path.length -1, this ),
			result = src && src._updater.apply( obj,
				[ propName, this.contours, this.anchors, this.parentAnchors, Utils ].concat(
					src._parameters.map(function(name) {
						return params[name];
					})
				)
			);

		// this assignement could be placed right inside the _updater,
		// but it would make it harder to debug
		if ( result !== undefined ) {
			obj[propName] = result;
		}
	}, this);

	this.contours.forEach(function(contour) {
		// prepare skeletons and outlines, but not expanded contours
		if ( contour.expandedFrom === undefined ) {
			naive.prepareContour( contour );
		}

		// update outlines and expanded contours, but not skeletons
		if ( contour.skeleton !== true ) {
			naive.updateContour( contour, params );
		}
	});
};

module.exports = plumin;
},{"../node_modules/plumin.js/dist/plumin.js":"/home/louisremi/Workspace/prototypo.js/node_modules/plumin.js/dist/plumin.js","./Utils.js":"/home/louisremi/Workspace/prototypo.js/src/Utils.js","./naive.js":"/home/louisremi/Workspace/prototypo.js/src/naive.js"}]},{},["/home/louisremi/Workspace/prototypo.js/src/prototypo.js"])("/home/louisremi/Workspace/prototypo.js/src/prototypo.js")
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RlcHRyZWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGx1bWluLmpzL2Rpc3QvcGx1bWluLmpzIiwic3JjL1V0aWxzLmpzIiwic3JjL25haXZlLmpzIiwic3JjL3Byb3RvdHlwby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzbGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5NdXRhdGlvbk9ic2VydmVyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICB2YXIgcXVldWUgPSBbXTtcblxuICAgIGlmIChjYW5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIHZhciBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcXVldWVMaXN0ID0gcXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBxdWV1ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkRpdi5zZXRBdHRyaWJ1dGUoJ3llcycsICdubycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwidmFyIERlcFRyZWUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5ub2RlcyA9IHt9OyBcbn07XG5cbkRlcFRyZWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5vZGUsIGRlcGVuZGFudHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghZGVwZW5kYW50cykge1xuICAgIGRlcGVuZGFudHMgPSBbXTtcbiAgfSBlbHNlIGlmICghKGRlcGVuZGFudHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBkZXBlbmRhbnRzID0gW2RlcGVuZGFudHNdO1xuICB9XG5cbiAgdGhpcy5ub2Rlc1tub2RlXSA9IGRlcGVuZGFudHM7XG59O1xuXG5cbkRlcFRyZWUucHJvdG90eXBlLnJlc29sdmVOb2RlID0gZnVuY3Rpb24obm9kZSwgcmVzb2x2ZWQsIHByb2Nlc3NpbmcpIHtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmVzb2x2ZWQgPSByZXNvbHZlZCB8fCBbXTtcbiAgcHJvY2Vzc2luZyA9IHByb2Nlc3NpbmcgfHwge307XG4gIHZhciBkZXBzID0gdGhpcy5ub2Rlc1tub2RlXSB8fCBbXTtcblxuICBwcm9jZXNzaW5nW25vZGVdID0gdHJ1ZTtcblxuICBkZXBzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XG4gICAgaWYgKHJlc29sdmVkLmluZGV4T2YoZGVwKSAhPSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzc2luZ1tkZXBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NpcmN1bGFyIGRlcGVuZGVuY3k6ICcrZGVwKTtcbiAgICB9XG4gICAgc2VsZi5yZXNvbHZlTm9kZShkZXAsIHJlc29sdmVkLCBwcm9jZXNzaW5nKTtcbiAgfSk7XG5cbiAgaWYgKHJlc29sdmVkLmluZGV4T2Yobm9kZSkgPT0gLTEpIHtcbiAgICBwcm9jZXNzaW5nW25vZGVdID0gZmFsc2U7XG4gICAgcmVzb2x2ZWQucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59O1xuXG5EZXBUcmVlLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIHJlc29sdmVkID0gW107XG4gIGZvciAodmFyIG5vZGUgaW4gdGhpcy5ub2Rlcykge1xuICAgIHRoaXMucmVzb2x2ZU5vZGUobm9kZSwgcmVzb2x2ZWQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc29sdmVkO1xuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRGVwVHJlZTtcbiIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYucGx1bWluPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYub3BlbnR5cGU9ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIF9kZXJlcV89PVwiZnVuY3Rpb25cIiYmX2RlcmVxXztpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgX2RlcmVxXz09XCJmdW5jdGlvblwiJiZfZGVyZXFfO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBSdW4tdGltZSBjaGVja2luZyBvZiBwcmVjb25kaXRpb25zLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFByZWNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIGlzIHRydWUuXG4vLyBJZiBub3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5leHBvcnRzLmFyZ3VtZW50ID0gZnVuY3Rpb24gKHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIGFzc2VydGlvbiBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLmFyZ3VtZW50O1xuXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIERyYXdpbmcgdXRpbGl0eSBmdW5jdGlvbnMuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gRHJhdyBhIGxpbmUgb24gdGhlIGdpdmVuIGNvbnRleHQgZnJvbSBwb2ludCBgeDEseTFgIHRvIHBvaW50IGB4Mix5MmAuXG5mdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5cbmV4cG9ydHMubGluZSA9IGxpbmU7XG5cbn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gR2x5cGggZW5jb2RpbmdcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2ZmU3RhbmRhcmRTdHJpbmdzID0gW1xuICAgICcubm90ZGVmJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG4gICAgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsICdlcXVhbCcsICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG4gICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsXG4gICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsXG4gICAgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsXG4gICAgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZW5kYXNoJywgJ2RhZ2dlcicsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncGFyYWdyYXBoJyxcbiAgICAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JywgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJyxcbiAgICAncXVlc3Rpb25kb3duJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICdyaW5nJyxcbiAgICAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJywgJ2VtZGFzaCcsICdBRScsICdvcmRmZW1pbmluZScsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJyxcbiAgICAnb3JkbWFzY3VsaW5lJywgJ2FlJywgJ2RvdGxlc3NpJywgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscycsICdvbmVzdXBlcmlvcicsICdsb2dpY2Fsbm90JywgJ211JyxcbiAgICAndHJhZGVtYXJrJywgJ0V0aCcsICdvbmVoYWxmJywgJ3BsdXNtaW51cycsICdUaG9ybicsICdvbmVxdWFydGVyJywgJ2RpdmlkZScsICdicm9rZW5iYXInLCAnZGVncmVlJywgJ3Rob3JuJyxcbiAgICAndGhyZWVxdWFydGVycycsICd0d29zdXBlcmlvcicsICdyZWdpc3RlcmVkJywgJ21pbnVzJywgJ2V0aCcsICdtdWx0aXBseScsICd0aHJlZXN1cGVyaW9yJywgJ2NvcHlyaWdodCcsXG4gICAgJ0FhY3V0ZScsICdBY2lyY3VtZmxleCcsICdBZGllcmVzaXMnLCAnQWdyYXZlJywgJ0FyaW5nJywgJ0F0aWxkZScsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnRWNpcmN1bWZsZXgnLFxuICAgICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ050aWxkZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLFxuICAgICdPZGllcmVzaXMnLCAnT2dyYXZlJywgJ090aWxkZScsICdTY2Fyb24nLCAnVWFjdXRlJywgJ1VjaXJjdW1mbGV4JywgJ1VkaWVyZXNpcycsICdVZ3JhdmUnLCAnWWFjdXRlJyxcbiAgICAnWWRpZXJlc2lzJywgJ1pjYXJvbicsICdhYWN1dGUnLCAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2FncmF2ZScsICdhcmluZycsICdhdGlsZGUnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJyxcbiAgICAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJywgJ2VncmF2ZScsICdpYWN1dGUnLCAnaWNpcmN1bWZsZXgnLCAnaWRpZXJlc2lzJywgJ2lncmF2ZScsICdudGlsZGUnLCAnb2FjdXRlJyxcbiAgICAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJywgJ29ncmF2ZScsICdvdGlsZGUnLCAnc2Nhcm9uJywgJ3VhY3V0ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAndWdyYXZlJyxcbiAgICAneWFjdXRlJywgJ3lkaWVyZXNpcycsICd6Y2Fyb24nLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICcyNjYgZmYnLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICd6ZXJvb2xkc3R5bGUnLCAnb25lb2xkc3R5bGUnLCAndHdvb2xkc3R5bGUnLCAndGhyZWVvbGRzdHlsZScsICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJyxcbiAgICAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLFxuICAgICdxdWVzdGlvbnNtYWxsJywgJ2FzdXBlcmlvcicsICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnaXN1cGVyaW9yJywgJ2xzdXBlcmlvcicsXG4gICAgJ21zdXBlcmlvcicsICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJ2ZmJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJywgJ0NzbWFsbCcsICdEc21hbGwnLCAnRXNtYWxsJywgJ0ZzbWFsbCcsICdHc21hbGwnLCAnSHNtYWxsJywgJ0lzbWFsbCcsICdKc21hbGwnLCAnS3NtYWxsJywgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsICdOc21hbGwnLCAnT3NtYWxsJywgJ1BzbWFsbCcsICdRc21hbGwnLCAnUnNtYWxsJywgJ1NzbWFsbCcsICdUc21hbGwnLCAnVXNtYWxsJywgJ1ZzbWFsbCcsICdXc21hbGwnLFxuICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICdleGNsYW1kb3duc21hbGwnLFxuICAgICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLFxuICAgICdEb3RhY2NlbnRzbWFsbCcsICdNYWNyb25zbWFsbCcsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLFxuICAgICd6ZXJvc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJyxcbiAgICAnemVyb2luZmVyaW9yJywgJ29uZWluZmVyaW9yJywgJ3R3b2luZmVyaW9yJywgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsXG4gICAgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJyxcbiAgICAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJyxcbiAgICAnQXJpbmdzbWFsbCcsICdBRXNtYWxsJywgJ0NjZWRpbGxhc21hbGwnLCAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsXG4gICAgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJywgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLFxuICAgICdPYWN1dGVzbWFsbCcsICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLFxuICAgICdVYWN1dGVzbWFsbCcsICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnLCAnMDAxLjAwMCcsXG4gICAgJzAwMS4wMDEnLCAnMDAxLjAwMicsICcwMDEuMDAzJywgJ0JsYWNrJywgJ0JvbGQnLCAnQm9vaycsICdMaWdodCcsICdNZWRpdW0nLCAnUmVndWxhcicsICdSb21hbicsICdTZW1pYm9sZCddO1xuXG52YXIgY2ZmU3RhbmRhcmRFbmNvZGluZyA9IFtcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG4gICAgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsICdlcXVhbCcsICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG4gICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsXG4gICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJywgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsXG4gICAgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnJywgJ2VuZGFzaCcsICdkYWdnZXInLFxuICAgICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAnJywgJ3BhcmFncmFwaCcsICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLFxuICAgICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsICcnLCAncXVlc3Rpb25kb3duJywgJycsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJyxcbiAgICAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICcnLCAncmluZycsICdjZWRpbGxhJywgJycsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJyxcbiAgICAnZW1kYXNoJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdBRScsICcnLCAnb3JkZmVtaW5pbmUnLCAnJywgJycsICcnLFxuICAgICcnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsICdvcmRtYXNjdWxpbmUnLCAnJywgJycsICcnLCAnJywgJycsICdhZScsICcnLCAnJywgJycsICdkb3RsZXNzaScsICcnLCAnJyxcbiAgICAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJ107XG5cbnZhciBjZmZFeHBlcnRFbmNvZGluZyA9IFtcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJycsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJ3R3b2RvdGVubGVhZGVyJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdmcmFjdGlvbicsICd6ZXJvb2xkc3R5bGUnLCAnb25lb2xkc3R5bGUnLCAndHdvb2xkc3R5bGUnLCAndGhyZWVvbGRzdHlsZScsXG4gICAgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLCAnc2V2ZW5vbGRzdHlsZScsICdlaWdodG9sZHN0eWxlJywgJ25pbmVvbGRzdHlsZScsICdjb2xvbicsXG4gICAgJ3NlbWljb2xvbicsICdjb21tYXN1cGVyaW9yJywgJ3RocmVlcXVhcnRlcnNlbWRhc2gnLCAncGVyaW9kc3VwZXJpb3InLCAncXVlc3Rpb25zbWFsbCcsICcnLCAnYXN1cGVyaW9yJyxcbiAgICAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJycsICcnLCAnaXN1cGVyaW9yJywgJycsICcnLCAnbHN1cGVyaW9yJywgJ21zdXBlcmlvcicsXG4gICAgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAnJywgJycsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICcnLCAnZmYnLCAnZmknLCAnZmwnLCAnZmZpJywgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJycsICdwYXJlbnJpZ2h0aW5mZXJpb3InLCAnQ2lyY3VtZmxleHNtYWxsJywgJ2h5cGhlbnN1cGVyaW9yJywgJ0dyYXZlc21hbGwnLCAnQXNtYWxsJyxcbiAgICAnQnNtYWxsJywgJ0NzbWFsbCcsICdEc21hbGwnLCAnRXNtYWxsJywgJ0ZzbWFsbCcsICdHc21hbGwnLCAnSHNtYWxsJywgJ0lzbWFsbCcsICdKc21hbGwnLCAnS3NtYWxsJywgJ0xzbWFsbCcsXG4gICAgJ01zbWFsbCcsICdOc21hbGwnLCAnT3NtYWxsJywgJ1BzbWFsbCcsICdRc21hbGwnLCAnUnNtYWxsJywgJ1NzbWFsbCcsICdUc21hbGwnLCAnVXNtYWxsJywgJ1ZzbWFsbCcsICdXc21hbGwnLFxuICAgICdYc21hbGwnLCAnWXNtYWxsJywgJ1pzbWFsbCcsICdjb2xvbm1vbmV0YXJ5JywgJ29uZWZpdHRlZCcsICdydXBpYWgnLCAnVGlsZGVzbWFsbCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd25zbWFsbCcsICdjZW50b2xkc3R5bGUnLCAnTHNsYXNoc21hbGwnLCAnJywgJycsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJyxcbiAgICAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJywgJycsICdEb3RhY2NlbnRzbWFsbCcsICcnLCAnJywgJ01hY3JvbnNtYWxsJywgJycsICcnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsXG4gICAgJycsICcnLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsICcnLCAnJywgJycsICdvbmVxdWFydGVyJywgJ29uZWhhbGYnLCAndGhyZWVxdWFydGVycycsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsICcnLFxuICAgICcnLCAnemVyb3N1cGVyaW9yJywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLCAnZm91cnN1cGVyaW9yJywgJ2ZpdmVzdXBlcmlvcicsXG4gICAgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLCAnemVyb2luZmVyaW9yJywgJ29uZWluZmVyaW9yJywgJ3R3b2luZmVyaW9yJyxcbiAgICAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJywgJ3NldmVuaW5mZXJpb3InLCAnZWlnaHRpbmZlcmlvcicsXG4gICAgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLCAnY29tbWFpbmZlcmlvcicsICdBZ3JhdmVzbWFsbCcsXG4gICAgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLCAnQXJpbmdzbWFsbCcsICdBRXNtYWxsJywgJ0NjZWRpbGxhc21hbGwnLFxuICAgICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJywgJ0lncmF2ZXNtYWxsJywgJ0lhY3V0ZXNtYWxsJyxcbiAgICAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsICdPYWN1dGVzbWFsbCcsXG4gICAgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsICdVYWN1dGVzbWFsbCcsXG4gICAgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCddO1xuXG52YXIgc3RhbmRhcmROYW1lcyA9IFtcbiAgICAnLm5vdGRlZicsICcubnVsbCcsICdub25tYXJraW5ncmV0dXJuJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JyxcbiAgICAnYW1wZXJzYW5kJywgJ3F1b3Rlc2luZ2xlJywgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsXG4gICAgJ3plcm8nLCAnb25lJywgJ3R3bycsICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLFxuICAgICdlcXVhbCcsICdncmVhdGVyJywgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJyxcbiAgICAnUCcsICdRJywgJ1InLCAnUycsICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLFxuICAgICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJywgJ2dyYXZlJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJyxcbiAgICAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJyxcbiAgICAnQWRpZXJlc2lzJywgJ0FyaW5nJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdOdGlsZGUnLCAnT2RpZXJlc2lzJywgJ1VkaWVyZXNpcycsICdhYWN1dGUnLCAnYWdyYXZlJyxcbiAgICAnYWNpcmN1bWZsZXgnLCAnYWRpZXJlc2lzJywgJ2F0aWxkZScsICdhcmluZycsICdjY2VkaWxsYScsICdlYWN1dGUnLCAnZWdyYXZlJywgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsXG4gICAgJ2lhY3V0ZScsICdpZ3JhdmUnLCAnaWNpcmN1bWZsZXgnLCAnaWRpZXJlc2lzJywgJ250aWxkZScsICdvYWN1dGUnLCAnb2dyYXZlJywgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsXG4gICAgJ290aWxkZScsICd1YWN1dGUnLCAndWdyYXZlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICdkYWdnZXInLCAnZGVncmVlJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnc2VjdGlvbicsXG4gICAgJ2J1bGxldCcsICdwYXJhZ3JhcGgnLCAnZ2VybWFuZGJscycsICdyZWdpc3RlcmVkJywgJ2NvcHlyaWdodCcsICd0cmFkZW1hcmsnLCAnYWN1dGUnLCAnZGllcmVzaXMnLCAnbm90ZXF1YWwnLFxuICAgICdBRScsICdPc2xhc2gnLCAnaW5maW5pdHknLCAncGx1c21pbnVzJywgJ2xlc3NlcXVhbCcsICdncmVhdGVyZXF1YWwnLCAneWVuJywgJ211JywgJ3BhcnRpYWxkaWZmJywgJ3N1bW1hdGlvbicsXG4gICAgJ3Byb2R1Y3QnLCAncGknLCAnaW50ZWdyYWwnLCAnb3JkZmVtaW5pbmUnLCAnb3JkbWFzY3VsaW5lJywgJ09tZWdhJywgJ2FlJywgJ29zbGFzaCcsICdxdWVzdGlvbmRvd24nLFxuICAgICdleGNsYW1kb3duJywgJ2xvZ2ljYWxub3QnLCAncmFkaWNhbCcsICdmbG9yaW4nLCAnYXBwcm94ZXF1YWwnLCAnRGVsdGEnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsbGVtb3RyaWdodCcsXG4gICAgJ2VsbGlwc2lzJywgJ25vbmJyZWFraW5nc3BhY2UnLCAnQWdyYXZlJywgJ0F0aWxkZScsICdPdGlsZGUnLCAnT0UnLCAnb2UnLCAnZW5kYXNoJywgJ2VtZGFzaCcsICdxdW90ZWRibGxlZnQnLFxuICAgICdxdW90ZWRibHJpZ2h0JywgJ3F1b3RlbGVmdCcsICdxdW90ZXJpZ2h0JywgJ2RpdmlkZScsICdsb3plbmdlJywgJ3lkaWVyZXNpcycsICdZZGllcmVzaXMnLCAnZnJhY3Rpb24nLFxuICAgICdjdXJyZW5jeScsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdxdW90ZXNpbmdsYmFzZScsXG4gICAgJ3F1b3RlZGJsYmFzZScsICdwZXJ0aG91c2FuZCcsICdBY2lyY3VtZmxleCcsICdFY2lyY3VtZmxleCcsICdBYWN1dGUnLCAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLFxuICAgICdJY2lyY3VtZmxleCcsICdJZGllcmVzaXMnLCAnSWdyYXZlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsICdhcHBsZScsICdPZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjdW1mbGV4JyxcbiAgICAnVWdyYXZlJywgJ2RvdGxlc3NpJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLCAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdyaW5nJywgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JyxcbiAgICAnb2dvbmVrJywgJ2Nhcm9uJywgJ0xzbGFzaCcsICdsc2xhc2gnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdaY2Fyb24nLCAnemNhcm9uJywgJ2Jyb2tlbmJhcicsICdFdGgnLCAnZXRoJyxcbiAgICAnWWFjdXRlJywgJ3lhY3V0ZScsICdUaG9ybicsICd0aG9ybicsICdtaW51cycsICdtdWx0aXBseScsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJyxcbiAgICAnb25laGFsZicsICdvbmVxdWFydGVyJywgJ3RocmVlcXVhcnRlcnMnLCAnZnJhbmMnLCAnR2JyZXZlJywgJ2dicmV2ZScsICdJZG90YWNjZW50JywgJ1NjZWRpbGxhJywgJ3NjZWRpbGxhJyxcbiAgICAnQ2FjdXRlJywgJ2NhY3V0ZScsICdDY2Fyb24nLCAnY2Nhcm9uJywgJ2Rjcm9hdCddO1xuXG4vLyBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbi8vIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4vLyBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG5mdW5jdGlvbiBEZWZhdWx0RW5jb2RpbmcoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG59XG5cbkRlZmF1bHRFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgdmFyIGNvZGUsIGdseXBocywgaSwgZ2x5cGgsIGo7XG4gICAgY29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGgudW5pY29kZXNbal0gPT09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gQ21hcEVuY29kaW5nKGNtYXApIHtcbiAgICB0aGlzLmNtYXAgPSBjbWFwO1xufVxuXG5DbWFwRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiB0aGlzLmNtYXAuZ2x5cGhJbmRleE1hcFtjLmNoYXJDb2RlQXQoMCldIHx8IDA7XG59O1xuXG5mdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xufVxuXG5DZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGNvZGUsIGNoYXJOYW1lO1xuICAgIGNvZGUgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuICAgIHJldHVybiB0aGlzLmNoYXJzZXQuaW5kZXhPZihjaGFyTmFtZSk7XG59O1xuXG5mdW5jdGlvbiBHbHlwaE5hbWVzKHBvc3QpIHtcbiAgICB2YXIgaTtcbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5uYW1lcyA9IGV4cG9ydHMuc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwb3N0LmdseXBoTmFtZUluZGV4W2ldIDwgZXhwb3J0cy5zdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBleHBvcnRzLnN0YW5kYXJkTmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBwb3N0Lm5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gLSBleHBvcnRzLnN0YW5kYXJkTmFtZXMubGVuZ3RoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDIuNTpcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5uYW1lc1tpXSA9IGV4cG9ydHMuc3RhbmRhcmROYW1lc1tpICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuR2x5cGhOYW1lcy5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKTtcbn07XG5cbkdseXBoTmFtZXMucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbiAoZ2lkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNbZ2lkXTtcbn07XG5cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCkge1xuICAgIHZhciBnbHlwaEluZGV4TWFwLCBjaGFyQ29kZXMsIGksIGMsIGdseXBoSW5kZXgsIGdseXBoO1xuICAgIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgZ2x5cGguYWRkVW5pY29kZShwYXJzZUludChjKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZm9udC5jZmZFbmNvZGluZykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuY2ZmRW5jb2RpbmcuY2hhcnNldFtpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLm5hbWUgPSBmb250LmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5jZmZTdGFuZGFyZFN0cmluZ3MgPSBjZmZTdGFuZGFyZFN0cmluZ3M7XG5leHBvcnRzLmNmZlN0YW5kYXJkRW5jb2RpbmcgPSBjZmZTdGFuZGFyZEVuY29kaW5nO1xuZXhwb3J0cy5jZmZFeHBlcnRFbmNvZGluZyA9IGNmZkV4cGVydEVuY29kaW5nO1xuZXhwb3J0cy5zdGFuZGFyZE5hbWVzID0gc3RhbmRhcmROYW1lcztcbmV4cG9ydHMuRGVmYXVsdEVuY29kaW5nID0gRGVmYXVsdEVuY29kaW5nO1xuZXhwb3J0cy5DbWFwRW5jb2RpbmcgPSBDbWFwRW5jb2Rpbmc7XG5leHBvcnRzLkNmZkVuY29kaW5nID0gQ2ZmRW5jb2Rpbmc7XG5leHBvcnRzLkdseXBoTmFtZXMgPSBHbHlwaE5hbWVzO1xuZXhwb3J0cy5hZGRHbHlwaE5hbWVzID0gYWRkR2x5cGhOYW1lcztcblxufSx7fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgRm9udCBvYmplY3RcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IF9kZXJlcV8oJy4vcGF0aCcpO1xudmFyIHNmbnQgPSBfZGVyZXFfKCcuL3RhYmxlcy9zZm50Jyk7XG52YXIgZW5jb2RpbmcgPSBfZGVyZXFfKCcuL2VuY29kaW5nJyk7XG5cbi8vIEEgRm9udCByZXByZXNlbnRzIGEgbG9hZGVkIE9wZW5UeXBlIGZvbnQgZmlsZS5cbi8vIEl0IGNvbnRhaW5zIGEgc2V0IG9mIGdseXBocyBhbmQgbWV0aG9kcyB0byBkcmF3IHRleHQgb24gYSBkcmF3aW5nIGNvbnRleHQsXG4vLyBvciB0byBnZXQgYSBwYXRoIHJlcHJlc2VudGluZyB0aGUgdGV4dC5cbmZ1bmN0aW9uIEZvbnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuICAgIHRoaXMuZmFtaWx5TmFtZSA9IG9wdGlvbnMuZmFtaWx5TmFtZSB8fCAnICc7XG4gICAgdGhpcy5zdHlsZU5hbWUgPSBvcHRpb25zLnN0eWxlTmFtZSB8fCAnICc7XG4gICAgdGhpcy5kZXNpZ25lciA9IG9wdGlvbnMuZGVzaWduZXIgfHwgJyAnO1xuICAgIHRoaXMuZGVzaWduZXJVUkwgPSBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJztcbiAgICB0aGlzLm1hbnVmYWN0dXJlciA9IG9wdGlvbnMubWFudWZhY3R1cmVyIHx8ICcgJztcbiAgICB0aGlzLm1hbnVmYWN0dXJlclVSTCA9IG9wdGlvbnMubWFudWZhY3R1cmVyVVJMIHx8ICcgJztcbiAgICB0aGlzLmxpY2Vuc2UgPSBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnO1xuICAgIHRoaXMubGljZW5zZVVSTCA9IG9wdGlvbnMubGljZW5zZVVSTCB8fCAnICc7XG4gICAgdGhpcy52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uIHx8ICdWZXJzaW9uIDAuMSc7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnO1xuICAgIHRoaXMuY29weXJpZ2h0ID0gb3B0aW9ucy5jb3B5cmlnaHQgfHwgJyAnO1xuICAgIHRoaXMudHJhZGVtYXJrID0gb3B0aW9ucy50cmFkZW1hcmsgfHwgJyAnO1xuICAgIHRoaXMudW5pdHNQZXJFbSA9IG9wdGlvbnMudW5pdHNQZXJFbSB8fCAxMDAwO1xuICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgIHRoaXMuZGVzY2VuZGVyID0gb3B0aW9ucy5kZXNjZW5kZXI7XG4gICAgdGhpcy5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuZ2x5cGhzID0gb3B0aW9ucy5nbHlwaHMgfHwgW107XG4gICAgdGhpcy5lbmNvZGluZyA9IG5ldyBlbmNvZGluZy5EZWZhdWx0RW5jb2RpbmcodGhpcyk7XG4gICAgdGhpcy50YWJsZXMgPSB7fTtcbn1cblxuLy8gQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIGdseXBoIGluZGV4LlxuLy8gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbi8vIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xufTtcblxuLy8gQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIEdseXBoIG9iamVjdC5cbi8vIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4vLyB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbiAoYykge1xuICAgIHZhciBnbHlwaEluZGV4LCBnbHlwaDtcbiAgICBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgIGdseXBoID0gdGhpcy5nbHlwaHNbZ2x5cGhJbmRleF07XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdOyAvLyAubm90ZGVmXG4gICAgfVxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdpdmVuIHRleHQgdG8gYSBsaXN0IG9mIEdseXBoIG9iamVjdHMuXG4vLyBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gc3RyaWN0IG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuIGNoYXJhY3RlcnMgYW5kXG4vLyBnbHlwaHMsIHNvIHRoZSBsaXN0IG9mIHJldHVybmVkIGdseXBocyBjYW4gYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiB0aGVcbi8vIGxlbmd0aCBvZiB0aGUgZ2l2ZW4gc3RyaW5nLlxuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBpLCBjLCBnbHlwaHM7XG4gICAgZ2x5cGhzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYyA9IHNbaV07XG4gICAgICAgIGdseXBocy5wdXNoKHRoaXMuY2hhclRvR2x5cGgoYykpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xufTtcblxuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBnbHlwaEluZGV4LCBnbHlwaDtcbiAgICBnbHlwaEluZGV4ID0gdGhpcy5uYW1ldG9HbHlwaEluZGV4KG5hbWUpO1xuICAgIGdseXBoID0gdGhpcy5nbHlwaHNbZ2x5cGhJbmRleF07XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzWzBdOyAvLyAubm90ZGVmXG4gICAgfVxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbkZvbnQucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbiAoZ2lkKSB7XG4gICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShnaWQpO1xufTtcblxuLy8gUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuLy8gYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cbi8vIFRoZSBrZXJuaW5nIHZhbHVlIGdldHMgYWRkZWQgdG8gdGhlIGFkdmFuY2Ugd2lkdGggd2hlbiBjYWxjdWxhdGluZyB0aGUgc3BhY2luZ1xuLy8gYmV0d2VlbiBnbHlwaHMuXG5Gb250LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbiAobGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIHZhciBncG9zS2VybmluZyA9IHRoaXMuZ2V0R3Bvc0tlcm5pbmdWYWx1ZTtcbiAgICByZXR1cm4gZ3Bvc0tlcm5pbmcgPyBncG9zS2VybmluZyhsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIDpcbiAgICAgICAgKHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDApO1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG4vLyBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLlxuRm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXJuaW5nLCBmb250U2NhbGUsIGdseXBocywgaSwgZ2x5cGgsIGtlcm5pbmdWYWx1ZTtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGtlcm5pbmcgPSBvcHRpb25zLmtlcm5pbmcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmtlcm5pbmc7XG4gICAgZm9udFNjYWxlID0gMSAvIHRoaXMudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGdseXBocyA9IHRoaXMuc3RyaW5nVG9HbHlwaHModGV4dCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZ2x5cGgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGdseXBoLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICAgICAgeCArPSBnbHlwaC5hZHZhbmNlV2lkdGggKiBmb250U2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBrZXJuaW5nVmFsdWUgPSB0aGlzLmdldEtlcm5pbmdWYWx1ZShnbHlwaCwgZ2x5cGhzW2kgKyAxXSk7XG4gICAgICAgICAgICB4ICs9IGtlcm5pbmdWYWx1ZSAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIENyZWF0ZSBhIFBhdGggb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2l2ZW4gdGV4dC5cbi8vXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbi8vXG4vLyBSZXR1cm5zIGEgUGF0aCBvYmplY3QuXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGZ1bGxQYXRoID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbiAoZ2x5cGgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ2x5cGguZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSk7XG4gICAgICAgIGZ1bGxQYXRoLmV4dGVuZChwYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vLyBEcmF3IHRoZSB0ZXh0IG9uIHRoZSBnaXZlbiBkcmF3aW5nIGNvbnRleHQuXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcbn07XG5cbi8vIERyYXcgdGhlIHBvaW50cyBvZiBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuLy8gT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbi8vXG4vLyBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4vLyB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuLy8geCAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8gZm9udFNpemUgLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLiAoZGVmYXVsdDogNzIpXG4vLyBPcHRpb25zIGlzIGFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNvbnRhaW5zOlxuLy8gLSBrZXJuaW5nIC0gV2hldGhlciB0byB0YWtlIGtlcm5pbmcgaW5mb3JtYXRpb24gaW50byBhY2NvdW50LiAoZGVmYXVsdDogdHJ1ZSlcbkZvbnQucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbiAoY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbiAoZ2x5cGgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdQb2ludHMoY3R4LCB4LCB5LCBmb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vLyBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuLy8gQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4vLyBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4vLyBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4vL1xuLy8gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuLy8gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC4gKGRlZmF1bHQ6IDcyKVxuLy8gT3B0aW9ucyBpcyBhbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjb250YWluczpcbi8vIC0ga2VybmluZyAtIFdoZXRoZXIgdG8gdGFrZSBrZXJuaW5nIGluZm9ybWF0aW9uIGludG8gYWNjb3VudC4gKGRlZmF1bHQ6IHRydWUpXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uIChjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uIChnbHlwaCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd01ldHJpY3MoY3R4LCB4LCB5LCBmb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vLyBWYWxpZGF0ZVxuRm9udC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIGZvbnQgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFN0cmluZ0F0dHJpYnV0ZShhdHRyTmFtZSkge1xuICAgICAgICBhc3NlcnQoZm9udFthdHRyTmFtZV0gJiYgZm9udFthdHRyTmFtZV0udHJpbSgpLmxlbmd0aCA+IDAsICdObyAnICsgYXR0ck5hbWUgKyAnIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnZmFtaWx5TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydFN0cmluZ0F0dHJpYnV0ZSgnbWFudWZhY3R1cmVyJyk7XG4gICAgYXNzZXJ0U3RyaW5nQXR0cmlidXRlKCdjb3B5cmlnaHQnKTtcbiAgICBhc3NlcnRTdHJpbmdBdHRyaWJ1dGUoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwLCAnTm8gdW5pdHNQZXJFbSBzcGVjaWZpZWQuJyk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG4vLyBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZm50LmZvbnRUb1RhYmxlKHRoaXMpO1xufTtcblxuRm9udC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNmbnRUYWJsZSA9IHRoaXMudG9UYWJsZXMoKTtcbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnRBcnJheVtpXSA9IGJ5dGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbkZvbnQucHJvdG90eXBlLmRvd25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuZmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgdGhpcy5zdHlsZU5hbWUgKyAnLm90Zic7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoKTtcblxuICAgIHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSA9IHdpbmRvdy5yZXF1ZXN0RmlsZVN5c3RlbSB8fCB3aW5kb3cud2Via2l0UmVxdWVzdEZpbGVTeXN0ZW07XG4gICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKHdpbmRvdy5URU1QT1JBUlksIGJ1ZmZlci5ieXRlTGVuZ3RoLCBmdW5jdGlvbiAoZnMpIHtcbiAgICAgICAgZnMucm9vdC5nZXRGaWxlKGZpbGVOYW1lLCB7Y3JlYXRlOiB0cnVlfSwgZnVuY3Rpb24gKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgZmlsZUVudHJ5LmNyZWF0ZVdyaXRlcihmdW5jdGlvbiAod3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YVZpZXddLCB7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlKGJsb2IpO1xuXG4gICAgICAgICAgICAgICAgIHdyaXRlci5hZGRFdmVudExpc3RlbmVyKCd3cml0ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGluZyB0byB0aGUgZmlsZSB3aWxsIGRvd25sb2FkIGl0LlxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn07XG5cbmV4cG9ydHMuRm9udCA9IEZvbnQ7XG5cbn0se1wiLi9lbmNvZGluZ1wiOjMsXCIuL3BhdGhcIjo4LFwiLi90YWJsZXMvc2ZudFwiOjIzfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgR2x5cGggb2JqZWN0XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gX2RlcmVxXygnLi9jaGVjaycpO1xudmFyIGRyYXcgPSBfZGVyZXFfKCcuL2RyYXcnKTtcbnZhciBwYXRoID0gX2RlcmVxXygnLi9wYXRoJyk7XG5cbi8vIEEgR2x5cGggaXMgYW4gaW5kaXZpZHVhbCBtYXJrIHRoYXQgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjaGFyYWN0ZXIuXG4vLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cbi8vIEdseXBocyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIGZvbnQuXG4vL1xuLy8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuZnVuY3Rpb24gR2x5cGgob3B0aW9ucykge1xuICAgIHRoaXMuZm9udCA9IG9wdGlvbnMuZm9udCB8fCBudWxsO1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID0gb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZCA/IFtvcHRpb25zLnVuaWNvZGVdIDogW107XG4gICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluIHx8IDA7XG4gICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluIHx8IDA7XG4gICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4IHx8IDA7XG4gICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4IHx8IDA7XG4gICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aCB8fCAwO1xuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCBudWxsO1xufVxuXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uICh1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuICAgIHRoaXMudW5pY29kZXMucHVzaCh1bmljb2RlKTtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGdseXBoIHRvIGEgUGF0aCB3ZSBjYW4gZHJhdyBvbiBhIGRyYXdpbmcgY29udGV4dC5cbi8vXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICh4LCB5LCBmb250U2l6ZSkge1xuICAgIHZhciBzY2FsZSwgcCwgY29tbWFuZHMsIGNtZDtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBwID0gbmV3IHBhdGguUGF0aCgpO1xuICAgIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyh4ICsgKGNtZC54ICogc2NhbGUpLCB5ICsgKC1jbWQueSAqIHNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgcC5saW5lVG8oeCArIChjbWQueCAqIHNjYWxlKSwgeSArICgtY21kLnkgKiBzY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHNjYWxlKSwgeSArICgtY21kLnkxICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBwLmN1cnZlVG8oeCArIChjbWQueDEgKiBzY2FsZSksIHkgKyAoLWNtZC55MSAqIHNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54MiAqIHNjYWxlKSwgeSArICgtY21kLnkyICogc2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLnggKiBzY2FsZSksIHkgKyAoLWNtZC55ICogc2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xufTtcblxuLy8gU3BsaXQgdGhlIGdseXBoIGludG8gY29udG91cnMuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBhbmQgdG9cbi8vIHByb3ZpZGUgcmF3IGFjY2VzcyB0byB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZXMuXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRvdXJzLCBjdXJyZW50Q29udG91ciwgaSwgcHQ7XG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHB0ID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2suYXJndW1lbnQoY3VycmVudENvbnRvdXIubGVuZ3RoID09PSAwLCAnVGhlcmUgYXJlIHN0aWxsIHBvaW50cyBsZWZ0IGluIHRoZSBjdXJyZW50IGNvbnRvdXIuJyk7XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xufTtcblxuLy8gQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG5HbHlwaC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgdmFyIHhDb29yZHMgPSBbXTtcbiAgICB2YXIgeUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgIT09ICdaJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54KTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54Mik7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWV0cmljcyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIGxlZnRTaWRlQmVhcmluZzogMFxuICAgIH07XG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLy8gRHJhdyB0aGUgZ2x5cGggb24gdGhlIGdpdmVuIGNvbnRleHQuXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCwgeCwgeSwgZm9udFNpemUpIHtcbiAgICB0aGlzLmdldFBhdGgoeCwgeSwgZm9udFNpemUpLmRyYXcoY3R4KTtcbn07XG5cbi8vIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG4vLyBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuLy9cbi8vIGN0eCAtIFRoZSBkcmF3aW5nIGNvbnRleHQuXG4vLyB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgZ2x5cGguIChkZWZhdWx0OiAwKVxuLy8geSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyBmb250U2l6ZSAtIEZvbnQgc2l6ZSwgaW4gcGl4ZWxzIChkZWZhdWx0OiA3MikuXG5HbHlwaC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIGZvbnRTaXplKSB7XG5cbiAgICBmdW5jdGlvbiBkcmF3Q2lyY2xlcyhsLCB4LCB5LCBzY2FsZSkge1xuICAgICAgICB2YXIgaiwgUElfU1EgPSBNYXRoLlBJICogMjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSksIDIsIDAsIFBJX1NRLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSwgaSwgYmx1ZUNpcmNsZXMsIHJlZENpcmNsZXMsIHBhdGgsIGNtZDtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgIGJsdWVDaXJjbGVzID0gW107XG4gICAgcmVkQ2lyY2xlcyA9IFtdO1xuICAgIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsdWVDaXJjbGVzLnB1c2goe3g6IGNtZC54LCB5OiAtY21kLnl9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNtZC54MiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWRDaXJjbGVzLnB1c2goe3g6IGNtZC54MiwgeTogLWNtZC55Mn0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdibHVlJztcbiAgICBkcmF3Q2lyY2xlcyhibHVlQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICBkcmF3Q2lyY2xlcyhyZWRDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG59O1xuXG4vLyBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzLlxuLy8gQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4vLyBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4vLyBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4vL1xuLy8gY3R4IC0gVGhlIGRyYXdpbmcgY29udGV4dC5cbi8vIHggLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBnbHlwaC4gKGRlZmF1bHQ6IDApXG4vLyB5IC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIGdseXBoLiAoZGVmYXVsdDogMClcbi8vIGZvbnRTaXplIC0gRm9udCBzaXplLCBpbiBwaXhlbHMgKGRlZmF1bHQ6IDcyKS5cbkdseXBoLnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uIChjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG4gICAgLy8gRHJhdyB0aGUgZ2x5cGggYm94XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAodGhpcy54TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAodGhpcy54TWluICogc2NhbGUpLCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh0aGlzLnhNYXggKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLnhNYXggKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXRoaXMueU1pbiAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXRoaXMueU1pbiAqIHNjYWxlKSk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5ICsgKC10aGlzLnlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC10aGlzLnlNYXggKiBzY2FsZSkpO1xuICAgIC8vIERyYXcgdGhlIGFkdmFuY2Ugd2lkdGhcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAodGhpcy5hZHZhbmNlV2lkdGggKiBzY2FsZSksIC0xMDAwMCwgeCArICh0aGlzLmFkdmFuY2VXaWR0aCAqIHNjYWxlKSwgMTAwMDApO1xufTtcblxuZXhwb3J0cy5HbHlwaCA9IEdseXBoO1xuXG59LHtcIi4vY2hlY2tcIjoxLFwiLi9kcmF3XCI6MixcIi4vcGF0aFwiOjh9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIG9wZW50eXBlLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWJveC9vcGVudHlwZS5qc1xuLy8gKGMpIDIwMTQgRnJlZGVyaWsgRGUgQmxlc2VyXG4vLyBvcGVudHlwZS5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuLyogZ2xvYmFsIEFycmF5QnVmZmVyLCBEYXRhVmlldywgVWludDhBcnJheSwgWE1MSHR0cFJlcXVlc3QgICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVuY29kaW5nID0gX2RlcmVxXygnLi9lbmNvZGluZycpO1xudmFyIF9mb250ID0gX2RlcmVxXygnLi9mb250Jyk7XG52YXIgZ2x5cGggPSBfZGVyZXFfKCcuL2dseXBoJyk7XG52YXIgcGFyc2UgPSBfZGVyZXFfKCcuL3BhcnNlJyk7XG52YXIgcGF0aCA9IF9kZXJlcV8oJy4vcGF0aCcpO1xuXG52YXIgY21hcCA9IF9kZXJlcV8oJy4vdGFibGVzL2NtYXAnKTtcbnZhciBjZmYgPSBfZGVyZXFfKCcuL3RhYmxlcy9jZmYnKTtcbnZhciBnbHlmID0gX2RlcmVxXygnLi90YWJsZXMvZ2x5ZicpO1xudmFyIGdwb3MgPSBfZGVyZXFfKCcuL3RhYmxlcy9ncG9zJyk7XG52YXIgaGVhZCA9IF9kZXJlcV8oJy4vdGFibGVzL2hlYWQnKTtcbnZhciBoaGVhID0gX2RlcmVxXygnLi90YWJsZXMvaGhlYScpO1xudmFyIGhtdHggPSBfZGVyZXFfKCcuL3RhYmxlcy9obXR4Jyk7XG52YXIga2VybiA9IF9kZXJlcV8oJy4vdGFibGVzL2tlcm4nKTtcbnZhciBsb2NhID0gX2RlcmVxXygnLi90YWJsZXMvbG9jYScpO1xudmFyIG1heHAgPSBfZGVyZXFfKCcuL3RhYmxlcy9tYXhwJyk7XG52YXIgX25hbWUgPSBfZGVyZXFfKCcuL3RhYmxlcy9uYW1lJyk7XG52YXIgb3MyID0gX2RlcmVxXygnLi90YWJsZXMvb3MyJyk7XG52YXIgcG9zdCA9IF9kZXJlcV8oJy4vdGFibGVzL3Bvc3QnKTtcblxuLy8gRmlsZSBsb2FkZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGEgTm9kZS5qcyBCdWZmZXIgdG8gYW4gQXJyYXlCdWZmZXJcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpLFxuICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRhW2ldID0gYnVmZmVyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZzID0gX2RlcmVxXygnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbiAoZXJyLCBidWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZDogJyArIHJlcXVlc3Quc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKCk7XG59XG5cbi8vIFB1YmxpYyBBUEkgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbi8vIElmIHRoZSBmaWxlIGNvdWxkIG5vdCBiZSBwYXJzZWQgKG1vc3QgbGlrZWx5IGJlY2F1c2UgaXQgY29udGFpbnMgUG9zdHNjcmlwdCBvdXRsaW5lcylcbi8vIHdlIHJldHVybiBhbiBlbXB0eSBGb250IG9iamVjdCB3aXRoIHRoZSBgc3VwcG9ydGVkYCBmbGFnIHNldCB0byBgZmFsc2VgLlxuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGZvbnQsIGRhdGEsIHZlcnNpb24sIG51bVRhYmxlcywgaSwgcCwgdGFnLCBvZmZzZXQsIGhtdHhPZmZzZXQsIGdseWZPZmZzZXQsIGxvY2FPZmZzZXQsXG4gICAgICAgIGNmZk9mZnNldCwga2Vybk9mZnNldCwgZ3Bvc09mZnNldCwgaW5kZXhUb0xvY0Zvcm1hdCwgbnVtR2x5cGhzLCBsb2NhVGFibGUsXG4gICAgICAgIHNob3J0VmVyc2lvbjtcbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cblxuICAgIGZvbnQgPSBuZXcgX2ZvbnQuRm9udCgpO1xuICAgIGRhdGEgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCAwKTtcblxuICAgIHZlcnNpb24gPSBwYXJzZS5nZXRGaXhlZChkYXRhLCAwKTtcbiAgICBpZiAodmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZlcnNpb24gPSBwYXJzZS5nZXRUYWcoZGF0YSwgMCk7XG4gICAgICAgIGlmICh2ZXJzaW9uID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgdmVyc2lvbiAnICsgdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG5cbiAgICAvLyBPZmZzZXQgaW50byB0aGUgdGFibGUgcmVjb3Jkcy5cbiAgICBwID0gMTI7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdjbWFwJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgIGlmICghZm9udC5lbmNvZGluZykge1xuICAgICAgICAgICAgICAgIGZvbnQuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5oZWFkID0gaGVhZC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC51bml0c1BlckVtID0gZm9udC50YWJsZXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoaGVhJzpcbiAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBmb250LmFzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5hc2NlbmRlcjtcbiAgICAgICAgICAgIGZvbnQuZGVzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXI7XG4gICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaG10eCc6XG4gICAgICAgICAgICBobXR4T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21heHAnOlxuICAgICAgICAgICAgZm9udC50YWJsZXMubWF4cCA9IG1heHAucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gbnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5uYW1lID0gX25hbWUucGFyc2UoZGF0YSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGZvbnQuZmFtaWx5TmFtZSA9IGZvbnQudGFibGVzLm5hbWUuZm9udEZhbWlseTtcbiAgICAgICAgICAgIGZvbnQuc3R5bGVOYW1lID0gZm9udC50YWJsZXMubmFtZS5mb250U3ViZmFtaWx5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09TLzInOlxuICAgICAgICAgICAgZm9udC50YWJsZXMub3MyID0gb3MyLnBhcnNlKGRhdGEsIG9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICBmb250LnRhYmxlcy5wb3N0ID0gcG9zdC5wYXJzZShkYXRhLCBvZmZzZXQpO1xuICAgICAgICAgICAgZm9udC5nbHlwaE5hbWVzID0gbmV3IGVuY29kaW5nLkdseXBoTmFtZXMoZm9udC50YWJsZXMucG9zdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZ2x5Zic6XG4gICAgICAgICAgICBnbHlmT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xvY2EnOlxuICAgICAgICAgICAgbG9jYU9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgIGNmZk9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdrZXJuJzpcbiAgICAgICAgICAgIGtlcm5PZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnR1BPUyc6XG4gICAgICAgICAgICBncG9zT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcCArPSAxNjtcbiAgICB9XG5cbiAgICBpZiAoZ2x5Zk9mZnNldCAmJiBsb2NhT2Zmc2V0KSB7XG4gICAgICAgIHNob3J0VmVyc2lvbiA9IGluZGV4VG9Mb2NGb3JtYXQgPT09IDA7XG4gICAgICAgIGxvY2FUYWJsZSA9IGxvY2EucGFyc2UoZGF0YSwgbG9jYU9mZnNldCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuICAgICAgICBmb250LmdseXBocyA9IGdseWYucGFyc2UoZGF0YSwgZ2x5Zk9mZnNldCwgbG9jYVRhYmxlLCBmb250KTtcbiAgICAgICAgaG10eC5wYXJzZShkYXRhLCBobXR4T2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocyk7XG4gICAgICAgIGVuY29kaW5nLmFkZEdseXBoTmFtZXMoZm9udCk7XG4gICAgfSBlbHNlIGlmIChjZmZPZmZzZXQpIHtcbiAgICAgICAgY2ZmLnBhcnNlKGRhdGEsIGNmZk9mZnNldCwgZm9udCk7XG4gICAgICAgIGVuY29kaW5nLmFkZEdseXBoTmFtZXMoZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZm9udC5zdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKGtlcm5PZmZzZXQpIHtcbiAgICAgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShkYXRhLCBrZXJuT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdwb3NPZmZzZXQpIHtcbiAgICAgICAgICAgIGdwb3MucGFyc2UoZGF0YSwgZ3Bvc09mZnNldCwgZm9udCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm9udDtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGEgZmlsZXN5c3RlbS4gV2hlbiBkb25lLCBjYWxsIHRoZSBjYWxsYmFja1xuLy8gd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBmb250KWAuIFRoZSBgZXJyYCB3aWxsIGJlIG51bGwgb24gc3VjY2Vzcyxcbi8vIHRoZSBgZm9udGAgaXMgYSBGb250IG9iamVjdC5cbi8vXG4vLyBXZSB1c2UgdGhlIG5vZGUuanMgY2FsbGJhY2sgY29udmVudGlvbiBzbyB0aGF0XG4vLyBvcGVudHlwZS5qcyBjYW4gaW50ZWdyYXRlIHdpdGggZnJhbWV3b3JrcyBsaWtlIGFzeW5jLmpzLlxuZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBsb2FkRm4gPSBpc05vZGUgPyBsb2FkRnJvbUZpbGUgOiBsb2FkRnJvbVVybDtcbiAgICBsb2FkRm4odXJsLCBmdW5jdGlvbiAoZXJyLCBhcnJheUJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udCA9IHBhcnNlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICAgICAgaWYgKCFmb250LnN1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGlzIG5vdCBzdXBwb3J0ZWQgKGlzIHRoaXMgYSBQb3N0c2NyaXB0IGZvbnQ/KScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmb250KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5Gb250ID0gX2ZvbnQuRm9udDtcbmV4cG9ydHMuR2x5cGggPSBnbHlwaC5HbHlwaDtcbmV4cG9ydHMuUGF0aCA9IHBhdGguUGF0aDtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZUJ1ZmZlcjtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5cbn0se1wiLi9lbmNvZGluZ1wiOjMsXCIuL2ZvbnRcIjo0LFwiLi9nbHlwaFwiOjUsXCIuL3BhcnNlXCI6NyxcIi4vcGF0aFwiOjgsXCIuL3RhYmxlcy9jZmZcIjoxMCxcIi4vdGFibGVzL2NtYXBcIjoxMSxcIi4vdGFibGVzL2dseWZcIjoxMixcIi4vdGFibGVzL2dwb3NcIjoxMyxcIi4vdGFibGVzL2hlYWRcIjoxNCxcIi4vdGFibGVzL2hoZWFcIjoxNSxcIi4vdGFibGVzL2htdHhcIjoxNixcIi4vdGFibGVzL2tlcm5cIjoxNyxcIi4vdGFibGVzL2xvY2FcIjoxOCxcIi4vdGFibGVzL21heHBcIjoxOSxcIi4vdGFibGVzL25hbWVcIjoyMCxcIi4vdGFibGVzL29zMlwiOjIxLFwiLi90YWJsZXMvcG9zdFwiOjIyLFwiZnNcIjp1bmRlZmluZWR9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFBhcnNpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuZXhwb3J0cy5nZXRCeXRlID0gZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59O1xuXG5leHBvcnRzLmdldENhcmQ4ID0gZXhwb3J0cy5nZXRCeXRlO1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5leHBvcnRzLmdldFVTaG9ydCA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbn07XG5cbmV4cG9ydHMuZ2V0Q2FyZDE2ID0gZXhwb3J0cy5nZXRVU2hvcnQ7XG5cbi8vIFJldHJpZXZlIGEgc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0U2hvcnQgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbn07XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZXhwb3J0cy5nZXRVTG9uZyA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbn07XG5cbi8vIFJldHJpZXZlIGEgMzItYml0IHNpZ25lZCBmaXhlZC1wb2ludCBudW1iZXIgKDE2LjE2KSBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmV4cG9ydHMuZ2V0Rml4ZWQgPSBmdW5jdGlvbiAoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciBkZWNpbWFsLCBmcmFjdGlvbjtcbiAgICBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn07XG5cbi8vIFJldHJpZXZlIGEgNC1jaGFyYWN0ZXIgdGFnIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5leHBvcnRzLmdldFRhZyA9IGZ1bmN0aW9uIChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIHRhZyA9ICcnLCBpO1xuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIDQ7IGkgKz0gMSkge1xuICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRJbnQ4KGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbn07XG5cbi8vIFJldHJpZXZlIGFuIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIE9mZnNldHMgYXJlIDEgdG8gNCBieXRlcyBpbiBsZW5ndGgsIGRlcGVuZGluZyBvbiB0aGUgb2ZmU2l6ZSBhcmd1bWVudC5cbmV4cG9ydHMuZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICB2YXIgaSwgdjtcbiAgICB2ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIHYgPDw9IDg7XG4gICAgICAgIHYgKz0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuLy8gUmV0cmlldmUgYSBudW1iZXIgb2YgYnl0ZXMgZnJvbSBzdGFydCBvZmZzZXQgdG8gdGhlIGVuZCBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5leHBvcnRzLmdldEJ5dGVzID0gZnVuY3Rpb24gKGRhdGFWaWV3LCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgdmFyIGJ5dGVzLCBpO1xuICAgIGJ5dGVzID0gW107XG4gICAgZm9yIChpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufTtcblxuLy8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHZhciBzLCBpO1xuICAgIHMgPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59O1xuXG52YXIgdHlwZU9mZnNldHMgPSB7XG4gICAgYnl0ZTogMSxcbiAgICB1U2hvcnQ6IDIsXG4gICAgc2hvcnQ6IDIsXG4gICAgdUxvbmc6IDQsXG4gICAgZml4ZWQ6IDQsXG4gICAgbG9uZ0RhdGVUaW1lOiA4LFxuICAgIHRhZzogNFxufTtcblxuLy8gQSBzdGF0ZWZ1bCBwYXJzZXIgdGhhdCBjaGFuZ2VzIHRoZSBvZmZzZXQgd2hlbmV2ZXIgYSB2YWx1ZSBpcyByZXRyaWV2ZWQuXG4vLyBUaGUgZGF0YSBpcyBhIERhdGFWaWV3LlxuZnVuY3Rpb24gUGFyc2VyKGRhdGEsIG9mZnNldCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IDA7XG59XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkOCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUYyRG90MTQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IGV4cG9ydHMuZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdiA9IGV4cG9ydHMuZ2V0Rml4ZWQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNkxpc3QgPVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3QgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCksXG4gICAgICAgIGRhdGFWaWV3ID0gdGhpcy5kYXRhLFxuICAgICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBleHBvcnRzLmdldFVTaG9ydChkYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBvZmZzZXRzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGEsXG4gICAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCxcbiAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xufTtcblxuLy8gTE9OR0RBVEVUSU1FIGlzIGEgNjQtYml0IGludGVnZXIuXG4vLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2Vcbi8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZXhwb3J0cy5nZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2IC8gNjU1MzY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYWpvciA9IGV4cG9ydHMuZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICAvLyBIb3cgdG8gaW50ZXJwcmV0IHRoZSBtaW5vciB2ZXJzaW9uIGlzIHZlcnkgdmFndWUgaW4gdGhlIHNwZWMuIDB4NTAwMCBpcyA1LCAweDEwMDAgaXMgMVxuICAgIC8vIFRoaXMgcmV0dXJucyB0aGUgY29ycmVjdCBudW1iZXIgaWYgbWlub3IgPSAweE4wMDAgd2hlcmUgTiBpcyAwLTlcbiAgICB2YXIgbWlub3IgPSBleHBvcnRzLmdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gbWFqb3IgKyBtaW5vciAvIDB4MTAwMCAvIDEwO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKHR5cGUsIGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbW91bnQgPSAxO1xuICAgIH1cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xufTtcblxuZXhwb3J0cy5QYXJzZXIgPSBQYXJzZXI7XG5cbn0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gR2VvbWV0cmljIG9iamVjdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuLy8gUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTScsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cblBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0wnLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG5QYXRoLnByb3RvdHlwZS5xdWFkVG8gPSBQYXRoLnByb3RvdHlwZS5xdWFkcmF0aWNDdXJ2ZVRvID0gZnVuY3Rpb24gKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cblBhdGgucHJvdG90eXBlLmNsb3NlID0gUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJ1xuICAgIH0pO1xufTtcblxuLy8gQWRkIHRoZSBnaXZlbiBwYXRoIG9yIGxpc3Qgb2YgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9mIHRoaXMgcGF0aC5cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChwYXRoT3JDb21tYW5kcykge1xuICAgIGlmIChwYXRoT3JDb21tYW5kcy5jb21tYW5kcykge1xuICAgICAgICBwYXRoT3JDb21tYW5kcyA9IHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzO1xuICAgIH1cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBwYXRoT3JDb21tYW5kcyk7XG59O1xuXG4vLyBEcmF3IHRoZSBwYXRoIHRvIGEgMkQgY29udGV4dC5cblBhdGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIGksIGNtZDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBQYXRoIHRvIGEgc3RyaW5nIG9mIHBhdGggZGF0YSBpbnN0cnVjdGlvbnNcbi8vIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuLy8gUGFyYW1ldGVyczpcbi8vIC0gZGVjaW1hbFBsYWNlczogVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzIChkZWZhdWx0OiAyKVxuUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uIChkZWNpbWFsUGxhY2VzKSB7XG4gICAgZGVjaW1hbFBsYWNlcyA9IGRlY2ltYWxQbGFjZXMgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxQbGFjZXMgOiAyO1xuXG4gICAgZnVuY3Rpb24gZmxvYXRUb1N0cmluZyh2KSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHYpID09PSB2KSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBNYXRoLnJvdW5kKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9GaXhlZChkZWNpbWFsUGxhY2VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhY2tWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDAgJiYgaSA+IDApIHtcbiAgICAgICAgICAgICAgICBzICs9ICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgKz0gZmxvYXRUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGQgKz0gJ00nICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGQgKz0gJ0wnICsgcGFja1ZhbHVlcyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGQgKz0gJ0MnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgZCArPSAnUScgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnWicpIHtcbiAgICAgICAgICAgIGQgKz0gJ1onO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkO1xufTtcblxuLy8gQ29udmVydCB0aGUgcGF0aCB0byBhIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG4vLyBQYXJhbWV0ZXJzOlxuLy8gLSBkZWNpbWFsUGxhY2VzOiBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXMgKGRlZmF1bHQ6IDIpXG5QYXRoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uIChkZWNpbWFsUGxhY2VzKSB7XG4gICAgdmFyIHN2ZyA9ICc8cGF0aCBkPVwiJztcbiAgICBzdmcgKz0gdGhpcy50b1BhdGhEYXRhKGRlY2ltYWxQbGFjZXMpO1xuICAgIHN2ZyArPSAnXCInO1xuICAgIGlmICh0aGlzLmZpbGwgJiB0aGlzLmZpbGwgIT09ICdibGFjaycpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIm5vbmVcIic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwiJyArIHRoaXMuZmlsbCArICdcIic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgIHN2ZyArPSAnIHN0cm9rZT1cIicgKyB0aGlzLnN0cm9rZSArICdcIiBzdHJva2Utd2lkdGg9XCInICsgdGhpcy5zdHJva2VXaWR0aCArICdcIic7XG4gICAgfVxuICAgIHN2ZyArPSAnLz4nO1xuICAgIHJldHVybiBzdmc7XG59O1xuXG5leHBvcnRzLlBhdGggPSBQYXRoO1xuXG59LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRhYmxlIG1ldGFkYXRhXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gX2RlcmVxXygnLi9jaGVjaycpO1xudmFyIGVuY29kZSA9IF9kZXJlcV8oJy4vdHlwZXMnKS5lbmNvZGU7XG52YXIgc2l6ZU9mID0gX2RlcmVxXygnLi90eXBlcycpLnNpemVPZjtcblxuZnVuY3Rpb24gVGFibGUodGFibGVOYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgdGhpc1tmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2ldO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXNba10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmllbGRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemVPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdiArPSB2YWx1ZS5zaXplT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCh0eXBlb2Ygc2l6ZU9mRnVuY3Rpb24gPT09ICdmdW5jdGlvbicsICdDb3VsZCBub3QgZmluZCBzaXplT2YgZnVuY3Rpb24gZm9yIGZpZWxkJyArIGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgdiArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG59O1xuXG5UYWJsZS5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG5leHBvcnRzLlRhYmxlID0gVGFibGU7XG5cbn0se1wiLi9jaGVja1wiOjEsXCIuL3R5cGVzXCI6MjR9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IF9kZXJlcV8oJy4uL2VuY29kaW5nJyk7XG52YXIgX2dseXBoID0gX2RlcmVxXygnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IF9kZXJlcV8oJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IF9kZXJlcV8oJy4uL3BhdGgnKTtcbnZhciB0YWJsZSA9IF9kZXJlcV8oJy4uL3RhYmxlJyk7XG5cbi8vIEN1c3RvbSBlcXVhbHMgZnVuY3Rpb24gdGhhdCBjYW4gYWxzbyBjaGVjayBsaXN0cy5cbmZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cywgb2JqZWN0cywgY291bnQsIGVuZE9mZnNldCwgb2Zmc2V0U2l6ZSwgb2JqZWN0T2Zmc2V0LCBwb3MsIGksIHZhbHVlO1xuICAgIG9mZnNldHMgPSBbXTtcbiAgICBvYmplY3RzID0gW107XG4gICAgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIGlmIChjb3VudCAhPT0gMCkge1xuICAgICAgICBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvZmZzZXRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMsIGVvZiwgbG9va3VwLCBiLCBuMSwgbjI7XG4gICAgcyA9ICcnO1xuICAgIGVvZiA9IDE1O1xuICAgIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIG4xID0gYiA+PiA0O1xuICAgICAgICBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxLCBiMiwgYjMsIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbywga2V5LCB2YWx1ZXMsIGksIHZhbHVlO1xuICAgIG8gPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBrZXkgPSBlbnRyaWVzW2ldWzBdO1xuICAgICAgICB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICB2YXIgcGFyc2VyLCBlbnRyaWVzLCBvcGVyYW5kcywgb3A7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGVudHJpZXMgPSBbXTtcbiAgICBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudHJpZXMucHVzaChbb3AsIG9wZXJhbmRzXSk7XG4gICAgICAgICAgICBvcGVyYW5kcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG9wZXJhbmRzICh2YWx1ZXMpIGNvbWUgYmVmb3JlIHRoZSBvcGVyYXRvcnMgKGtleXMpLCB3ZSBzdG9yZSBhbGwgb3BlcmFuZHMgaW4gYSBsaXN0XG4gICAgICAgICAgICAvLyB1bnRpbCB3ZSBlbmNvdW50ZXIgYW4gb3BlcmF0b3IuXG4gICAgICAgICAgICBvcGVyYW5kcy5wdXNoKHBhcnNlT3BlcmFuZChwYXJzZXIsIG9wKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIG0sIHZhbHVlLCBuZXdEaWN0O1xuICAgIG5ld0RpY3QgPSB7fTtcbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gZGljdFttLm9wXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0udHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge25hbWU6ICdmb250TWF0cml4Jywgb3A6IDEyMDcsIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSwgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX1cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0O1xuICAgIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgcGFyc2VyLCBmb3JtYXQsIGNoYXJzZXQsIGksIHNpZCwgY291bnQ7XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICBmb3JtYXQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IGNvdW50OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICAgICAgICAgIHNpZCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNoYXJzZXQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFyc2V0O1xufVxuXG4vLyBQYXJzZSB0aGUgQ0ZGIGVuY29kaW5nIGRhdGEuIE9ubHkgb25lIGVuY29kaW5nIGNhbiBiZSBzcGVjaWZpZWQgcGVyIGZvbnQuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMiwgXCJFbmNvZGluZ3NcIi5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRW5jb2RpbmcoZGF0YSwgc3RhcnQsIGNoYXJzZXQpIHtcbiAgICB2YXIgZW5jLCBwYXJzZXIsIGZvcm1hdCwgbkNvZGVzLCBpLCBjb2RlLCBuUmFuZ2VzLCBmaXJzdCwgbkxlZnQsIGo7XG4gICAgZW5jID0ge307XG4gICAgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgblJhbmdlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhjb2RlLCBmb250LCBpbmRleCkge1xuICAgIHZhciBwLCBnbHlwaCwgc3RhY2ssIG5TdGVtcywgaGF2ZVdpZHRoLCB3aWR0aCwgeCwgeSwgYzF4LCBjMXksIGMyeCwgYzJ5LCB2O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgc3RhY2sgPSBbXTtcbiAgICBuU3RlbXMgPSAwO1xuICAgIGhhdmVXaWR0aCA9IGZhbHNlO1xuICAgIHdpZHRoID0gZm9udC5kZWZhdWx0V2lkdGhYO1xuICAgIHggPSB5ID0gMDtcblxuICAgIGZ1bmN0aW9uIHBhcnNlU3RlbXMoKSB7XG4gICAgICAgIHZhciBoYXNXaWR0aEFyZztcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgfVxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UoY29kZSkge1xuICAgICAgICB2YXIgaSwgYjEsIGIyLCBiMywgYjQsIGNvZGVJbmRleCwgc3VickNvZGU7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBoc3RlbVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzogLy8gdnN0ZW1cbiAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIHZtb3ZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIGZvbnQubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBzdGFjay5wb3AoKSArIGZvbnQuc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5zdWJyc1tjb2RlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAxMjogLy8gZXNjYXBlXG4gICAgICAgICAgICAgICAgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICBjYXNlIDIwOiAvLyBjbnRybWFza1xuICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgZm9udC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIyOiAvLyBobW92ZXRvXG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBmb250Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY6IC8vIHZ2Y3VydmV0b1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI3OiAvLyBoaGN1cnZldG9cbiAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyODogLy8gc2hvcnRpbnRcbiAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSkgPj4gMTYpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjk6IC8vIGNhbGxnc3ViclxuICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoc3VickNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzA6IC8vIHZoY3VydmV0b1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAodiA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh2IC0gMTM5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYjMgPSBjb2RlW2kgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKCgoYjEgPDwgMjQpIHwgKGIyIDw8IDE2KSB8IChiMyA8PCA4KSB8IGI0KSAvIDY1NTM2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLnBhdGggPSBwO1xuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBnbHlwaDtcbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG4gICAgcmV0dXJuIGJpYXM7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIHZhciBoZWFkZXIsIG5hbWVJbmRleCwgdG9wRGljdEluZGV4LCBzdHJpbmdJbmRleCwgZ2xvYmFsU3VickluZGV4LCB0b3BEaWN0LCBwcml2YXRlRGljdE9mZnNldCwgcHJpdmF0ZURpY3QsXG4gICAgICAgIHN1YnJPZmZzZXQsIHN1YnJJbmRleCwgY2hhclN0cmluZywgY2hhclN0cmluZ3NJbmRleCwgY2hhcnNldCwgaTtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgbmFtZUluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBoZWFkZXIuZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICBnbG9iYWxTdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0cmluZ0luZGV4LmVuZE9mZnNldCk7XG4gICAgZm9udC5nc3VicnMgPSBnbG9iYWxTdWJySW5kZXgub2JqZWN0cztcbiAgICBmb250LmdzdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5nc3VicnMpO1xuXG4gICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KHRvcERpY3RJbmRleC5vYmplY3RzWzBdKS5idWZmZXIpO1xuICAgIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0Wydwcml2YXRlJ11bMV07XG4gICAgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVEaWN0T2Zmc2V0LCB0b3BEaWN0Wydwcml2YXRlJ11bMF0sIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgZm9udC5ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcblxuICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICBjaGFyU3RyaW5nc0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdGFydCArIHRvcERpY3QuY2hhclN0cmluZ3MpO1xuICAgIGZvbnQubkdseXBocyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0cy5sZW5ndGg7XG5cbiAgICBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7IC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgZW5jb2RpbmcuQ2ZmRW5jb2RpbmcoZW5jb2RpbmcuY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7IC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IGVuY29kaW5nLkNmZkVuY29kaW5nKGVuY29kaW5nLmNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cbiAgICAvLyBQcmVmZXIgdGhlIENNQVAgZW5jb2RpbmcgdG8gdGhlIENGRiBlbmNvZGluZy5cbiAgICBmb250LmVuY29kaW5nID0gZm9udC5lbmNvZGluZyB8fCBmb250LmNmZkVuY29kaW5nO1xuXG4gICAgZm9udC5nbHlwaHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgZm9udC5nbHlwaHMucHVzaChwYXJzZUNGRkNoYXJzdHJpbmcoY2hhclN0cmluZywgZm9udCwgaSkpO1xuICAgIH1cbn1cblxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIGksIHNpZDtcbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICBpID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGVuY29kaW5nLmNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gZW5jb2RpbmcuY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnTmFtZSBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0Lm5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5uYW1lcy5wdXNoKHtuYW1lOiAnbmFtZV8nICsgaSwgdHlwZTogJ05BTUUnLCB2YWx1ZTogZm9udE5hbWVzW2ldfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge30sIGksIGVudHJ5LCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhbHVlID0gYXR0cnNbZW50cnkubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTdHJpbmcodmFsdWUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIGRvbid0IHVzZSBzdWJyb3V0aW5lcy5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgdmFyIG9wcyA9IFtdLCBwYXRoID0gZ2x5cGgucGF0aCwgeCwgeSwgaSwgY21kLCBkeCwgZHksIGR4MSwgZHkxLCBkeDIsIGR5MjtcbiAgICBvcHMucHVzaCh7bmFtZTogJ3dpZHRoJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBnbHlwaC5hZHZhbmNlV2lkdGh9KTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gQ0ZGIG9ubHkgc3VwcG9ydHMgYsOpemllciBjdXJ2ZXMsIHNvIGNvbnZlcnQgdGhlIHF1YWQgdG8gYSBiw6l6aWVyLlxuICAgICAgICAgICAgdmFyIF8xMyA9IDEgLyAzO1xuICAgICAgICAgICAgdmFyIF8yMyA9IDIgLyAzO1xuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IGNvbW1hbmQgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBwYXRoLlxuICAgICAgICAgICAgY21kID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgICAgICAgICB4OiBjbWQueCxcbiAgICAgICAgICAgICAgICB5OiBjbWQueSxcbiAgICAgICAgICAgICAgICB4MTogXzEzICogeCArIF8yMyAqIGNtZC54MSxcbiAgICAgICAgICAgICAgICB5MTogXzEzICogeSArIF8yMyAqIGNtZC55MSxcbiAgICAgICAgICAgICAgICB4MjogXzEzICogY21kLnggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTI6IF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybW92ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDIxfSk7XG4gICAgICAgICAgICB4ID0gY21kLng7XG4gICAgICAgICAgICB5ID0gY21kLnk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZHggPSBjbWQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0geTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdybGluZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDV9KTtcbiAgICAgICAgICAgIHggPSBjbWQueDtcbiAgICAgICAgICAgIHkgPSBjbWQueTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkeDEgPSBjbWQueDEgLSB4O1xuICAgICAgICAgICAgZHkxID0gY21kLnkxIC0geTtcbiAgICAgICAgICAgIGR4MiA9IGNtZC54MiAtIGNtZC54MTtcbiAgICAgICAgICAgIGR5MiA9IGNtZC55MiAtIGNtZC55MTtcbiAgICAgICAgICAgIGR4ID0gY21kLnggLSBjbWQueDI7XG4gICAgICAgICAgICBkeSA9IGNtZC55IC0gY21kLnkyO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JyY3VydmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA4fSk7XG4gICAgICAgICAgICB4ID0gY21kLng7XG4gICAgICAgICAgICB5ID0gY21kLnk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgLy8gQ29udG91cnMgYXJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAgICB9XG4gICAgfVxuICAgIG9wcy5wdXNoKHtuYW1lOiAnZW5kY2hhcicsIHR5cGU6ICdPUCcsIHZhbHVlOiAxNH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdDaGFyU3RyaW5ncyBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHZhciBvcHMgPSBnbHlwaFRvT3BzKGdseXBoKTtcbiAgICAgICAgdC5jaGFyU3RyaW5ncy5wdXNoKHtuYW1lOiBnbHlwaC5uYW1lLCB0eXBlOiAnQ0hBUlNUUklORycsIHZhbHVlOiBvcHN9KTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdQcml2YXRlIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdEluZGV4KHByaXZhdGVEaWN0KSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ1ByaXZhdGUgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdHMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5wcml2YXRlRGljdHMgPSBbe25hbWU6ICdwcml2YXRlRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHByaXZhdGVEaWN0fV07XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ0ZGICcsIFtcbiAgICAgICAge25hbWU6ICdoZWFkZXInLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICduYW1lSW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICd0b3BEaWN0SW5kZXgnLCB0eXBlOiAnVEFCTEUnfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2dsb2JhbFN1YnJJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ2NoYXJzZXRzJywgdHlwZTogJ1RBQkxFJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3NJbmRleCcsIHR5cGU6ICdUQUJMRSd9LFxuICAgICAgICB7bmFtZTogJ3ByaXZhdGVEaWN0SW5kZXgnLCB0eXBlOiAnVEFCTEUnfVxuICAgIF0pO1xuXG4gICAgLy8gV2UgdXNlIG5vbi16ZXJvIHZhbHVlcyBmb3IgdGhlIG9mZnNldHMgc28gdGhhdCB0aGUgRElDVCBlbmNvZGVzIHRoZW0uXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgVG9wIERJQ1QgcGxheXMgYSByb2xlIGluIG9mZnNldCBjYWxjdWxhdGlvbixcbiAgICAvLyBhbmQgdGhlIHNpemUgc2hvdWxkbid0IGNoYW5nZSBhZnRlciB3ZSd2ZSB3cml0dGVuIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgZnVsbE5hbWU6IG9wdGlvbnMuZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG4gICAgICAgIGNoYXJzZXQ6IDk5OSxcbiAgICAgICAgZW5jb2Rpbmc6IDAsXG4gICAgICAgIGNoYXJTdHJpbmdzOiA5OTksXG4gICAgICAgIHByaXZhdGU6IFswLCA5OTldXG4gICAgfTtcblxuICAgIHZhciBwcml2YXRlQXR0cnMgPSB7fTtcblxuICAgIHZhciBnbHlwaE5hbWVzID0gW107XG4gICAgLy8gU2tpcCBmaXJzdCBnbHlwaCAoLm5vdGRlZilcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaE5hbWVzLnB1c2goZ2x5cGhzW2ldLm5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdzID0gW107XG5cbiAgICB0LmhlYWRlciA9IG1ha2VIZWFkZXIoKTtcbiAgICB0Lm5hbWVJbmRleCA9IG1ha2VOYW1lSW5kZXgoW29wdGlvbnMucG9zdFNjcmlwdE5hbWVdKTtcbiAgICB2YXIgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG4gICAgdC5nbG9iYWxTdWJySW5kZXggPSBtYWtlR2xvYmFsU3VickluZGV4KCk7XG4gICAgdC5jaGFyc2V0cyA9IG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKTtcbiAgICB0LmNoYXJTdHJpbmdzSW5kZXggPSBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpO1xuICAgIHZhciBwcml2YXRlRGljdCA9IG1ha2VQcml2YXRlRGljdChwcml2YXRlQXR0cnMsIHN0cmluZ3MpO1xuICAgIHQucHJpdmF0ZURpY3RJbmRleCA9IG1ha2VQcml2YXRlRGljdEluZGV4KHByaXZhdGVEaWN0KTtcblxuICAgIC8vIE5lZWRzIHRvIGNvbWUgYXQgdGhlIGVuZCwgdG8gZW5jb2RlIGFsbCBjdXN0b20gc3RyaW5ncyB1c2VkIGluIHRoZSBmb250LlxuICAgIHQuc3RyaW5nSW5kZXggPSBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncyk7XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0LmhlYWRlci5zaXplT2YoKSArXG4gICAgICAgIHQubmFtZUluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC50b3BEaWN0SW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnN0cmluZ0luZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5nbG9iYWxTdWJySW5kZXguc2l6ZU9mKCk7XG4gICAgYXR0cnMuY2hhcnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgIGF0dHJzLmVuY29kaW5nID0gMDsgLy8gV2UgdXNlIHRoZSBDRkYgc3RhbmRhcmQgZW5jb2Rpbmc7IHByb3BlciBlbmNvZGluZyB3aWxsIGJlIGhhbmRsZWQgaW4gY21hcC5cbiAgICBhdHRycy5jaGFyU3RyaW5ncyA9IGF0dHJzLmNoYXJzZXQgKyB0LmNoYXJzZXRzLnNpemVPZigpO1xuICAgIGF0dHJzLnByaXZhdGVbMV0gPSBhdHRycy5jaGFyU3RyaW5ncyArIHQuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKTtcblxuICAgIC8vIFJlY3JlYXRlIHRoZSBUb3AgRElDVCBJTkRFWCB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuXG4gICAgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlQ0ZGVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlQ0ZGVGFibGU7XG5cbn0se1wiLi4vZW5jb2RpbmdcIjozLFwiLi4vZ2x5cGhcIjo1LFwiLi4vcGFyc2VcIjo3LFwiLi4vcGF0aFwiOjgsXCIuLi90YWJsZVwiOjl9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYGNtYXBgIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY21hcC5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSBfZGVyZXFfKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gX2RlcmVxXygnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IF9kZXJlcV8oJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBgY21hcGAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgdmVyc2lvbiwgbnVtVGFibGVzLCBvZmZzZXQsIHBsYXRmb3JtSWQsIGVuY29kaW5nSWQsIGZvcm1hdCwgc2VnQ291bnQsXG4gICAgICAgIGVuZENvdW50UGFyc2VyLCBzdGFydENvdW50UGFyc2VyLCBpZERlbHRhUGFyc2VyLCBpZFJhbmdlT2Zmc2V0UGFyc2VyLCBnbHlwaEluZGV4T2Zmc2V0LFxuICAgICAgICBlbmRDb3VudCwgc3RhcnRDb3VudCwgaSwgYywgaWREZWx0YSwgaWRSYW5nZU9mZnNldCwgcCwgZ2x5cGhJbmRleDtcbiAgICB2YXIgY21hcCA9IHt9O1xuICAgIGNtYXAudmVyc2lvbiA9IHZlcnNpb24gPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cbiAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuICAgIC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBhIFwicGxhdGZvcm0gM1wiIHRhYmxlLiBUaGlzIGlzIGEgV2luZG93cyBmb3JtYXQuXG4gICAgY21hcC5udW10YWJsZXMgPSBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICBvZmZzZXQgPSAtMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgcGxhdGZvcm1JZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpKTtcbiAgICAgICAgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgMik7XG4gICAgICAgIGlmIChwbGF0Zm9ybUlkID09PSAzICYmIChlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDApKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBjbWFwIHRhYmxlIGluIHRoZSBmb250IHRoYXQgd2Ugc3VwcG9ydCwgc28gcmV0dXJuIG51bGwuXG4gICAgICAgIC8vIFRoaXMgZm9udCB3aWxsIGJlIG1hcmtlZCBhcyB1bnN1cHBvcnRlZC5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuICAgIGNtYXAuZm9ybWF0ID0gZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGZvcm1hdCA9PT0gNCwgJ09ubHkgZm9ybWF0IDQgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY21hcC5sYW5ndWFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBzZWdDb3VudCBpcyBzdG9yZWQgeCAyLlxuICAgIGNtYXAuc2VnQ291bnQgPSBzZWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKSA+PiAxO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuXG4gICAgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuICAgIHN0YXJ0Q291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDIpO1xuICAgIGlkRGVsdGFQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDQpO1xuICAgIGlkUmFuZ2VPZmZzZXRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDYpO1xuICAgIGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdDb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICBlbmRDb3VudCA9IGVuZENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHN0YXJ0Q291bnQgPSBzdGFydENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGlkRGVsdGEgPSBpZERlbHRhUGFyc2VyLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgaWRSYW5nZU9mZnNldCA9IGlkUmFuZ2VPZmZzZXRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yIChjID0gc3RhcnRDb3VudDsgYyA8PSBlbmRDb3VudDsgYyArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPSAoaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgKyBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC0gMik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSBvZiB0aGUgaWRSYW5nZU9mZnNldCwgd2hpY2ggd2lsbCBtb3ZlIHVzIGludG8gdGhlIGdseXBoSW5kZXggYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSBpZFJhbmdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRoZSBjaGFyYWN0ZXIgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2VnbWVudCwgbXVsdGlwbGllZCBieSAyIGZvciBVU0hPUlRzLlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgKz0gKGMgLSBzdGFydENvdW50KSAqIDI7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBnbHlwaEluZGV4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2x5cGhJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGdseXBoSW5kZXggKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoYyArIGlkRGVsdGEpICYgMHhGRkZGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY21hcDtcbn1cblxuZnVuY3Rpb24gYWRkU2VnbWVudCh0LCBjb2RlLCBnbHlwaEluZGV4KSB7XG4gICAgdC5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgZW5kOiBjb2RlLFxuICAgICAgICBzdGFydDogY29kZSxcbiAgICAgICAgZGVsdGE6IC0oY29kZSAtIGdseXBoSW5kZXgpLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGVybWluYXRvclNlZ21lbnQodCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogMHhGRkZGLFxuICAgICAgICBzdGFydDogMHhGRkZGLFxuICAgICAgICBkZWx0YTogMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDbWFwVGFibGUoZ2x5cGhzKSB7XG4gICAgdmFyIGksIGosIGdseXBoO1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdjbWFwJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDEyfSxcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlZ0NvdW50WDInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuXG4gICAgdC5zZWdtZW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWRkU2VnbWVudCh0LCBnbHlwaC51bmljb2Rlc1tqXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVGVybWluYXRvclNlZ21lbnQodCk7XG5cbiAgICB2YXIgc2VnQ291bnQ7XG4gICAgc2VnQ291bnQgPSB0LnNlZ21lbnRzLmxlbmd0aDtcbiAgICB0LnNlZ0NvdW50WDIgPSBzZWdDb3VudCAqIDI7XG4gICAgdC5zZWFyY2hSYW5nZSA9IE1hdGgucG93KDIsIE1hdGguZmxvb3IoTWF0aC5sb2coc2VnQ291bnQpIC8gTWF0aC5sb2coMikpKSAqIDI7XG4gICAgdC5lbnRyeVNlbGVjdG9yID0gTWF0aC5sb2codC5zZWFyY2hSYW5nZSAvIDIpIC8gTWF0aC5sb2coMik7XG4gICAgdC5yYW5nZVNoaWZ0ID0gdC5zZWdDb3VudFgyIC0gdC5zZWFyY2hSYW5nZTtcblxuICAgICAvLyBTZXQgdXAgcGFyYWxsZWwgc2VnbWVudCBhcnJheXMuXG4gICAgdmFyIGVuZENvdW50cyA9IFtdLFxuICAgICAgICBzdGFydENvdW50cyA9IFtdLFxuICAgICAgICBpZERlbHRhcyA9IFtdLFxuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IFtdLFxuICAgICAgICBnbHlwaElkcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0LnNlZ21lbnRzW2ldO1xuICAgICAgICBlbmRDb3VudHMgPSBlbmRDb3VudHMuY29uY2F0KHtuYW1lOiAnZW5kXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG4gICAgICAgIHN0YXJ0Q291bnRzID0gc3RhcnRDb3VudHMuY29uY2F0KHtuYW1lOiAnc3RhcnRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5zdGFydH0pO1xuICAgICAgICBpZERlbHRhcyA9IGlkRGVsdGFzLmNvbmNhdCh7bmFtZTogJ2lkRGVsdGFfJyArIGksIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmRlbHRhfSk7XG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzID0gaWRSYW5nZU9mZnNldHMuY29uY2F0KHtuYW1lOiAnaWRSYW5nZU9mZnNldF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50Lm9mZnNldH0pO1xuICAgICAgICBpZiAoc2VnbWVudC5nbHlwaElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGdseXBoSWRzID0gZ2x5cGhJZHMuY29uY2F0KHtuYW1lOiAnZ2x5cGhfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5nbHlwaElkfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZW5kQ291bnRzKTtcbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVzZXJ2ZWRQYWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9KTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChzdGFydENvdW50cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWREZWx0YXMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkUmFuZ2VPZmZzZXRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChnbHlwaElkcyk7XG5cbiAgICB0Lmxlbmd0aCA9IDE0ICsgLy8gU3VidGFibGUgaGVhZGVyXG4gICAgICAgIGVuZENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgMiArIC8vIHJlc2VydmVkUGFkXG4gICAgICAgIHN0YXJ0Q291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZERlbHRhcy5sZW5ndGggKiAyICtcbiAgICAgICAgaWRSYW5nZU9mZnNldHMubGVuZ3RoICogMiArXG4gICAgICAgIGdseXBoSWRzLmxlbmd0aCAqIDI7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUNtYXBUYWJsZTtcbmV4cG9ydHMubWFrZSA9IG1ha2VDbWFwVGFibGU7XG5cbn0se1wiLi4vY2hlY2tcIjoxLFwiLi4vcGFyc2VcIjo3LFwiLi4vdGFibGVcIjo5fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVGhlIGBnbHlmYCB0YWJsZSBkZXNjcmliZXMgdGhlIGdseXBocyBpbiBUcnVlVHlwZSBvdXRsaW5lIGZvcm1hdC5cbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9nbHlmLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IF9kZXJlcV8oJy4uL2NoZWNrJyk7XG52YXIgX2dseXBoID0gX2RlcmVxXygnLi4vZ2x5cGgnKTtcbnZhciBwYXJzZSA9IF9kZXJlcV8oJy4uL3BhcnNlJyk7XG52YXIgcGF0aCA9IF9kZXJlcV8oJy4uL3BhdGgnKTtcblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZGF0YSwgc3RhcnQsIGluZGV4LCBmb250KSB7XG4gICAgdmFyIHAsIGdseXBoLCBmbGFnLCBpLCBqLCBmbGFncyxcbiAgICAgICAgZW5kUG9pbnRJbmRpY2VzLCBudW1iZXJPZkNvb3JkaW5hdGVzLCByZXBlYXRDb3VudCwgcG9pbnRzLCBwb2ludCwgcHgsIHB5LFxuICAgICAgICBjb21wb25lbnQsIG1vcmVDb21wb25lbnRzO1xuICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBnbHlwaCA9IG5ldyBfZ2x5cGguR2x5cGgoe2ZvbnQ6IGZvbnQsIGluZGV4OiBpbmRleH0pO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC54TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGgueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC55TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICBlbmRQb2ludEluZGljZXMgPSBnbHlwaC5lbmRQb2ludEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByZXBlYXRDb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC55ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHksIDQsIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgcHkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbW9yZUNvbXBvbmVudHMgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobW9yZUNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIGZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgeFNjYWxlOiAxLFxuICAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgICB5U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgd29yZHNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGFyZ3VtZW50cyBhcmUgYnl0ZXNcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdseXBoO1xufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzLCBpLCBwdCwgbmV3UHQ7XG4gICAgbmV3UG9pbnRzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1BvaW50cztcbn1cblxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMsIGN1cnJlbnRDb250b3VyLCBpLCBwdDtcbiAgICBjb250b3VycyA9IFtdO1xuICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCwgY29udG91cnMsIGksIHJlYWxGaXJzdFBvaW50LCBqLCBjb250b3VyLCBwdCwgZmlyc3RQdCxcbiAgICAgICAgcHJldlB0LCBtaWRQdCwgY3VydmVQdCwgbGFzdFB0O1xuICAgIHAgPSBuZXcgcGF0aC5QYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udG91cnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29udG91ciA9IGNvbnRvdXJzW2ldO1xuICAgICAgICBmaXJzdFB0ID0gY29udG91clswXTtcbiAgICAgICAgbGFzdFB0ID0gY29udG91cltjb250b3VyLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZmlyc3RQdC5vbkN1cnZlKSB7XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCB3aWxsIGJlIGNvbnN1bWVkIGJ5IHRoZSBtb3ZlVG8gY29tbWFuZCxcbiAgICAgICAgICAgIC8vIHNvIHNraXAgaXQgaW4gdGhlIGxvb3AuXG4gICAgICAgICAgICByZWFsRmlyc3RQb2ludCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGFzdFB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgcG9pbnQgaXMgb2ZmLWN1cnZlIGFuZCB0aGUgbGFzdCBwb2ludCBpcyBvbi1jdXJ2ZSxcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCB0aGUgbGFzdCBwb2ludC5cbiAgICAgICAgICAgICAgICBmaXJzdFB0ID0gbGFzdFB0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgZmlyc3RQdCA9IHsgeDogKGZpcnN0UHQueCArIGxhc3RQdC54KSAvIDIsIHk6IChmaXJzdFB0LnkgKyBsYXN0UHQueSkgLyAyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJ2ZVB0ID0gZmlyc3RQdDtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwb2ludCBpcyBzeW50aGVzaXplZCwgc28gZG9uJ3Qgc2tpcCB0aGUgcmVhbCBmaXJzdCBwb2ludC5cbiAgICAgICAgICAgIHJlYWxGaXJzdFBvaW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcC5tb3ZlVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuXG4gICAgICAgIGZvciAoaiA9IHJlYWxGaXJzdFBvaW50ID8gMSA6IDA7IGogPCBjb250b3VyLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBwdCA9IGNvbnRvdXJbal07XG4gICAgICAgICAgICBwcmV2UHQgPSBqID09PSAwID8gZmlyc3RQdCA6IGNvbnRvdXJbaiAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlB0Lm9uQ3VydmUgJiYgIXB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwcmV2UHQub25DdXJ2ZSAmJiAhcHQub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgIG1pZFB0ID0geyB4OiAocHJldlB0LnggKyBwdC54KSAvIDIsIHk6IChwcmV2UHQueSArIHB0LnkpIC8gMiB9O1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhwcmV2UHQueCwgcHJldlB0LnksIG1pZFB0LngsIG1pZFB0LnkpO1xuICAgICAgICAgICAgICAgIGN1cnZlUHQgPSBwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXByZXZQdC5vbkN1cnZlICYmIHB0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2aW91cyBwb2ludCBvZmYtY3VydmUsIHRoaXMgcG9pbnQgb24tY3VydmUuXG4gICAgICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnZlUHQueCwgY3VydmVQdC55LCBwdC54LCBwdC55KTtcbiAgICAgICAgICAgICAgICBjdXJ2ZVB0ID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFB0ICE9PSBsYXN0UHQpIHtcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGxhc3QgYW5kIGZpcnN0IHBvaW50c1xuICAgICAgICAgICAgaWYgKGN1cnZlUHQpIHtcbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3VydmVQdC54LCBjdXJ2ZVB0LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC5saW5lVG8oZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMsIGksIGosIG9mZnNldCwgbmV4dE9mZnNldCwgZ2x5cGgsXG4gICAgICAgIGNvbXBvbmVudCwgY29tcG9uZW50R2x5cGgsIHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIGdseXBocyA9IFtdO1xuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgbmV4dE9mZnNldCA9IGxvY2FbaSArIDFdO1xuICAgICAgICBpZiAob2Zmc2V0ICE9PSBuZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChwYXJzZUdseXBoKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBpLCBmb250KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChuZXcgX2dseXBoLkdseXBoKHtmb250OiBmb250LCBpbmRleDogaX0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBHbyBvdmVyIHRoZSBnbHlwaHMgYWdhaW4sIHJlc29sdmluZyB0aGUgY29tcG9zaXRlIGdseXBocy5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRHbHlwaCA9IGdseXBoc1tjb21wb25lbnQuZ2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEdseXBoLnBvaW50cykge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IGdseXBoLnBvaW50cy5jb25jYXQodHJhbnNmb3JtZWRQb2ludHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnbHlwaC5wYXRoID0gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VHbHlmVGFibGU7XG5cbn0se1wiLi4vY2hlY2tcIjoxLFwiLi4vZ2x5cGhcIjo1LFwiLi4vcGFyc2VcIjo3LFwiLi4vcGF0aFwiOjh9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSBfZGVyZXFfKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gX2RlcmVxXygnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBuID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIEZvcm1hdCAxIGlzIGEgc2ltcGxlIGxpc3Qgb2YgZ2x5cGggaWRzLFxuLy8gRm9ybWF0IDIgaXMgYSBsaXN0IG9mIHJhbmdlcy4gSXQgaXMgZXhwYW5kZWQgaW4gYSBsaXN0IG9mIGdseXBocywgbWF5YmUgbm90IHRoZSBiZXN0IGlkZWEuXG5mdW5jdGlvbiBwYXJzZUNvdmVyYWdlVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgIGNvdW50ID0gIHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwLnBhcnNlVVNob3J0TGlzdChjb3VudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgaSwgYmVnaW4sIGVuZCwgaW5kZXgsIGNvdmVyYWdlID0gW107XG4gICAgICAgIGZvciAoOyBjb3VudC0tOykge1xuICAgICAgICAgICAgYmVnaW4gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBlbmQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBpbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGZvciAoaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3ZlcmFnZTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGdldHMgYSBjbGFzcyB2YWx1ZSBmcm9tIGEgZ2x5cGggSUQuXG5mdW5jdGlvbiBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpLFxuICAgICAgICBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGb3JtYXQgMSBzcGVjaWZpZXMgYSByYW5nZSBvZiBjb25zZWN1dGl2ZSBnbHlwaCBpbmRpY2VzLCBvbmUgY2xhc3MgcGVyIGdseXBoIElELlxuICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGdseXBoQ291bnQgPSBwLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzID0gcC5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihnbHlwaElEKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlc1tnbHlwaElEIC0gc3RhcnRHbHlwaF0gfHwgMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIC8vIEZvcm1hdCAyIGRlZmluZXMgbXVsdGlwbGUgZ3JvdXBzIG9mIGdseXBoIGluZGljZXMgdGhhdCBiZWxvbmcgdG8gdGhlIHNhbWUgY2xhc3MuXG4gICAgICAgIHZhciByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgc3RhcnRHbHlwaHMgPSBbXSxcbiAgICAgICAgICAgIGVuZEdseXBocyA9IFtdLFxuICAgICAgICAgICAgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGdseXBoSUQpIHtcbiAgICAgICAgICAgIHZhciBsLCBjLCByO1xuICAgICAgICAgICAgbCA9IDA7XG4gICAgICAgICAgICByID0gc3RhcnRHbHlwaHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChsIDwgcikge1xuICAgICAgICAgICAgICAgIGMgPSAobCArIHIgKyAxKSA+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaElEIDwgc3RhcnRHbHlwaHNbY10pIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGMgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGwgPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydEdseXBoc1tsXSA8PSBnbHlwaElEICYmIGdseXBoSUQgPD0gZW5kR2x5cGhzW2xdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzVmFsdWVzW2xdIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgcGFpciBhZGp1c3RtZW50IHBvc2l0aW9uaW5nIHN1YnRhYmxlLCBmb3JtYXQgMSBvciBmb3JtYXQgMlxuLy8gVGhlIHN1YnRhYmxlIGlzIHJldHVybmVkIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwIGZ1bmN0aW9uLlxuZnVuY3Rpb24gcGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQsIGNvdmVyYWdlT2Zmc2V0LCBjb3ZlcmFnZSwgdmFsdWVGb3JtYXQxLCB2YWx1ZUZvcm1hdDIsXG4gICAgICAgIHNoYXJlZFBhaXJTZXRzLCBmaXJzdEdseXBoLCBzZWNvbmRHbHlwaCwgdmFsdWUxLCB2YWx1ZTI7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0K2NvdmVyYWdlT2Zmc2V0KTtcbiAgICAvLyB2YWx1ZUZvcm1hdCA0OiBYQWR2YW5jZSBvbmx5LCAxOiBYUGxhY2VtZW50IG9ubHksIDA6IG5vIFZhbHVlUmVjb3JkIGZvciBzZWNvbmQgZ2x5cGhcbiAgICAvLyBPbmx5IHZhbHVlRm9ybWF0MT00IGFuZCB2YWx1ZUZvcm1hdDI9MCBpcyBzdXBwb3J0ZWQuXG4gICAgdmFsdWVGb3JtYXQxID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhbHVlRm9ybWF0MiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAodmFsdWVGb3JtYXQxICE9PSA0IHx8IHZhbHVlRm9ybWF0MiAhPT0gMCkgcmV0dXJuO1xuICAgIHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIHZhciBwYWlyU2V0Q291bnQsIHBhaXJTZXRPZmZzZXRzLCBwYWlyU2V0T2Zmc2V0LCBzaGFyZWRQYWlyU2V0LCBwYWlyVmFsdWVDb3VudCwgcGFpclNldDtcbiAgICAgICAgcGFpclNldENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwYWlyU2V0ID0gW107XG4gICAgICAgIC8vIEFycmF5IG9mIG9mZnNldHMgdG8gUGFpclNldCB0YWJsZXMtZnJvbSBiZWdpbm5pbmcgb2YgUGFpclBvcyBzdWJ0YWJsZS1vcmRlcmVkIGJ5IENvdmVyYWdlIEluZGV4XG4gICAgICAgIHBhaXJTZXRPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChwYWlyU2V0Q291bnQpO1xuICAgICAgICBmb3IgKGZpcnN0R2x5cGggPSAwOyBmaXJzdEdseXBoIDwgcGFpclNldENvdW50OyBmaXJzdEdseXBoKyspIHtcbiAgICAgICAgICAgIHBhaXJTZXRPZmZzZXQgPSBwYWlyU2V0T2Zmc2V0c1tmaXJzdEdseXBoXTtcbiAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICBwYWlyVmFsdWVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgcGFpclZhbHVlQ291bnQtLTspIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUZvcm1hdDEpIHZhbHVlMSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHZhbHVlMSBpcyB0aGUgWEFkdmFuY2UgYW5kIHZhbHVlMiBpcyBlbXB0eS5cbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkUGFpclNldFtzZWNvbmRHbHlwaF0gPSB2YWx1ZTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFpclNldFtjb3ZlcmFnZVtmaXJzdEdseXBoXV0gPSBzaGFyZWRQYWlyU2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlycyA9IHBhaXJTZXRbbGVmdEdseXBoXTtcbiAgICAgICAgICAgIGlmIChwYWlycykgcmV0dXJuIHBhaXJzW3JpZ2h0R2x5cGhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgLy8gUGFpciBQb3NpdGlvbmluZyBBZGp1c3RtZW50OiBGb3JtYXQgMlxuICAgICAgICB2YXIgY2xhc3NEZWYxT2Zmc2V0LCBjbGFzc0RlZjJPZmZzZXQsIGNsYXNzMUNvdW50LCBjbGFzczJDb3VudCwgaSwgaixcbiAgICAgICAgICAgIGdldENsYXNzMSwgZ2V0Q2xhc3MyLCBrZXJuaW5nTWF0cml4LCBrZXJuaW5nUm93LCBjb3ZlcmVkO1xuICAgICAgICBjbGFzc0RlZjFPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzRGVmMk9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2xhc3MxQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNsYXNzMkNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnZXRDbGFzczEgPSBwYXJzZUNsYXNzRGVmVGFibGUoZGF0YSwgc3RhcnQrY2xhc3NEZWYxT2Zmc2V0KTtcbiAgICAgICAgZ2V0Q2xhc3MyID0gcGFyc2VDbGFzc0RlZlRhYmxlKGRhdGEsIHN0YXJ0K2NsYXNzRGVmMk9mZnNldCk7XG5cbiAgICAgICAgLy8gUGFyc2Uga2VybmluZyB2YWx1ZXMgYnkgY2xhc3MgcGFpci5cbiAgICAgICAga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3MxQ291bnQ7IGkrKykge1xuICAgICAgICAgICAga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjbGFzczJDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MSkgdmFsdWUxID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHZhbHVlRm9ybWF0MSA9IDQgYW5kIHZhbHVlRm9ybWF0MiA9IDAsXG4gICAgICAgICAgICAgICAgLy8gc28gdmFsdWUxIGlzIHRoZSBYQWR2YW5jZSBhbmQgdmFsdWUyIGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgIGtlcm5pbmdSb3dbal0gPSB2YWx1ZTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGNvdmVyYWdlIGxpc3QgdG8gYSBoYXNoXG4gICAgICAgIGNvdmVyZWQgPSB7fTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgY292ZXJhZ2UubGVuZ3RoOyBpKyspIGNvdmVyZWRbY292ZXJhZ2VbaV1dID0gMTtcblxuICAgICAgICAvLyBHZXQgdGhlIGtlcm5pbmcgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZ2x5cGggcGFpci5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkW2xlZnRHbHlwaF0pIHJldHVybjtcbiAgICAgICAgICAgIHZhciBjbGFzczEgPSBnZXRDbGFzczEobGVmdEdseXBoKSxcbiAgICAgICAgICAgICAgICBjbGFzczIgPSBnZXRDbGFzczIocmlnaHRHbHlwaCksXG4gICAgICAgICAgICAgICAga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbY2xhc3MxXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChrZXJuaW5nUm93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlcm5pbmdSb3dbY2xhc3MyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgTG9va3VwVGFibGUgKHByZXNlbnQgaW4gb2YgR1BPUywgR1NVQiwgR0RFRiwgQkFTRSwgSlNURiB0YWJsZXMpLlxuZnVuY3Rpb24gcGFyc2VMb29rdXBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlLCBsb29rdXBUeXBlLCBsb29rdXBGbGFnLCB1c2VNYXJrRmlsdGVyaW5nU2V0LCBzdWJUYWJsZUNvdW50LCBzdWJUYWJsZU9mZnNldHMsIHN1YnRhYmxlcywgaTtcbiAgICBsb29rdXBUeXBlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGxvb2t1cEZsYWcgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuICAgIHN1YlRhYmxlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgc3ViVGFibGVPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChzdWJUYWJsZUNvdW50KTtcbiAgICB0YWJsZSA9IHtcbiAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcbiAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHAucGFyc2VVU2hvcnQoKSA6IC0xXG4gICAgfTtcbiAgICAvLyBMb29rdXBUeXBlIDIsIFBhaXIgYWRqdXN0bWVudFxuICAgIGlmIChsb29rdXBUeXBlID09PSAyKSB7XG4gICAgICAgIHN1YnRhYmxlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3ViVGFibGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJ0YWJsZXMucHVzaChwYXJzZVBhaXJQb3NTdWJUYWJsZShkYXRhLCBzdGFydCArIHN1YlRhYmxlT2Zmc2V0c1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGZpbmRzIHRoZSBrZXJuaW5nIHZhbHVlcyBpbiB0aGUgc3VidGFibGVzLlxuICAgICAgICB0YWJsZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdWJ0YWJsZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gc3VidGFibGVzW2ldKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIFBhcnNlIHRoZSBgR1BPU2AgdGFibGUgd2hpY2ggY29udGFpbnMsIGFtb25nIG90aGVyIHRoaW5ncywga2VybmluZyBwYWlycy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cbmZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0LCBmb250KSB7XG4gICAgdmFyIHAsIHRhYmxlVmVyc2lvbiwgbG9va3VwTGlzdE9mZnNldCwgc2NyaXB0TGlzdCwgaSwgZmVhdHVyZUxpc3QsIGxvb2t1cENvdW50LFxuICAgICAgICBsb29rdXBUYWJsZU9mZnNldHMsIGxvb2t1cExpc3RBYnNvbHV0ZU9mZnNldCwgdGFibGU7XG5cbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdGFibGVWZXJzaW9uID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uLicpO1xuXG4gICAgLy8gU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgLSBpZ25vcmVkIGZvciBub3dcbiAgICBzY3JpcHRMaXN0ID0gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQrcC5wYXJzZVVTaG9ydCgpKTtcbiAgICAvLyAna2VybicgaXMgdGhlIGZlYXR1cmUgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIGZlYXR1cmVMaXN0ID0gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQrcC5wYXJzZVVTaG9ydCgpKTtcblxuICAgIC8vIExvb2t1cExpc3RcbiAgICBsb29rdXBMaXN0T2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHAucmVsYXRpdmVPZmZzZXQgPSBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGxvb2t1cENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGxvb2t1cFRhYmxlT2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3QobG9va3VwQ291bnQpO1xuICAgIGxvb2t1cExpc3RBYnNvbHV0ZU9mZnNldCA9IHN0YXJ0ICsgbG9va3VwTGlzdE9mZnNldDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbG9va3VwQ291bnQ7IGkrKykge1xuICAgICAgICB0YWJsZSA9IHBhcnNlTG9va3VwVGFibGUoZGF0YSwgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ICsgbG9va3VwVGFibGVPZmZzZXRzW2ldKTtcbiAgICAgICAgaWYgKHRhYmxlLmxvb2t1cFR5cGUgPT09IDIgJiYgIWZvbnQuZ2V0R3Bvc0tlcm5pbmdWYWx1ZSkgZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlID0gdGFibGUuZ2V0S2VybmluZ1ZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlR3Bvc1RhYmxlO1xuXG59LHtcIi4uL2NoZWNrXCI6MSxcIi4uL3BhcnNlXCI6N31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoZSBgaGVhZGAgdGFibGUgY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oZWFkLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IF9kZXJlcV8oJy4uL2NoZWNrJyk7XG52YXIgcGFyc2UgPSBfZGVyZXFfKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gX2RlcmVxXygnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIGhlYWRlciBgaGVhZGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlSGVhZFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWQgPSB7fSxcbiAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWQudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGVhZC5mb250UmV2aXNpb24gPSBNYXRoLnJvdW5kKHAucGFyc2VGaXhlZCgpICogMTAwMCkgLyAxMDAwO1xuICAgIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgaGVhZC5tYWdpY051bWJlciA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NUYwRjNDRjUsICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLicpO1xuICAgIGhlYWQuZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLm1vZGlmaWVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5sb3dlc3RSZWNQUEVNID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTsgICAgIC8vIDUwXG4gICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICByZXR1cm4gaGVhZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRUYWJsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGVhZCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2ZvbnRSZXZpc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdjaGVja1N1bUFkanVzdG1lbnQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWFnaWNOdW1iZXInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHg1RjBGM0NGNX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuaXRzUGVyRW0nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwMDB9LFxuICAgICAgICB7bmFtZTogJ2NyZWF0ZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21vZGlmaWVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hY1N0eWxlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsb3dlc3RSZWNQUEVNJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdmb250RGlyZWN0aW9uSGludCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdpbmRleFRvTG9jRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2dseXBoRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VIZWFkVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlSGVhZFRhYmxlO1xuXG59LHtcIi4uL2NoZWNrXCI6MSxcIi4uL3BhcnNlXCI6NyxcIi4uL3RhYmxlXCI6OX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXJzZSA9IF9kZXJlcV8oJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSBfZGVyZXFfKCcuLi90YWJsZScpO1xuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSGhlYVRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhoZWFUYWJsZTtcblxufSx7XCIuLi9wYXJzZVwiOjcsXCIuLi90YWJsZVwiOjl9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2htdHguaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gX2RlcmVxXygnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IF9kZXJlcV8oJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgdmFyIHAsIGksIGdseXBoLCBhZHZhbmNlV2lkdGgsIGxlZnRTaWRlQmVhcmluZztcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBnbHlwaC5hZHZhbmNlV2lkdGggPSBhZHZhbmNlV2lkdGg7XG4gICAgICAgIGdseXBoLmxlZnRTaWRlQmVhcmluZyA9IGxlZnRTaWRlQmVhcmluZztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VIbXR4VGFibGUoZ2x5cGhzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ2htdHgnLCBbXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICB2YXIgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBsZWZ0U2lkZUJlYXJpbmcgPSBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgfHwgMDtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2FkdmFuY2VXaWR0aF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBhZHZhbmNlV2lkdGh9KTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlZnRTaWRlQmVhcmluZ18nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IGxlZnRTaWRlQmVhcmluZ30pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlSG10eFRhYmxlO1xuZXhwb3J0cy5tYWtlID0gbWFrZUhtdHhUYWJsZTtcblxuXG5cblxufSx7XCIuLi9wYXJzZVwiOjcsXCIuLi90YWJsZVwiOjl9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYGtlcm5gIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG4vLyBOb3RlIHRoYXQgc29tZSBmb250cyB1c2UgdGhlIEdQT1MgT3BlblR5cGUgbGF5b3V0IHRhYmxlIHRvIHNwZWNpZnkga2VybmluZy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMva2Vybi5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2hlY2sgPSBfZGVyZXFfKCcuLi9jaGVjaycpO1xudmFyIHBhcnNlID0gX2RlcmVxXygnLi4vcGFyc2UnKTtcblxuLy8gUGFyc2UgdGhlIGBrZXJuYCB0YWJsZSB3aGljaCBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VLZXJuVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcGFpcnMsIHAsIHRhYmxlVmVyc2lvbiwgc3ViVGFibGVWZXJzaW9uLCBuUGFpcnMsXG4gICAgICAgIGksIGxlZnRJbmRleCwgcmlnaHRJbmRleCwgdmFsdWU7XG4gICAgcGFpcnMgPSB7fTtcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTtcbiAgICBzdWJUYWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3ViVGFibGVWZXJzaW9uID09PSAwLCAnVW5zdXBwb3J0ZWQga2VybiBzdWItdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBTa2lwIHN1YlRhYmxlTGVuZ3RoLCBzdWJUYWJsZUNvdmVyYWdlXG4gICAgcC5za2lwKCd1U2hvcnQnLCAyKTtcbiAgICBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlS2VyblRhYmxlO1xuXG59LHtcIi4uL2NoZWNrXCI6MSxcIi4uL3BhcnNlXCI6N31dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbG9jYS5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSBfZGVyZXFfKCcuLi9wYXJzZScpO1xuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCwgcGFyc2VGbiwgZ2x5cGhPZmZzZXRzLCBnbHlwaE9mZnNldCwgaTtcbiAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgcGFyc2VGbiA9IHNob3J0VmVyc2lvbiA/IHAucGFyc2VVU2hvcnQgOiBwLnBhcnNlVUxvbmc7XG4gICAgLy8gVGhlcmUgaXMgYW4gZXh0cmEgZW50cnkgYWZ0ZXIgdGhlIGxhc3QgaW5kZXggZWxlbWVudCB0byBjb21wdXRlIHRoZSBsZW5ndGggb2YgdGhlIGxhc3QgZ2x5cGguXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSB1c2UgbnVtR2x5cGhzICsgMS5cbiAgICBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZUxvY2FUYWJsZTtcblxufSx7XCIuLi9wYXJzZVwiOjd9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYG1heHBgIHRhYmxlIGVzdGFibGlzaGVzIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGZvciB0aGUgZm9udC5cbi8vIFdlIG5lZWQgaXQganVzdCB0byBnZXQgdGhlIG51bWJlciBvZiBnbHlwaHMgaW4gdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL21heHAuaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBhcnNlID0gX2RlcmVxXygnLi4vcGFyc2UnKTtcbnZhciB0YWJsZSA9IF9kZXJlcV8oJy4uL3RhYmxlJyk7XG5cbi8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgbWF4cCA9IHt9LFxuICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgbWF4cC52ZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBtYXhwLm51bUdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAobWF4cC52ZXJzaW9uID09PSAxLjApIHtcbiAgICAgICAgbWF4cC5tYXhQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlUG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZUNvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFpvbmVzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFR3aWxpZ2h0UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0b3JhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4RnVuY3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEluc3RydWN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdGFja0VsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFNpemVPZkluc3RydWN0aW9ucyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnRFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb25lbnREZXB0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heHA7XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXhwVGFibGUobnVtR2x5cGhzKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbWF4cCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMDUwMDB9LFxuICAgICAgICB7bmFtZTogJ251bUdseXBocycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbnVtR2x5cGhzfVxuICAgIF0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VNYXhwVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTWF4cFRhYmxlO1xuXG59LHtcIi4uL3BhcnNlXCI6NyxcIi4uL3RhYmxlXCI6OX1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoZSBgbmFtZWAgbmFtaW5nIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9uYW1lLmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGUgPSBfZGVyZXFfKCcuLi90eXBlcycpLmVuY29kZTtcbnZhciBwYXJzZSA9IF9kZXJlcV8oJy4uL3BhcnNlJyk7XG52YXIgdGFibGUgPSBfZGVyZXFfKCcuLi90YWJsZScpO1xuXG4vLyBOYW1lSURzIGZvciB0aGUgbmFtZSB0YWJsZS5cbnZhciBuYW1lVGFibGVOYW1lcyA9IFtcbiAgICAnY29weXJpZ2h0JywgICAgICAgICAgICAgIC8vIDBcbiAgICAnZm9udEZhbWlseScsICAgICAgICAgICAgIC8vIDFcbiAgICAnZm9udFN1YmZhbWlseScsICAgICAgICAgIC8vIDJcbiAgICAndW5pcXVlSUQnLCAgICAgICAgICAgICAgIC8vIDNcbiAgICAnZnVsbE5hbWUnLCAgICAgICAgICAgICAgIC8vIDRcbiAgICAndmVyc2lvbicsICAgICAgICAgICAgICAgIC8vIDVcbiAgICAncG9zdFNjcmlwdE5hbWUnLCAgICAgICAgIC8vIDZcbiAgICAndHJhZGVtYXJrJywgICAgICAgICAgICAgIC8vIDdcbiAgICAnbWFudWZhY3R1cmVyJywgICAgICAgICAgIC8vIDhcbiAgICAnZGVzaWduZXInLCAgICAgICAgICAgICAgIC8vIDlcbiAgICAnZGVzY3JpcHRpb24nLCAgICAgICAgICAgIC8vIDEwXG4gICAgJ21hbnVmYWN0dXJlclVSTCcsICAgICAgICAvLyAxMVxuICAgICdkZXNpZ25lclVSTCcsICAgICAgICAgICAgLy8gMTJcbiAgICAnbGljZW5jZScsICAgICAgICAgICAgICAgIC8vIDEzXG4gICAgJ2xpY2VuY2VVUkwnLCAgICAgICAgICAgICAvLyAxNFxuICAgICdyZXNlcnZlZCcsICAgICAgICAgICAgICAgLy8gMTVcbiAgICAncHJlZmVycmVkRmFtaWx5JywgICAgICAgIC8vIDE2XG4gICAgJ3ByZWZlcnJlZFN1YmZhbWlseScsICAgICAvLyAxN1xuICAgICdjb21wYXRpYmxlRnVsbE5hbWUnLCAgICAgLy8gMThcbiAgICAnc2FtcGxlVGV4dCcsICAgICAgICAgICAgIC8vIDE5XG4gICAgJ3Bvc3RTY3JpcHRGaW5kRm9udE5hbWUnLCAvLyAyMFxuICAgICd3d3NGYW1pbHknLCAgICAgICAgICAgICAgLy8gMjFcbiAgICAnd3dzU3ViZmFtaWx5JyAgICAgICAgICAgIC8vIDIyXG5dO1xuXG4vLyBQYXJzZSB0aGUgbmFtaW5nIGBuYW1lYCB0YWJsZVxuLy8gT25seSBXaW5kb3dzIFVuaWNvZGUgRW5nbGlzaCBuYW1lcyBhcmUgc3VwcG9ydGVkLlxuLy8gRm9ybWF0IDEgYWRkaXRpb25hbCBmaWVsZHMgYXJlIG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIHBhcnNlTmFtZVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG5hbWUgPSB7fSxcbiAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG5hbWUuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3VudCA9IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgc3RyaW5nT2Zmc2V0ID0gcC5vZmZzZXQgKyBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgcHJvcGVydHksIGJ5dGVMZW5ndGgsXG4gICAgICAgIG9mZnNldCwgc3RyLCBpLCBqLCBjb2RlUG9pbnRzO1xuICAgIHZhciB1bmtub3duQ291bnQgPSAwO1xuICAgIGZvcihpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgcGxhdGZvcm1JRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZW5jb2RpbmdJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbGFuZ3VhZ2VJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbmFtZUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBwcm9wZXJ0eSA9IG5hbWVUYWJsZU5hbWVzW25hbWVJRF07XG4gICAgICAgIGJ5dGVMZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgLy8gcGxhdGZvcm1JRCAtIGVuY29kaW5nSUQgLSBsYW5ndWFnZUlEIHN0YW5kYXJkIGNvbWJpbmF0aW9ucyA6XG4gICAgICAgIC8vIDEgLSAwIC0gMCA6IE1hY2ludG9zaCwgUm9tYW4sIEVuZ2xpc2hcbiAgICAgICAgLy8gMyAtIDEgLSAweDQwOSA6IFdpbmRvd3MsIFVuaWNvZGUgQk1QIChVQ1MtMiksIGVuLVVTXG4gICAgICAgIGlmIChwbGF0Zm9ybUlEID09PSAzICYmIGVuY29kaW5nSUQgPT09IDEgJiYgbGFuZ3VhZ2VJRCA9PT0gMHg0MDkpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoLzI7XG4gICAgICAgICAgICBmb3IoaiA9IDA7IGogPCBsZW5ndGg7IGorKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnRzW2pdID0gcGFyc2UuZ2V0U2hvcnQoZGF0YSwgc3RyaW5nT2Zmc2V0K29mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgbmFtZVtwcm9wZXJ0eV0gPSBzdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmtub3duQ291bnQrKztcbiAgICAgICAgICAgICAgICBuYW1lWyd1bmtub3duJyt1bmtub3duQ291bnRdID0gc3RyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgaWYgKG5hbWUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIG5hbWUubGFuZ1RhZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVSZWNvcmQocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCwgbmFtZUlELCBsZW5ndGgsIG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ05hbWVSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcGxhdGZvcm1JRH0sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZW5jb2RpbmdJRH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2VJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGFuZ3VhZ2VJRH0sXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG9mZnNldH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gYWRkTWFjaW50b3NoTmFtZVJlY29yZCh0LCByZWNvcmRJRCwgcywgb2Zmc2V0KSB7XG4gICAgLy8gTWFjaW50b3NoLCBSb21hbiwgRW5nbGlzaFxuICAgIHZhciBzdHJpbmdCeXRlcyA9IGVuY29kZS5TVFJJTkcocyk7XG4gICAgdC5yZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMSwgMCwgMCwgcmVjb3JkSUQsIHN0cmluZ0J5dGVzLmxlbmd0aCwgb2Zmc2V0KSk7XG4gICAgdC5zdHJpbmdzLnB1c2goc3RyaW5nQnl0ZXMpO1xuICAgIG9mZnNldCArPSBzdHJpbmdCeXRlcy5sZW5ndGg7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gYWRkV2luZG93c05hbWVSZWNvcmQodCwgcmVjb3JkSUQsIHMsIG9mZnNldCkge1xuICAgIC8vIFdpbmRvd3MsIFVuaWNvZGUgQk1QIChVQ1MtMiksIFVTIEVuZ2xpc2hcbiAgICB2YXIgdXRmMTZCeXRlcyA9IGVuY29kZS5VVEYxNihzKTtcbiAgICB0LnJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZCgzLCAxLCAweDA0MDksIHJlY29yZElELCB1dGYxNkJ5dGVzLmxlbmd0aCwgb2Zmc2V0KSk7XG4gICAgdC5zdHJpbmdzLnB1c2godXRmMTZCeXRlcyk7XG4gICAgb2Zmc2V0ICs9IHV0ZjE2Qnl0ZXMubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lVGFibGUob3B0aW9ucykge1xuICAgIHZhciBpLCBzO1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCduYW1lJywgW1xuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N0cmluZ09mZnNldCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcbiAgICB0LnJlY29yZHMgPSBbXTtcbiAgICB0LnN0cmluZ3MgPSBbXTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAvLyBBZGQgTWFjaW50b3NoIHJlY29yZHMgZmlyc3RcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZVRhYmxlTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZVRhYmxlTmFtZXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGFkZE1hY2ludG9zaE5hbWVSZWNvcmQodCwgaSwgcywgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVuIGFkZCBXaW5kb3dzIHJlY29yZHNcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmFtZVRhYmxlTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZVRhYmxlTmFtZXNbaV1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHMgPSBvcHRpb25zW25hbWVUYWJsZU5hbWVzW2ldXTtcbiAgICAgICAgICAgIG9mZnNldCA9IGFkZFdpbmRvd3NOYW1lUmVjb3JkKHQsIGksIHMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0LmNvdW50ID0gdC5yZWNvcmRzLmxlbmd0aDtcbiAgICB0LnN0cmluZ09mZnNldCA9IDYgKyB0LmNvdW50ICogMTI7XG4gICAgZm9yIChpID0gMDsgaSA8IHQucmVjb3Jkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVjb3JkXycgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdC5yZWNvcmRzW2ldfSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0LnN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ18nICsgaSwgdHlwZTogJ0xJVEVSQUwnLCB2YWx1ZTogdC5zdHJpbmdzW2ldfSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VOYW1lVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlTmFtZVRhYmxlO1xuXG59LHtcIi4uL3BhcnNlXCI6NyxcIi4uL3RhYmxlXCI6OSxcIi4uL3R5cGVzXCI6MjR9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL29zMi5odG1cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGFyc2UgPSBfZGVyZXFfKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gX2RlcmVxXygnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlT1MyVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb3MyID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuICAgIG9zMi51bFVuaWNvZGVSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMyA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpKTtcbiAgICBvczIuZnNTZWxlY3Rpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzRmlyc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzTGFzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuc1R5cG9Bc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0Rlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0xpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIudXNXaW5Bc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2luRGVzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMSkge1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMikge1xuICAgICAgICBvczIuc3hIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnNDYXBIZWlnaHQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzRGVmYXVsdENoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c0JyZWFrQ2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzTWF4Q29udGVudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9zMjtcbn1cblxuZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB4MDAwM30sXG4gICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpZHRoQ2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3Vic2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFBvc2l0aW9uJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NGYW1pbHlDbGFzcycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYldlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlN0cm9rZVZhcmlhdGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYk1pZGxpbmUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhY2hWZW5kSUQnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6ICdYWFhYJ30sXG4gICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTGFzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0xpbmVHYXAnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NDYXBIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTWF4Q29udGV4dCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlT1MyVGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlT1MyVGFibGU7XG5cbn0se1wiLi4vcGFyc2VcIjo3LFwiLi4vdGFibGVcIjo5fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gVGhlIGBwb3N0YCB0YWJsZSBzdG9yZXMgYWRkaXRpb25hbCBQb3N0U2NyaXB0IGluZm9ybWF0aW9uLCBzdWNoIGFzIGdseXBoIG5hbWVzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9wb3N0Lmh0bVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmNvZGluZyA9IF9kZXJlcV8oJy4uL2VuY29kaW5nJyk7XG52YXIgcGFyc2UgPSBfZGVyZXFfKCcuLi9wYXJzZScpO1xudmFyIHRhYmxlID0gX2RlcmVxXygnLi4vdGFibGUnKTtcblxuLy8gUGFyc2UgdGhlIFBvc3RTY3JpcHQgYHBvc3RgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZVBvc3RUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwb3N0ID0ge30sXG4gICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KSxcbiAgICAgICAgaSwgbmFtZUxlbmd0aDtcbiAgICBwb3N0LnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIHBvc3QuaXRhbGljQW5nbGUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwb3N0LnVuZGVybGluZVBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC51bmRlcmxpbmVUaGlja25lc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LmlzRml4ZWRQaXRjaCA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICBwb3N0Lm5hbWVzID0gZW5jb2Rpbmcuc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXggPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zdC5uYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA+PSBlbmNvZGluZy5zdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5hbWVMZW5ndGggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIHBvc3QubmFtZXMucHVzaChwLnBhcnNlU3RyaW5nKG5hbWVMZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlIDIuNTpcbiAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcG9zdC5vZmZzZXQgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgIHBvc3Qub2Zmc2V0W2ldID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VQb3N0VGFibGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgncG9zdCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMzAwMDB9LFxuICAgICAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuICAgIF0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VQb3N0VGFibGU7XG5leHBvcnRzLm1ha2UgPSBtYWtlUG9zdFRhYmxlO1xuXG59LHtcIi4uL2VuY29kaW5nXCI6MyxcIi4uL3BhcnNlXCI6NyxcIi4uL3RhYmxlXCI6OX1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIFRoZSBgc2ZudGAgd3JhcHBlciBwcm92aWRlcyBvcmdhbml6YXRpb24gZm9yIHRoZSB0YWJsZXMgaW4gdGhlIGZvbnQuXG4vLyBJdCBpcyB0aGUgdG9wLWxldmVsIGRhdGEgc3RydWN0dXJlIGluIGEgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3RmZi5odG1cbi8vIFJlY29tbWVuZGF0aW9ucyBmb3IgY3JlYXRpbmcgT3BlblR5cGUgRm9udHM6XG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMxNDAvcmVjb20uaHRtXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNoZWNrID0gX2RlcmVxXygnLi4vY2hlY2snKTtcbnZhciB0YWJsZSA9IF9kZXJlcV8oJy4uL3RhYmxlJyk7XG5cbnZhciBjbWFwID0gX2RlcmVxXygnLi9jbWFwJyk7XG52YXIgY2ZmID0gX2RlcmVxXygnLi9jZmYnKTtcbnZhciBoZWFkID0gX2RlcmVxXygnLi9oZWFkJyk7XG52YXIgaGhlYSA9IF9kZXJlcV8oJy4vaGhlYScpO1xudmFyIGhtdHggPSBfZGVyZXFfKCcuL2htdHgnKTtcbnZhciBtYXhwID0gX2RlcmVxXygnLi9tYXhwJyk7XG52YXIgX25hbWUgPSBfZGVyZXFfKCcuL25hbWUnKTtcbnZhciBvczIgPSBfZGVyZXFfKCcuL29zMicpO1xudmFyIHBvc3QgPSBfZGVyZXFfKCcuL3Bvc3QnKTtcblxuZnVuY3Rpb24gbG9nMih2KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikgfCAwO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHN1bSArPSAoYnl0ZXNbaV0gPDwgMjQpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgMl0gPDwgOCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAzXSk7XG4gICAgfVxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnVGFibGUgUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3RhZycsIHR5cGU6ICdUQUcnLCB2YWx1ZTogdGFnICE9PSB1bmRlZmluZWQgPyB0YWcgOiAnJ30sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW0nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY2hlY2tTdW0gIT09IHVuZGVmaW5lZCA/IGNoZWNrU3VtIDogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG9mZnNldCAhPT0gdW5kZWZpbmVkID8gb2Zmc2V0IDogMH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGxlbmd0aCAhPT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogMH1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZVNmbnRUYWJsZSh0YWJsZXMpIHtcbiAgICB2YXIgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIHZhciBoaWdoZXN0UG93ZXJPZjIgPSBNYXRoLnBvdygyLCBsb2cyKHNmbnQubnVtVGFibGVzKSk7XG4gICAgc2ZudC5zZWFyY2hSYW5nZSA9IDE2ICogaGlnaGVzdFBvd2VyT2YyO1xuICAgIHNmbnQuZW50cnlTZWxlY3RvciA9IGxvZzIoaGlnaGVzdFBvd2VyT2YyKTtcbiAgICBzZm50LnJhbmdlU2hpZnQgPSBzZm50Lm51bVRhYmxlcyAqIDE2IC0gc2ZudC5zZWFyY2hSYW5nZTtcblxuICAgIHZhciByZWNvcmRGaWVsZHMgPSBbXTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIHZhciBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdCA9IHRhYmxlc1tpXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQodC50YWJsZU5hbWUubGVuZ3RoID09PSA0LCAnVGFibGUgbmFtZScgKyB0LnRhYmxlTmFtZSArICcgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgdmFyIHRhYmxlTGVuZ3RoID0gdC5zaXplT2YoKTtcbiAgICAgICAgdmFyIHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogdC50YWJsZU5hbWUgKyAnIHRhYmxlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbiAocjEsIHIyKSB7XG4gICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcbiAgICByZXR1cm4gc2ZudDtcbn1cblxuLy8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBtZXRyaWNzIGZvciB0aGUgZmlyc3QgYXZhaWxhYmxlIGNoYXJhY3Rlci5cbi8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tnbHlwaEluZGV4XTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuLy8gUmV0dXJuIHRoZSBzbWFsbGVzdCBhbmQgbGFyZ2VzdCB1bmljb2RlIHZhbHVlcyBvZiB0aGUgY2hhcmFjdGVycyBpbiB0aGlzIGZvbnQuXG4vLyBGb3IgbW9zdCBmb250cyB0aGUgc21hbGxlc3QgdmFsdWUgd291bGQgYmUgMjAgKHNwYWNlKS5cbmZ1bmN0aW9uIGNoYXJDb2RlQm91bmRzKGdseXBocykge1xuICAgIHZhciBtaW5Db2RlLCBtYXhDb2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgaWYgKGdseXBoLnVuaWNvZGUgPj0gMjApIHtcbiAgICAgICAgICAgIGlmIChtaW5Db2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA8IG1pbkNvZGUpIHtcbiAgICAgICAgICAgICAgICBtaW5Db2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXhDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGgudW5pY29kZSA+IG1heENvZGUpIHtcbiAgICAgICAgICAgICAgICBtYXhDb2RlID0gZ2x5cGgudW5pY29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21pbkNvZGUsIG1heENvZGVdO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBoc1tpXTtcbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgbWV0cmljcyA9IGdseXBoLmdldE1ldHJpY3MoKTtcbiAgICAgICAgeE1pbnMucHVzaChtZXRyaWNzLnhNaW4pO1xuICAgICAgICB5TWlucy5wdXNoKG1ldHJpY3MueU1pbik7XG4gICAgICAgIHhNYXhzLnB1c2gobWV0cmljcy54TWF4KTtcbiAgICAgICAgeU1heHMucHVzaChtZXRyaWNzLnlNYXgpO1xuICAgICAgICBsZWZ0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5sZWZ0U2lkZUJlYXJpbmcpO1xuICAgICAgICByaWdodFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MucmlnaHRTaWRlQmVhcmluZyk7XG4gICAgICAgIGFkdmFuY2VXaWR0aHMucHVzaChnbHlwaC5hZHZhbmNlV2lkdGgpO1xuICAgIH1cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGZvbnQuYXNjZW5kZXIgIT09IHVuZGVmaW5lZCA/IGZvbnQuYXNjZW5kZXIgOiBnbG9iYWxzLnlNYXg7XG4gICAgZ2xvYmFscy5kZXNjZW5kZXIgPSBmb250LmRlc2NlbmRlciAhPT0gdW5kZWZpbmVkID8gZm9udC5kZXNjZW5kZXIgOiBnbG9iYWxzLnlNaW47XG5cbiAgICB2YXIgaGVhZFRhYmxlID0gaGVhZC5tYWtlKHtcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICB4TWluOiBnbG9iYWxzLnhNaW4sXG4gICAgICAgIHlNaW46IGdsb2JhbHMueU1pbixcbiAgICAgICAgeE1heDogZ2xvYmFscy54TWF4LFxuICAgICAgICB5TWF4OiBnbG9iYWxzLnlNYXhcbiAgICB9KTtcblxuICAgIHZhciBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuICAgICAgICAvLyBBZGRpbmcgYSBsaXR0bGUgaGVyZSBtYWtlcyBPUyBYIFF1aWNrIExvb2sgaGFwcHlcbiAgICAgICAgYXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIGFkdmFuY2VXaWR0aE1heDogZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXgsXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5MZWZ0U2lkZUJlYXJpbmcsXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluUmlnaHRTaWRlQmVhcmluZyxcbiAgICAgICAgeE1heEV4dGVudDogZ2xvYmFscy5tYXhMZWZ0U2lkZUJlYXJpbmcgKyAoZ2xvYmFscy54TWF4IC0gZ2xvYmFscy54TWluKSxcbiAgICAgICAgbnVtYmVyT2ZITWV0cmljczogZm9udC5nbHlwaHMubGVuZ3RoXG4gICAgfSk7XG5cbiAgICB2YXIgbWF4cFRhYmxlID0gbWF4cC5tYWtlKGZvbnQuZ2x5cGhzLmxlbmd0aCk7XG5cbiAgICB2YXIgY29kZUJvdW5kcyA9IGNoYXJDb2RlQm91bmRzKGZvbnQuZ2x5cGhzKTtcbiAgICB2YXIgb3MyVGFibGUgPSBvczIubWFrZSh7XG4gICAgICAgIHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoZ2xvYmFscy5hZHZhbmNlV2lkdGhBdmcpLFxuICAgICAgICB1c1dlaWdodENsYXNzOiA1MDAsIC8vIE1lZGl1bSBGSVhNRSBNYWtlIHRoaXMgY29uZmlndXJhYmxlXG4gICAgICAgIHVzV2lkdGhDbGFzczogNSwgLy8gTWVkaXVtIChub3JtYWwpIEZJWE1FIE1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAgICAgdXNGaXJzdENoYXJJbmRleDogY29kZUJvdW5kc1swXSxcbiAgICAgICAgdXNMYXN0Q2hhckluZGV4OiBjb2RlQm91bmRzWzFdLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTE6IDB4MDAwMDAwMDEsIC8vIEJhc2ljIExhdGluXG4gICAgICAgIC8vIFNlZSBodHRwOi8vdHlwb3BoaWxlLmNvbS9ub2RlLzEzMDgxIGZvciBtb3JlIGluZm8gb24gdmVydGljYWwgbWV0cmljcy5cbiAgICAgICAgLy8gV2UgZ2V0IG1ldHJpY3MgZm9yIHR5cGljYWwgY2hhcmFjdGVycyAoc3VjaCBhcyBcInhcIiBmb3IgeEhlaWdodCkuXG4gICAgICAgIC8vIFdlIHByb3ZpZGUgc29tZSBmYWxsYmFjayBjaGFyYWN0ZXJzIGlmIGNoYXJhY3RlcnMgYXJlIHVuYXZhaWxhYmxlOiB0aGVpclxuICAgICAgICAvLyBvcmRlcmluZyB3YXMgY2hvc2VuIGV4cGVyaW1lbnRhbGx5LlxuICAgICAgICBzVHlwb0FzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuICAgICAgICBzVHlwb0Rlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHNUeXBvTGluZUdhcDogMCxcbiAgICAgICAgdXNXaW5Bc2NlbnQ6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIHVzV2luRGVzY2VudDogLWdsb2JhbHMuZGVzY2VuZGVyLFxuICAgICAgICB1bENvZGVQYWdlUmFuZ2UxOiAweDAwMDAwMDAxLCAvLyBCYXNpYyBMYXRpblxuICAgICAgICBzeEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ3h5dncnLCB7eU1heDogMH0pLnlNYXgsXG4gICAgICAgIHNDYXBIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICdISUtMRUZKTU5UWkJEUFJBR09RU1VWV1hZJywgZ2xvYmFscykueU1heCxcbiAgICAgICAgdXNCcmVha0NoYXI6IGZvbnQuaGFzQ2hhcignICcpID8gMzIgOiAwIC8vIFVzZSBzcGFjZSBhcyB0aGUgYnJlYWsgY2hhcmFjdGVyLCBpZiBhdmFpbGFibGUuXG4gICAgfSk7XG5cblxuICAgIHZhciBobXR4VGFibGUgPSBobXR4Lm1ha2UoZm9udC5nbHlwaHMpO1xuICAgIHZhciBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG4gICAgdmFyIGZ1bGxOYW1lID0gZm9udC5mYW1pbHlOYW1lICsgJyAnICsgZm9udC5zdHlsZU5hbWU7XG4gICAgdmFyIHBvc3RTY3JpcHROYW1lID0gZm9udC5mYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBmb250LnN0eWxlTmFtZTtcbiAgICB2YXIgbmFtZVRhYmxlID0gX25hbWUubWFrZSh7XG4gICAgICAgIGNvcHlyaWdodDogZm9udC5jb3B5cmlnaHQsXG4gICAgICAgIGZvbnRGYW1pbHk6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgZm9udFN1YmZhbWlseTogZm9udC5zdHlsZU5hbWUsXG4gICAgICAgIHVuaXF1ZUlEOiBmb250Lm1hbnVmYWN0dXJlciArICc6JyArIGZ1bGxOYW1lLFxuICAgICAgICBmdWxsTmFtZTogZnVsbE5hbWUsXG4gICAgICAgIHZlcnNpb246IGZvbnQudmVyc2lvbixcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuICAgICAgICB0cmFkZW1hcms6IGZvbnQudHJhZGVtYXJrLFxuICAgICAgICBtYW51ZmFjdHVyZXI6IGZvbnQubWFudWZhY3R1cmVyLFxuICAgICAgICBkZXNpZ25lcjogZm9udC5kZXNpZ25lcixcbiAgICAgICAgZGVzY3JpcHRpb246IGZvbnQuZGVzY3JpcHRpb24sXG4gICAgICAgIG1hbnVmYWN0dXJlclVSTDogZm9udC5tYW51ZmFjdHVyZXJVUkwsXG4gICAgICAgIGRlc2lnbmVyVVJMOiBmb250LmRlc2lnbmVyVVJMLFxuICAgICAgICBsaWNlbnNlOiBmb250LmxpY2Vuc2UsXG4gICAgICAgIGxpY2Vuc2VVUkw6IGZvbnQubGljZW5zZVVSTCxcbiAgICAgICAgcHJlZmVycmVkRmFtaWx5OiBmb250LmZhbWlseU5hbWUsXG4gICAgICAgIHByZWZlcnJlZFN1YmZhbWlseTogZm9udC5zdHlsZU5hbWVcbiAgICB9KTtcbiAgICB2YXIgcG9zdFRhYmxlID0gcG9zdC5tYWtlKCk7XG4gICAgdmFyIGNmZlRhYmxlID0gY2ZmLm1ha2UoZm9udC5nbHlwaHMsIHtcbiAgICAgICAgdmVyc2lvbjogZm9udC52ZXJzaW9uLFxuICAgICAgICBmdWxsTmFtZTogZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IGZvbnQuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0TmFtZTogZm9udC5zdHlsZU5hbWUsXG4gICAgICAgIHBvc3RTY3JpcHROYW1lOiBwb3N0U2NyaXB0TmFtZVxuICAgIH0pO1xuICAgIC8vIE9yZGVyIHRoZSB0YWJsZXMgYWNjb3JkaW5nIHRvIHRoZSB0aGUgT3BlblR5cGUgc3BlY2lmaWNhdGlvbiAxLjQuXG4gICAgdmFyIHRhYmxlcyA9IFtoZWFkVGFibGUsIGhoZWFUYWJsZSwgbWF4cFRhYmxlLCBvczJUYWJsZSwgbmFtZVRhYmxlLCBjbWFwVGFibGUsIHBvc3RUYWJsZSwgY2ZmVGFibGUsIGhtdHhUYWJsZV07XG5cbiAgICB2YXIgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgdmFyIGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIHZhciBjaGVja1N1bSA9IGNvbXB1dGVDaGVja1N1bShieXRlcyk7XG4gICAgaGVhZFRhYmxlLmNoZWNrU3VtQWRqdXN0bWVudCA9IDB4QjFCMEFGQkEgLSBjaGVja1N1bTtcblxuICAgIC8vIEJ1aWxkIHRoZSBmb250IGFnYWluLCBub3cgd2l0aCB0aGUgcHJvcGVyIGNoZWNrU3VtLlxuICAgIHNmbnRUYWJsZSA9IG1ha2VTZm50VGFibGUodGFibGVzKTtcblxuICAgIHJldHVybiBzZm50VGFibGU7XG59XG5cbmV4cG9ydHMuY29tcHV0ZUNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtO1xuZXhwb3J0cy5tYWtlID0gbWFrZVNmbnRUYWJsZTtcbmV4cG9ydHMuZm9udFRvVGFibGUgPSBmb250VG9TZm50VGFibGU7XG5cbn0se1wiLi4vY2hlY2tcIjoxLFwiLi4vdGFibGVcIjo5LFwiLi9jZmZcIjoxMCxcIi4vY21hcFwiOjExLFwiLi9oZWFkXCI6MTQsXCIuL2hoZWFcIjoxNSxcIi4vaG10eFwiOjE2LFwiLi9tYXhwXCI6MTksXCIuL25hbWVcIjoyMCxcIi4vb3MyXCI6MjEsXCIuL3Bvc3RcIjoyMn1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG4vKiBnbG9iYWwgV2Vha01hcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjaGVjayA9IF9kZXJlcV8oJy4vY2hlY2snKTtcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbnZhciBkZWNvZGUgPSB7fTtcbnZhciBlbmNvZGUgPSB7fTtcbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBDb252ZXJ0IGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24gKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcbiAgICByZXR1cm4gW3ZdO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLy8gQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYi5wdXNoKHYuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBiO1xufTtcblxuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDE2LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMTYpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLy8gQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLy8gQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8vIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbmVuY29kZS5MT05HID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgLy8gVHdvJ3MgY29tcGxlbWVudFxuICAgIGlmICh2ID49IExJTUlUMzIpe1xuICAgICAgICB2ID0gLSAoIDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuXG4vLyBGSVhNRSBJbXBsZW1lbnQgTE9OR0RBVEVUSU1FXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG59O1xuXG5zaXplT2YuTE9OR0RBVEVUSU1FID0gY29uc3RhbnQoOCk7XG5cbi8vIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuZW5jb2RlLlRBRyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbnNpemVPZi5UQUcgPSBjb25zdGFudCg0KTtcblxuLy8gQ0ZGIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZW5jb2RlLkNhcmQ4ID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuQ2FyZDggPSBzaXplT2YuQllURTtcblxuZW5jb2RlLkNhcmQxNiA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuQ2FyZDE2ID0gc2l6ZU9mLlVTSE9SVDtcblxuZW5jb2RlLk9mZlNpemUgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PZmZTaXplID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5TSUQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlNJRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8vIENvbnZlcnQgYSBudW1lcmljIG9wZXJhbmQgb3IgY2hhcnN0cmluZyBudW1iZXIgdG8gYSB2YXJpYWJsZS1zaXplIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAodiA+PSAtMTA3ICYmIHYgPD0gMTA3KSB7XG4gICAgICAgIHJldHVybiBbdiArIDEzOV07XG4gICAgfSBlbHNlIGlmICh2ID49IDEwOCAmJiB2IDw9IDExMzEgKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbnNpemVPZi5OVU1CRVIgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuLy8gVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMik7XG5cbi8vIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZm91ci1ieXRlIHZhbHVlLlxuLy8gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuLy8gYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8vIENvbnZlcnQgYSBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIFVURjE2IGJ5dGVzLlxuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiLnB1c2goMCk7XG4gICAgICAgIGIucHVzaCh2LmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn07XG5cbnNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoICogMjtcbn07XG5cbi8vIENvbnZlcnQgYSBsaXN0IG9mIHZhbHVlcyB0byBhIENGRiBJTkRFWCBzdHJ1Y3R1cmUuXG4vLyBUaGUgdmFsdWVzIHNob3VsZCBiZSBvYmplY3RzIGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZS5cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIG9mZlNpemUsIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgICAgIGRhdGFTaXplLCBpLCB2O1xuICAgIC8vIEJlY2F1c2Ugd2UgaGF2ZSB0byBrbm93IHdoaWNoIGRhdGEgdHlwZSB0byB1c2UgdG8gZW5jb2RlIHRoZSBvZmZzZXRzLFxuICAgIC8vIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgdmFsdWVzIHR3aWNlOiBvbmNlIHRvIGVuY29kZSB0aGUgZGF0YSBhbmRcbiAgICAvLyBjYWxjdWxhdGUgdGhlIG9mZmV0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICBvZmZzZXRzID0gW29mZnNldF07XG4gICAgZGF0YSA9IFtdO1xuICAgIGRhdGFTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIGRhdGFTaXplICs9IHYubGVuZ3RoO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhkYXRhU2l6ZSkvTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2Zmc2V0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBlbmNvZGVkT2Zmc2V0ID0gb2Zmc2V0RW5jb2RlcihvZmZzZXRzW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGVuY29kZS5JTkRFWCh2KS5sZW5ndGg7XG59O1xuXG4vLyBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbi8vIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgdmFyIGQgPSBbXSxcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG0pLFxuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIHZhciB2ID0gbVtrXTtcbiAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQVRPUihrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIGVuY29kZS5ESUNUKG0pLmxlbmd0aDtcbn07XG5cbmVuY29kZS5PUEVSQVRPUiA9IGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHYgPCAxMjAwKSB7XG4gICAgICAgIHJldHVybiBbdl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFsxMiwgdiAtIDEyMDBdO1xuICAgIH1cbn07XG5cbmVuY29kZS5PUEVSQU5EID0gZnVuY3Rpb24gKHYsIHR5cGUpIHtcbiAgICB2YXIgZCwgaTtcbiAgICBkID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG4gICAgICAgICAgICAvLyA0IGJ5dGVzLiBUaGlzIG1ha2VzIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgdGhlIHRvcCBkaWN0IGVhc2llci5cbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRklYTUUgQWRkIHN1cHBvcnQgZm9yIGJvb2xlYW5zXG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbnZhciB3bW0gPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuLy8gQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgaWYgKCB3bW0gJiYgd21tLmhhcyggb3BzICkgKSB7XG4gICAgICAgIHJldHVybiB3bW0uZ2V0KCBvcHMgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IFtdLFxuICAgICAgICBsZW5ndGggPSBvcHMubGVuZ3RoLFxuICAgICAgICBvcCxcbiAgICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBvcCA9IG9wc1tpXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KCBlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpICk7XG4gICAgfVxuXG4gICAgaWYgKCB3bW0gKSB7XG4gICAgICAgIHdtbS5zZXQoIG9wcywgZCApO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuc2l6ZU9mLkNIQVJTVFJJTkcgPSBmdW5jdGlvbiAob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8vIENvbnZlcnQgYSB0YWJsZSBvYmplY3QgdG8gYnl0ZXMuXG4vLyBBIHRhYmxlIGNvbnRhaW5zIGEgbGlzdCBvZiBmaWVsZHMgY29udGFpbmluZyB0aGUgbWV0YWRhdGEgKG5hbWUsIHR5cGUgYW5kIGRlZmF1bHQgdmFsdWUpLlxuLy8gVGhlIHRhYmxlIGl0c2VsZiBoYXMgdGhlIGZpZWxkIHZhbHVlcyBzZXQgYXMgYXR0cmlidXRlcy5cbmVuY29kZS5UQUJMRSA9IGZ1bmN0aW9uICh0YWJsZSkge1xuICAgIHZhciBkID0gW10sXG4gICAgICAgIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGgsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gZW5jb2RpbmdGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBkO1xufTtcblxuLy8gTWVyZ2UgaW4gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2O1xufTtcblxuc2l6ZU9mLkxJVEVSQUwgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cblxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuc2l6ZU9mID0gc2l6ZU9mO1xuXG59LHtcIi4vY2hlY2tcIjoxfV19LHt9LFs2XSkoNilcbn0pO1xuXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogUGFwZXIuanMgdjAuOS4yMSAtIFRoZSBTd2lzcyBBcm15IEtuaWZlIG9mIFZlY3RvciBHcmFwaGljcyBTY3JpcHRpbmcuXG4gKiBodHRwOi8vcGFwZXJqcy5vcmcvXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDExIC0gMjAxNCwgSnVlcmcgTGVobmkgJiBKb25hdGhhbiBQdWNrZXlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vICYgaHR0cDovL2pvbmF0aGFucHVja2V5LmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUgZm9yIGRldGFpbHMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBEYXRlOiBNb24gSmFuIDI2IDE2OjIyOjA2IDIwMTUgKzAxMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxMyBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBuZXcgZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cblx0XHQgIHZhciBub0NhbnZhcyA9XG5cdFx0XHQgICggdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MuYnJvd3NlciAhPT0gdHJ1ZSApIHx8XG5cdFx0XHQgICggdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgKTtcblxudmFyIEJhc2UgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBoaWRkZW4gPSAvXihzdGF0aWNzfGVudW1lcmFibGV8YmVhbnN8cHJlc2VydmUpJC8sXG5cblx0XHRmb3JFYWNoID0gW10uZm9yRWFjaCB8fCBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGZvckluID0gZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzKVxuXHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ocHJvdG8pIHtcblx0XHRcdHJldHVybiB7IF9fcHJvdG9fXzogcHJvdG8gfTtcblx0XHR9LFxuXG5cdFx0ZGVzY3JpYmUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdFx0dmFyIGdldCA9IG9iai5fX2xvb2t1cEdldHRlcl9fICYmIG9iai5fX2xvb2t1cEdldHRlcl9fKG5hbWUpO1xuXHRcdFx0cmV0dXJuIGdldFxuXHRcdFx0XHRcdD8geyBnZXQ6IGdldCwgc2V0OiBvYmouX19sb29rdXBTZXR0ZXJfXyhuYW1lKSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0OiBvYmouaGFzT3duUHJvcGVydHkobmFtZSlcblx0XHRcdFx0XHRcdD8geyB2YWx1ZTogb2JqW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0X2RlZmluZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGlmICgoZGVzYy5nZXQgfHwgZGVzYy5zZXQpICYmIG9iai5fX2RlZmluZUdldHRlcl9fKSB7XG5cdFx0XHRcdGlmIChkZXNjLmdldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVHZXR0ZXJfXyhuYW1lLCBkZXNjLmdldCk7XG5cdFx0XHRcdGlmIChkZXNjLnNldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVTZXR0ZXJfXyhuYW1lLCBkZXNjLnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvYmpbbmFtZV0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0ZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRkZWxldGUgb2JqW25hbWVdO1xuXHRcdFx0cmV0dXJuIF9kZWZpbmUob2JqLCBuYW1lLCBkZXNjKTtcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGluamVjdChkZXN0LCBzcmMsIGVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSkge1xuXHRcdHZhciBiZWFuc05hbWVzID0ge307XG5cblx0XHRmdW5jdGlvbiBmaWVsZChuYW1lLCB2YWwpIHtcblx0XHRcdHZhbCA9IHZhbCB8fCAodmFsID0gZGVzY3JpYmUoc3JjLCBuYW1lKSlcblx0XHRcdFx0XHQmJiAodmFsLmdldCA/IHZhbCA6IHZhbC52YWx1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnIycpXG5cdFx0XHRcdHZhbCA9IGRlc3RbdmFsLnN1YnN0cmluZygxKV0gfHwgdmFsO1xuXHRcdFx0dmFyIGlzRnVuYyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG5cdFx0XHRcdHJlcyA9IHZhbCxcblx0XHRcdFx0cHJldiA9IHByZXNlcnZlIHx8IGlzRnVuY1xuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpXG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRpZiAob2JqKVxuXHRcdFx0KCdsZW5ndGgnIGluIG9iaiAmJiAhb2JqLmdldExlbmd0aFxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0XHQ/IGZvckVhY2hcblx0XHRcdFx0OiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0cmV0dXJuIGJpbmQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob2JqLCBwcm9wcywgZXhjbHVkZSkge1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICghZXhjbHVkZSB8fCAhZXhjbHVkZVtrZXldKSlcblx0XHRcdFx0b2JqW2tleV0gPSBwcm9wc1trZXldO1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHRyZXR1cm4gaW5qZWN0KGZ1bmN0aW9uIEJhc2UoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2V0KHRoaXMsIGFyZ3VtZW50c1tpXSk7XG5cdH0sIHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKHNyYykge1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHR2YXIgc3RhdGljcyA9IHNyYy5zdGF0aWNzID09PSB0cnVlID8gc3JjIDogc3JjLnN0YXRpY3MsXG5cdFx0XHRcdFx0YmVhbnMgPSBzcmMuYmVhbnMsXG5cdFx0XHRcdFx0cHJlc2VydmUgPSBzcmMucHJlc2VydmU7XG5cdFx0XHRcdGlmIChzdGF0aWNzICE9PSBzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMucHJvdG90eXBlLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0XHRpbmplY3QodGhpcywgc3RhdGljcywgdHJ1ZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5pbmplY3QoYXJndW1lbnRzW2ldKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLFxuXHRcdFx0XHRjdG9yO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY3RvciA9IGFyZ3VtZW50c1tpXS5pbml0aWFsaXplKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0ZGVmaW5lKGN0b3IucHJvdG90eXBlLCAnY29uc3RydWN0b3InLFxuXHRcdFx0XHRcdHsgdmFsdWU6IGN0b3IsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRpbmplY3QoY3RvciwgdGhpcywgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cykgOiBjdG9yO1xuXHRcdH1cblx0fSwgdHJ1ZSkuaW5qZWN0KHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMsIHNyYywgc3JjLmVudW1lcmFibGUsIHNyYy5iZWFucywgc3JjLnByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IGNyZWF0ZSh0aGlzKTtcblx0XHRcdHJldHVybiByZXMuaW5qZWN0LmFwcGx5KHJlcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0ZWFjaDogZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0cmV0dXJuIGVhY2godGhpcywgaXRlciwgYmluZCk7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdHJldHVybiBzZXQodGhpcywgcHJvcHMpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGVhY2g6IGVhY2gsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGRlZmluZTogZGVmaW5lLFxuXHRcdFx0ZGVzY3JpYmU6IGRlc2NyaWJlLFxuXHRcdFx0c2V0OiBzZXQsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGlmIChhcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHJldHVybiBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJylcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG5CYXNlLmluamVjdCh7XG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQgIT0gbnVsbFxuXHRcdFx0PyAgKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lXG5cdFx0XHRcdD8gXCIgJ1wiICsgdGhpcy5fbmFtZSArIFwiJ1wiXG5cdFx0XHRcdDogJyBAJyArIHRoaXMuX2lkKVxuXHRcdFx0OiAneyAnICsgQmFzZS5lYWNoKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsgKHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHRcdD8gRm9ybWF0dGVyLmluc3RhbmNlLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtdKS5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRnZXRDbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGFzcyB8fCAnJztcblx0fSxcblxuXHRleHBvcnRKU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzKTtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSwgZG9udENoZWNrKSB7XG5cdFx0aWYgKHByb3BzICYmIChkb250Q2hlY2sgfHwgQmFzZS5pc1BsYWluT2JqZWN0KHByb3BzKSkpIHtcblx0XHRcdHZhciBvcmlnID0gcHJvcHMuX2ZpbHRlcmluZyB8fCBwcm9wcztcblx0XHRcdGZvciAodmFyIGtleSBpbiBvcmlnKSB7XG5cdFx0XHRcdGlmIChvcmlnLmhhc093blByb3BlcnR5KGtleSkgJiYgIShleGNsdWRlICYmIGV4Y2x1ZGVba2V5XSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cblx0XHRleHBvcnRzOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdFx0dmFyIHJlcyA9IGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG5cdFx0XHRcdG5hbWUgPSByZXMucHJvdG90eXBlLl9jbGFzcztcblx0XHRcdGlmIChuYW1lICYmICFCYXNlLmV4cG9ydHNbbmFtZV0pXG5cdFx0XHRcdEJhc2UuZXhwb3J0c1tuYW1lXSA9IHJlcztcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24ob2JqMSwgb2JqMikge1xuXHRcdFx0ZnVuY3Rpb24gY2hlY2tLZXlzKG8xLCBvMikge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG8xKVxuXHRcdFx0XHRcdGlmIChvMS5oYXNPd25Qcm9wZXJ0eShpKSAmJiAhbzIuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aWYgKG9iajEgJiYgb2JqMS5lcXVhbHMpXG5cdFx0XHRcdHJldHVybiBvYmoxLmVxdWFscyhvYmoyKTtcblx0XHRcdGlmIChvYmoyICYmIG9iajIuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMi5lcXVhbHMob2JqMSk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmoxKSAmJiBBcnJheS5pc0FycmF5KG9iajIpKSB7XG5cdFx0XHRcdGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iajEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyhvYmoxW2ldLCBvYmoyW2ldKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmoxICYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0J1xuXHRcdFx0XHRcdCYmIG9iajIgJiYgdHlwZW9mIG9iajIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmICghY2hlY2tLZXlzKG9iajEsIG9iajIpIHx8ICFjaGVja0tleXMob2JqMiwgb2JqMSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG9iajEpIHtcblx0XHRcdFx0XHRpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKVxuXHRcdFx0XHRcdFx0XHQmJiAhQmFzZS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdHJlYWQ6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdGlmICh0aGlzID09PSBCYXNlKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMucGVlayhsaXN0LCBzdGFydCk7XG5cdFx0XHRcdGxpc3QuX19pbmRleCsrO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZSxcblx0XHRcdFx0cmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcblx0XHRcdFx0aW5kZXggPSBzdGFydCB8fCByZWFkSW5kZXggJiYgbGlzdC5fX2luZGV4IHx8IDA7XG5cdFx0XHRpZiAoIWxlbmd0aClcblx0XHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGggLSBpbmRleDtcblx0XHRcdHZhciBvYmogPSBsaXN0W2luZGV4XTtcblx0XHRcdGlmIChvYmogaW5zdGFuY2VvZiB0aGlzXG5cdFx0XHRcdHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBsZW5ndGggPD0gMSkge1xuXHRcdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgMTtcblx0XHRcdFx0cmV0dXJuIG9iaiAmJiBvcHRpb25zICYmIG9wdGlvbnMuY2xvbmUgPyBvYmouY2xvbmUoKSA6IG9iajtcblx0XHRcdH1cblx0XHRcdG9iaiA9IEJhc2UuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdG9iai5fX3JlYWQgPSB0cnVlO1xuXHRcdFx0b2JqID0gb2JqLmluaXRpYWxpemUuYXBwbHkob2JqLCBpbmRleCA+IDAgfHwgbGVuZ3RoIDwgbGlzdC5sZW5ndGhcblx0XHRcdFx0PyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpbmRleCwgaW5kZXggKyBsZW5ndGgpXG5cdFx0XHRcdDogbGlzdCkgfHwgb2JqO1xuXHRcdFx0aWYgKHJlYWRJbmRleCkge1xuXHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIG9iai5fX3JlYWQ7XG5cdFx0XHRcdG9iai5fX3JlYWQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRwZWVrOiBmdW5jdGlvbihsaXN0LCBzdGFydCkge1xuXHRcdFx0cmV0dXJuIGxpc3RbbGlzdC5fX2luZGV4ID0gc3RhcnQgfHwgbGlzdC5fX2luZGV4IHx8IDBdO1xuXHRcdH0sXG5cblx0XHRyZW1haW46IGZ1bmN0aW9uKGxpc3QpIHtcblx0XHRcdHJldHVybiBsaXN0Lmxlbmd0aCAtIChsaXN0Ll9faW5kZXggfHwgMCk7XG5cdFx0fSxcblxuXHRcdHJlYWRBbGw6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcmVzID0gW10sXG5cdFx0XHRcdGVudHJ5O1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0IHx8IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXMucHVzaChBcnJheS5pc0FycmF5KGVudHJ5ID0gbGlzdFtpXSlcblx0XHRcdFx0XHRcdD8gdGhpcy5yZWFkKGVudHJ5LCAwLCBvcHRpb25zKVxuXHRcdFx0XHRcdFx0OiB0aGlzLnJlYWQobGlzdCwgaSwgb3B0aW9ucywgMSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0cmVhZE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lLCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuXHRcdFx0XHRoYXNPYmplY3QgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGhhc09iamVjdCkge1xuXHRcdFx0XHR2YXIgZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZDtcblx0XHRcdFx0aWYgKCFmaWx0ZXJlZCkge1xuXHRcdFx0XHRcdGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQgPSBCYXNlLmNyZWF0ZShsaXN0WzBdKTtcblx0XHRcdFx0XHRmaWx0ZXJlZC5fZmlsdGVyaW5nID0gbGlzdFswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJlYWQoaGFzT2JqZWN0ID8gW3ZhbHVlXSA6IGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpO1xuXHRcdH0sXG5cblx0XHRnZXROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0dmFyIGFyZyA9IGxpc3RbMF07XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGxpc3QuX2hhc09iamVjdCA9IGxpc3QubGVuZ3RoID09PSAxICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdClcblx0XHRcdFx0cmV0dXJuIG5hbWUgPyBhcmdbbmFtZV0gOiBsaXN0Ll9maWx0ZXJlZCB8fCBhcmc7XG5cdFx0fSxcblxuXHRcdGhhc05hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gISF0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRpc1BsYWluVmFsdWU6IGZ1bmN0aW9uKG9iaiwgYXNTdHJpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iailcblx0XHRcdFx0XHR8fCBhc1N0cmluZyAmJiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcblx0XHR9LFxuXG5cdFx0c2VyaWFsaXplOiBmdW5jdGlvbihvYmosIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHR2YXIgcm9vdCA9ICFkaWN0aW9uYXJ5LFxuXHRcdFx0XHRyZXM7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRvcHRpb25zLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0XHRkaWN0aW9uYXJ5ID0ge1xuXHRcdFx0XHRcdGxlbmd0aDogMCxcblx0XHRcdFx0XHRkZWZpbml0aW9uczoge30sXG5cdFx0XHRcdFx0cmVmZXJlbmNlczoge30sXG5cdFx0XHRcdFx0YWRkOiBmdW5jdGlvbihpdGVtLCBjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHZhciBpZCA9ICcjJyArIGl0ZW0uX2lkLFxuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdO1xuXHRcdFx0XHRcdFx0aWYgKCFyZWYpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0XHRcdFx0dmFyIHJlcyA9IGNyZWF0ZS5jYWxsKGl0ZW0pLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBpdGVtLl9jbGFzcztcblx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRlZmluaXRpb25zW2lkXSA9IHJlcztcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXSA9IFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmogJiYgb2JqLl9zZXJpYWxpemUpIHtcblx0XHRcdFx0cmVzID0gb2JqLl9zZXJpYWxpemUob3B0aW9ucywgZGljdGlvbmFyeSk7XG5cdFx0XHRcdHZhciBuYW1lID0gb2JqLl9jbGFzcztcblx0XHRcdFx0aWYgKG5hbWUgJiYgIWNvbXBhY3QgJiYgIXJlcy5fY29tcGFjdCAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRyZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHRcdGlmIChjb21wYWN0KVxuXHRcdFx0XHRcdHJlcy5fY29tcGFjdCA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChvYmopKSB7XG5cdFx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG9iailcblx0XHRcdFx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdFx0cmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRyZXMgPSBvcHRpb25zLmZvcm1hdHRlci5udW1iZXIob2JqLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMgPSBvYmo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcm9vdCAmJiBkaWN0aW9uYXJ5Lmxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtbJ2RpY3Rpb25hcnknLCBkaWN0aW9uYXJ5LmRlZmluaXRpb25zXSwgcmVzXVxuXHRcdFx0XHRcdDogcmVzO1xuXHRcdH0sXG5cblx0XHRkZXNlcmlhbGl6ZTogZnVuY3Rpb24oanNvbiwgY3JlYXRlLCBfZGF0YSkge1xuXHRcdFx0dmFyIHJlcyA9IGpzb247XG5cdFx0XHRfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBqc29uWzBdLFxuXHRcdFx0XHRcdGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRcdFx0aWYgKCFpc0RpY3Rpb25hcnkpIHtcblx0XHRcdFx0XHRpZiAoX2RhdGEuZGljdGlvbmFyeSAmJiBqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSlcblx0XHRcdFx0XHRcdHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuXHRcdFx0XHRcdHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEpKTtcblx0XHRcdFx0aWYgKGlzRGljdGlvbmFyeSkge1xuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXNbMF07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob2JqLCBvcHRpb25zKSB7XG5cdFx0XHR2YXIganNvbiA9IEJhc2Uuc2VyaWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmFzU3RyaW5nID09PSBmYWxzZVxuXHRcdFx0XHRcdD8ganNvblxuXHRcdFx0XHRcdDogSlNPTi5zdHJpbmdpZnkoanNvbik7XG5cdFx0fSxcblxuXHRcdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24sIHRhcmdldCkge1xuXHRcdFx0cmV0dXJuIEJhc2UuZGVzZXJpYWxpemUoXG5cdFx0XHRcdFx0dHlwZW9mIGpzb24gPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShqc29uKSA6IGpzb24sXG5cdFx0XHRcdFx0ZnVuY3Rpb24odHlwZSwgYXJncykge1xuXHRcdFx0XHRcdFx0dmFyIG9iaiA9IHRhcmdldCAmJiB0YXJnZXQuY29uc3RydWN0b3IgPT09IHR5cGVcblx0XHRcdFx0XHRcdFx0XHQ/IHRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdDogQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpLFxuXHRcdFx0XHRcdFx0XHRpc1RhcmdldCA9IG9iaiA9PT0gdGFyZ2V0O1xuXHRcdFx0XHRcdFx0aWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIG9iaiBpbnN0YW5jZW9mIEl0ZW1cblx0XHRcdFx0XHRcdFx0XHQmJiAoaXNUYXJnZXQgfHwgIShvYmogaW5zdGFuY2VvZiBMYXllcikpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmcgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpXG5cdFx0XHRcdFx0XHRcdFx0YXJnLmluc2VydCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShvYmosIGFyZ3MpO1xuXHRcdFx0XHRcdFx0aWYgKGlzVGFyZ2V0KVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c3BsaWNlOiBmdW5jdGlvbihsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuXHRcdFx0dmFyIGFtb3VudCA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcblx0XHRcdFx0YXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcblx0XHRcdGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKVxuXHRcdFx0XHRpbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcblx0XHRcdFx0aXRlbXNbaV0uX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0XHRsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcblx0XHRcdFx0aWYgKGl0ZW1zKVxuXHRcdFx0XHRcdGFyZ3MucHVzaC5hcHBseShhcmdzLCBpdGVtcyk7XG5cdFx0XHRcdHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGxpc3RbaV0uX2luZGV4ID0gaTtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRjYW1lbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24oYWxsLCBjaHIpIHtcblx0XHRcdFx0cmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGh5cGhlbmF0ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIEVtaXR0ZXIgPSB7XG5cdG9uOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vbihrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdO1xuXHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0XHRcdFx0aGFuZGxlcnMgPSBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuXHRcdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHRcdGlmIChlbnRyeS5pbnN0YWxsICYmIGhhbmRsZXJzLmxlbmd0aCA9PSAxKVxuXHRcdFx0XHRcdFx0ZW50cnkuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub2ZmKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBlbnRyeSA9IHRoaXMuX2V2ZW50VHlwZXNbdHlwZV0sXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0sXG5cdFx0XHRpbmRleDtcblx0XHRpZiAoZW50cnkgJiYgaGFuZGxlcnMpIHtcblx0XHRcdGlmICghZnVuYyB8fCAoaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGZ1bmMpKSAhPT0gLTFcblx0XHRcdFx0XHQmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0aWYgKGVudHJ5LnVuaW5zdGFsbClcblx0XHRcdFx0XHRlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRcdH0gZWxzZSBpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRyZXR1cm4gdGhpcy5vbih0eXBlLCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMub2ZmKHR5cGUsIGZ1bmMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGVtaXQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoIWhhbmRsZXJzKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhpcywgYXJncykgPT09IGZhbHNlXG5cdFx0XHRcdFx0JiYgZXZlbnQgJiYgZXZlbnQuc3RvcCkge1xuXHRcdFx0XHRldmVudC5zdG9wKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZXNwb25kczogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiAhISh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdKTtcblx0fSxcblxuXHRhdHRhY2g6ICcjb24nLFxuXHRkZXRhY2g6ICcjb2ZmJyxcblx0ZmlyZTogJyNlbWl0JyxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24oaW5zdGFsbCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyxcblx0XHRcdGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblx0XHRmb3IgKHZhciB0eXBlIGluIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdGZ1bmMgPSBlbnRyeVtrZXldO1xuXHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRmdW5jLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChzcmMpIHtcblx0XHRcdHZhciBldmVudHMgPSBzcmMuX2V2ZW50cztcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0dmFyIHR5cGVzID0ge307XG5cdFx0XHRcdEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0XHRcdFx0XHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnLFxuXHRcdFx0XHRcdFx0bmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRcdFx0dHlwZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG5cdFx0XHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0XHRcdFx0c3JjWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0c3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJldiA9IHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0XHRpZiAocHJldilcblx0XHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgcHJldik7XG5cdFx0XHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRcdFx0dGhpcy5vbih0eXBlLCBmdW5jKTtcblx0XHRcdFx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBuZXcgQmFzZSh7XG5cdFx0XHRhcHBseU1hdHJpeDogdHJ1ZSxcblx0XHRcdGhhbmRsZVNpemU6IDQsXG5cdFx0XHRoaXRUb2xlcmFuY2U6IDBcblx0XHR9KTtcblx0XHR0aGlzLnByb2plY3QgPSBudWxsO1xuXHRcdHRoaXMucHJvamVjdHMgPSBbXTtcblx0XHR0aGlzLnRvb2xzID0gW107XG5cdFx0dGhpcy5wYWxldHRlcyA9IFtdO1xuXHRcdHRoaXMuX2lkID0gUGFwZXJTY29wZS5faWQrKztcblx0XHRQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcblx0XHR2YXIgcHJvdG8gPSBQYXBlclNjb3BlLnByb3RvdHlwZTtcblx0XHRpZiAoIG5vQ2FudmFzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIXRoaXMuc3VwcG9ydCkge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRwcm90by5zdXBwb3J0ID0ge1xuXHRcdFx0XHRuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuXHRcdFx0XHRuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcblx0XHRcdH07XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmJyb3dzZXIpIHtcblx0XHRcdHZhciBicm93c2VyID0gcHJvdG8uYnJvd3NlciA9IHt9O1xuXHRcdFx0bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXG5cdFx0XHRcdC8ob3BlcmF8Y2hyb21lfHNhZmFyaXx3ZWJraXR8ZmlyZWZveHxtc2llfHRyaWRlbnR8YXRvbSlcXC8/XFxzKihbLlxcZF0rKSg/Oi4qdmVyc2lvblxcLyhbLlxcZF0rKSk/KD86LipydlxcOihbLlxcZF0rKSk/L2csXG5cdFx0XHRcdGZ1bmN0aW9uKGFsbCwgbiwgdjEsIHYyLCBydikge1xuXHRcdFx0XHRcdGlmICghYnJvd3Nlci5jaHJvbWUpIHtcblx0XHRcdFx0XHRcdHZhciB2ID0gbiA9PT0gJ29wZXJhJyA/IHYyIDogdjE7XG5cdFx0XHRcdFx0XHRpZiAobiA9PT0gJ3RyaWRlbnQnKSB7XG5cdFx0XHRcdFx0XHRcdHYgPSBydjtcblx0XHRcdFx0XHRcdFx0biA9ICdtc2llJztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyb3dzZXIudmVyc2lvbiA9IHY7XG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb25OdW1iZXIgPSBwYXJzZUZsb2F0KHYpO1xuXHRcdFx0XHRcdFx0YnJvd3Nlci5uYW1lID0gbjtcblx0XHRcdFx0XHRcdGJyb3dzZXJbbl0gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHRcdGlmIChicm93c2VyLmNocm9tZSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIud2Via2l0O1xuXHRcdFx0aWYgKGJyb3dzZXIuYXRvbSlcblx0XHRcdFx0ZGVsZXRlIGJyb3dzZXIuY2hyb21lO1xuXHRcdH1cblx0fSxcblxuXHR2ZXJzaW9uOiAnMC45LjIxJyxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcblx0XHRWaWV3LnVwZGF0ZUZvY3VzKCk7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdGNvcyA9IE1hdGguY29zLFxuXHRcdFBJID0gTWF0aC5QSSxcblx0XHRUT0xFUkFOQ0UgPSAxZS02LFxuXHRcdEVQU0lMT04gPSAxZS0xMixcblx0XHRNQUNISU5FX0VQU0lMT04gPSAxLjEyZS0xNjtcblxuXHRyZXR1cm4ge1xuXHRcdFRPTEVSQU5DRTogVE9MRVJBTkNFLFxuXHRcdEVQU0lMT046IEVQU0lMT04sXG5cdFx0TUFDSElORV9FUFNJTE9OOiBNQUNISU5FX0VQU0lMT04sXG5cdFx0S0FQUEE6IDQgKiAoc3FydCgyKSAtIDEpIC8gMyxcblxuXHRcdGlzWmVybzogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRyZXR1cm4gYWJzKHZhbCkgPD0gRVBTSUxPTjtcblx0XHR9LFxuXG5cdFx0aW50ZWdyYXRlOiBmdW5jdGlvbihmLCBhLCBiLCBuKSB7XG5cdFx0XHR2YXIgeCA9IGFic2Npc3Nhc1tuIC0gMl0sXG5cdFx0XHRcdHcgPSB3ZWlnaHRzW24gLSAyXSxcblx0XHRcdFx0QSA9IChiIC0gYSkgKiAwLjUsXG5cdFx0XHRcdEIgPSBBICsgYSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdG0gPSAobiArIDEpID4+IDEsXG5cdFx0XHRcdHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7XG5cdFx0XHR3aGlsZSAoaSA8IG0pIHtcblx0XHRcdFx0dmFyIEF4ID0gQSAqIHhbaV07XG5cdFx0XHRcdHN1bSArPSB3W2krK10gKiAoZihCICsgQXgpICsgZihCIC0gQXgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBBICogc3VtO1xuXHRcdH0sXG5cblx0XHRmaW5kUm9vdDogZnVuY3Rpb24oZiwgZGYsIHgsIGEsIGIsIG4sIHRvbGVyYW5jZSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0XHRcdFx0dmFyIGZ4ID0gZih4KSxcblx0XHRcdFx0XHRkeCA9IGZ4IC8gZGYoeCksXG5cdFx0XHRcdFx0bnggPSB4IC0gZHg7XG5cdFx0XHRcdGlmIChhYnMoZHgpIDwgdG9sZXJhbmNlKVxuXHRcdFx0XHRcdHJldHVybiBueDtcblx0XHRcdFx0aWYgKGZ4ID4gMCkge1xuXHRcdFx0XHRcdGIgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA8PSBhID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGEgPSB4O1xuXHRcdFx0XHRcdHggPSBueCA+PSBiID8gKGEgKyBiKSAqIDAuNSA6IG54O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geDtcblx0XHR9LFxuXG5cdFx0c29sdmVRdWFkcmF0aWM6IGZ1bmN0aW9uKGEsIGIsIGMsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGNvdW50ID0gMCxcblx0XHRcdFx0eDEsIHgyID0gSW5maW5pdHksXG5cdFx0XHRcdEIgPSBiLFxuXHRcdFx0XHREO1xuXHRcdFx0YiAvPSAyO1xuXHRcdFx0RCA9IGIgKiBiIC0gYSAqIGM7XG5cdFx0XHRpZiAoYWJzKEQpIDwgTUFDSElORV9FUFNJTE9OKSB7XG5cdFx0XHRcdHZhciBwb3cgPSBNYXRoLnBvdyxcblx0XHRcdFx0XHRnbUMgPSBwb3coYWJzKGEqYipjKSwgMS8zKTtcblx0XHRcdFx0aWYgKGdtQyA8IDFlLTgpIHtcblx0XHRcdFx0XHQvKlxuXHRcdFx0XHRcdCAqIHdlIG11bHRpcGx5IHdpdGggYSBmYWN0b3IgdG8gbm9ybWFsaXplIHRoZVxuXHRcdFx0XHRcdCAqIGNvZWZmaWNpZW50cy4gVGhlIGZhY3RvciBpcyBqdXN0IHRoZSBuZWFyZXN0IGV4cG9uZW50XG5cdFx0XHRcdFx0ICogb2YgMTAsIGJpZyBlbm91Z2ggdG8gcmFpc2UgYWxsIHRoZSBjb2VmZmljaWVudHMgdG9cblx0XHRcdFx0XHQgKiBuZWFybHkgWy0xLCArMV0gcmFuZ2UuXG5cdFx0XHRcdFx0ICovXG5cdFx0XHRcdFx0dmFyIG11bHQgPSBwb3coMTAsIGFicyhcblx0XHRcdFx0XHRcdE1hdGguZmxvb3IoTWF0aC5sb2coZ21DKSAqIE1hdGguTE9HMTBFKSkpO1xuXHRcdFx0XHRcdGlmICghaXNGaW5pdGUobXVsdCkpXG5cdFx0XHRcdFx0XHRtdWx0ID0gMDtcblx0XHRcdFx0XHRhICo9IG11bHQ7XG5cdFx0XHRcdFx0YiAqPSBtdWx0O1xuXHRcdFx0XHRcdGMgKj0gbXVsdDtcblx0XHRcdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFicyhhKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKEIpIDwgTUFDSElORV9FUFNJTE9OKVxuXHRcdFx0XHRcdHJldHVybiBhYnMoYykgPCBNQUNISU5FX0VQU0lMT04gPyAtMSA6IDA7XG5cdFx0XHRcdHgxID0gLWMgLyBCO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKEQgPj0gLU1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHRcdEQgPSBEIDwgMCA/IDAgOiBEO1xuXHRcdFx0XHRcdHZhciBSID0gc3FydChEKTtcblx0XHRcdFx0XHRpZiAoYiA+PSBNQUNISU5FX0VQU0lMT04gJiYgYiA8PSBNQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0XHRcdHgxID0gYWJzKGEpID49IGFicyhjKSA/IFIgLyBhIDogLWMgLyBSO1xuXHRcdFx0XHRcdFx0eDIgPSAteDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBxID0gLShiICsgKGIgPCAwID8gLTEgOiAxKSAqIFIpO1xuXHRcdFx0XHRcdFx0eDEgPSBxIC8gYTtcblx0XHRcdFx0XHRcdHgyID0gYyAvIHE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNGaW5pdGUoeDEpICYmIChtaW4gPT0gbnVsbCB8fCB4MSA+PSBtaW4gJiYgeDEgPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4MTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKG1pbiA9PSBudWxsIHx8IHgyID49IG1pbiAmJiB4MiA8PSBtYXgpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IHgyO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciB4LCBiMSwgYzIsIGNvdW50ID0gMDtcblx0XHRcdGlmIChhID09PSAwKSB7XG5cdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRiMSA9IGM7XG5cdFx0XHRcdGMyID0gZDtcblx0XHRcdFx0eCA9IEluZmluaXR5O1xuXHRcdFx0fSBlbHNlIGlmIChkID09PSAwKSB7XG5cdFx0XHRcdGIxID0gYjtcblx0XHRcdFx0YzIgPSBjO1xuXHRcdFx0XHR4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlYyA9IDEgKyBNQUNISU5FX0VQU0lMT04sXG5cdFx0XHRcdFx0eDAsIHEsIHFkLCB0LCByLCBzLCB0bXA7XG5cdFx0XHRcdHggPSAtKGIgLyBhKSAvIDM7XG5cdFx0XHRcdHRtcCA9IGEgKiB4LFxuXHRcdFx0XHRiMSA9IHRtcCArIGIsXG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyLFxuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdFx0dCA9IHEgL2E7XG5cdFx0XHRcdHIgPSBwb3coYWJzKHQpLCAxLzMpO1xuXHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDE7XG5cdFx0XHRcdHQgPSAtcWQgLyBhO1xuXHRcdFx0XHRyID0gdCA+IDAgPyAxLjMyNDcxNzk1NzIgKiBNYXRoLm1heChyLCBzcXJ0KHQpKSA6IHI7XG5cdFx0XHRcdHgwID0geCAtIHMgKiByO1xuXHRcdFx0XHRpZiAoeDAgIT09IHgpIHtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdFx0XHR0bXAgPSBhICogeCxcblx0XHRcdFx0XHRcdGIxID0gdG1wICsgYixcblx0XHRcdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMixcblx0XHRcdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gZWM7XG5cdFx0XHRcdFx0XHRpZiAoeDAgPT09IHgpIHtcblx0XHRcdFx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cdFx0XHRcdFx0aWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuXHRcdFx0XHRcdFx0YzIgPSAtZCAvIHg7XG5cdFx0XHRcdFx0XHRiMSA9IChjMiAtIGMpIC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwIHx8IHggIT09IHJvb3RzW2NvdW50IC0gMV0pXG5cdFx0XHRcdFx0JiYgKG1pbiA9PSBudWxsIHx8IHggPj0gbWluICYmIHggPD0gbWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSB4O1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnQnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gaGFzWSA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5hbmdsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKGFyZzAuYW5nbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuXHRcdFx0XHQmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueVxuXHRcdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSlcblx0XHRcdFx0dGhpcy5nZXRBbmdsZSgpO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZClcblx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuXHRcdFx0c2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG5cdFx0XHRwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuXHRcdGlmIChzY2FsZSA+PSAwKVxuXHRcdFx0cG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuXHRcdGlmIChhbmdsZSA9PT0gMClcblx0XHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdFx0YW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcblx0XHRcdHMgPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHBvaW50ID0gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIGMgLSBwb2ludC55ICogcyxcblx0XHRcdHBvaW50LnggKiBzICsgcG9pbnQueSAqIGNcblx0XHQpO1xuXHRcdHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlOiBmdW5jdGlvbihwb2ludCwgdG9sZXJhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDwgdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuY3Jvc3MocG9pbnQpKSA8IDFlLTEyO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnModGhpcy5kb3QocG9pbnQpKSA8IDFlLTEyO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocG9pbnQuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoMCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBzY2FsZSA9IHRoaXMuZG90KHBvaW50KSAvIHBvaW50LmRvdChwb2ludCk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRcdHBvaW50LnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1pbihwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5tYXgocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMud2lkdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gYXJnMTtcblx0XHRcdHRoaXMud2lkdGggPSBhcmcyO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBhcmczO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzBbMV07XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzJdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzBbM107XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54IHx8IDA7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueSB8fCAwO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aCB8fCAwO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0IHx8IDA7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFyZWFkKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRvLnggLSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHRvLnkgLSBwb2ludC55O1xuXHRcdFx0XHRpZiAodGhpcy53aWR0aCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnggPSB0by54O1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSAtdGhpcy53aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdG8ueTtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IC10aGlzLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2ZpeFgpXG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSBzaXplLndpZHRoKSAqIHRoaXMuX2ZpeFg7XG5cdFx0aWYgKHRoaXMuX2ZpeFkpXG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcblx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdHRoaXMuX2ZpeFcgPSAxO1xuXHRcdHRoaXMuX2ZpeEggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZml4Vylcblx0XHRcdHRoaXMud2lkdGggLT0gbGVmdCAtIHRoaXMueDtcblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX2ZpeFggPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZml4SClcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRvcCAtIHRoaXMueTtcblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fZml4WSA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICh0aGlzLl9maXhYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WCAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeFcgPSAwO1xuXHRcdGlmICh0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMueDtcblx0XHR0aGlzLl9maXhYID0gMTtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeEggPSAwO1xuXHRcdGlmICh0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0dGhpcy5fZml4WSA9IDE7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuXHRcdHRoaXMuX2ZpeFggPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0dGhpcy5fZml4WSA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0dG91Y2hlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID49IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKHJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlLCBCYXNlLnBpY2socmVjdXJzaXZlbHksIHRydWUpLFxuXHRcdFx0XHRcdF9zZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0dGhpcy5fdHggKz0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYjtcblx0XHR0aGlzLl90eSArPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzY2FsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNjYWxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dGhpcy5fYSAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2MgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9iICo9IHNjYWxlLnk7XG5cdFx0dGhpcy5fZCAqPSBzY2FsZS55O1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdGFuZ2xlICo9IE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSxcblx0XHRcdHggPSBjZW50ZXIueCxcblx0XHRcdHkgPSBjZW50ZXIueSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHR4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuXHRcdFx0dHkgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3MsXG5cdFx0XHRhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZDtcblx0XHR0aGlzLl9hID0gY29zICogYSArIHNpbiAqIGI7XG5cdFx0dGhpcy5fYiA9IC1zaW4gKiBhICsgY29zICogYjtcblx0XHR0aGlzLl9jID0gY29zICogYyArIHNpbiAqIGQ7XG5cdFx0dGhpcy5fZCA9IC1zaW4gKiBjICsgY29zICogZDtcblx0XHR0aGlzLl90eCArPSB0eCAqIGEgKyB0eSAqIGI7XG5cdFx0dGhpcy5fdHkgKz0gdHggKiBjICsgdHkgKiBkO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNoZWFyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YyA9IHRoaXMuX2M7XG5cdFx0dGhpcy5fYSArPSBzaGVhci55ICogdGhpcy5fYjtcblx0XHR0aGlzLl9jICs9IHNoZWFyLnkgKiB0aGlzLl9kO1xuXHRcdHRoaXMuX2IgKz0gc2hlYXIueCAqIGE7XG5cdFx0dGhpcy5fZCArPSBzaGVhci54ICogYztcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2tldzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNrZXcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdHRvUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG5cdFx0XHRzaGVhciA9IG5ldyBQb2ludChNYXRoLnRhbihza2V3LnggKiB0b1JhZGlhbnMpLFxuXHRcdFx0XHRNYXRoLnRhbihza2V3LnkgKiB0b1JhZGlhbnMpKTtcblx0XHRyZXR1cm4gdGhpcy5zaGVhcihzaGVhciwgY2VudGVyKTtcblx0fSxcblxuXHRjb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGMyICogYjE7XG5cdFx0dGhpcy5fYiA9IGIyICogYTEgKyBkMiAqIGIxO1xuXHRcdHRoaXMuX2MgPSBhMiAqIGMxICsgYzIgKiBkMTtcblx0XHR0aGlzLl9kID0gYjIgKiBjMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggKz0gdHgyICogYTEgKyB0eTIgKiBiMTtcblx0XHR0aGlzLl90eSArPSB0eDIgKiBjMSArIHR5MiAqIGQxO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVDb25jYXRlbmF0ZTogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBiMiAqIGMxO1xuXHRcdHRoaXMuX2IgPSBhMiAqIGIxICsgYjIgKiBkMTtcblx0XHR0aGlzLl9jID0gYzIgKiBhMSArIGQyICogYzE7XG5cdFx0dGhpcy5fZCA9IGMyICogYjEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ID0gYTIgKiB0eDEgKyBiMiAqIHR5MSArIHR4Mjtcblx0XHR0aGlzLl90eSA9IGMyICogdHgxICsgZDIgKiB0eTEgKyB0eTI7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNoYWluOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeChcblx0XHRcdFx0YTIgKiBhMSArIGMyICogYjEsXG5cdFx0XHRcdGEyICogYzEgKyBjMiAqIGQxLFxuXHRcdFx0XHRiMiAqIGExICsgZDIgKiBiMSxcblx0XHRcdFx0YjIgKiBjMSArIGQyICogZDEsXG5cdFx0XHRcdHR4MSArIHR4MiAqIGExICsgdHkyICogYjEsXG5cdFx0XHRcdHR5MSArIHR4MiAqIGMxICsgdHkyICogZDEpO1xuXHR9LFxuXG5cdGlzSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hID09PSAxICYmIHRoaXMuX2MgPT09IDAgJiYgdGhpcy5fYiA9PT0gMCAmJiB0aGlzLl9kID09PSAxXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSAwICYmIHRoaXMuX3R5ID09PSAwO1xuXHR9LFxuXG5cdG9yTnVsbElmSWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKSA/IG51bGwgOiB0aGlzO1xuXHR9LFxuXG5cdGlzSW52ZXJ0aWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHRpc1Npbmd1bGFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbiggc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAzXG5cdFx0XHQ/IHRoaXMuX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoc3JjLCBkc3QsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG5cdFx0XHR4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIGRzdCwgY291bnQpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRqID0gMCxcblx0XHRcdG1heCA9IDIgKiBjb3VudDtcblx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0dmFyIHggPSBzcmNbaSsrXSxcblx0XHRcdFx0eSA9IHNyY1tpKytdO1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcblx0XHR9XG5cdFx0cmV0dXJuIGRzdDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCxcblx0XHRcdHkxID0gcmVjdC55LFxuXHRcdFx0eDIgPSB4MSArIHJlY3Qud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRjb29yZHMgPSBbIHgxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5MiBdO1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgNCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG5cdFx0XHRtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBjb29yZHMuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGNvb3Jkc1tpXSxcblx0XHRcdFx0aiA9IGkgJiAxO1xuXHRcdFx0aWYgKHZhbCA8IG1pbltqXSlcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0ZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuXHRcdFx0XHRtYXhbal0gPSB2YWw7XG5cdFx0fVxuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2dldERldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9iICogdGhpcy5fYztcblx0XHRyZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG5cdFx0XHRcdCYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSlcblx0XHRcdFx0PyBkZXQgOiBudWxsO1xuXHR9LFxuXG5cdF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIWRldClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0KHggKiB0aGlzLl9kIC0geSAqIHRoaXMuX2IpIC8gZGV0LFxuXHRcdFx0KHkgKiB0aGlzLl9hIC0geCAqIHRoaXMuX2MpIC8gZGV0LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLCBiID0gdGhpcy5fYiwgYyA9IHRoaXMuX2MsIGQgPSB0aGlzLl9kO1xuXHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGEgKiBkIC0gYiAqIGMpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdGEgLz0gc2NhbGVYO1xuXHRcdGIgLz0gc2NhbGVYO1xuXG5cdFx0dmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcblx0XHRjIC09IGEgKiBzaGVhcjtcblx0XHRkIC09IGIgKiBzaGVhcjtcblxuXHRcdHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0YyAvPSBzY2FsZVk7XG5cdFx0ZCAvPSBzY2FsZVk7XG5cdFx0c2hlYXIgLz0gc2NhbGVZO1xuXG5cdFx0aWYgKGEgKiBkIDwgYiAqIGMpIHtcblx0XHRcdGEgPSAtYTtcblx0XHRcdGIgPSAtYjtcblx0XHRcdHNoZWFyID0gLXNoZWFyO1xuXHRcdFx0c2NhbGVYID0gLXNjYWxlWDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcblx0XHRcdHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG5cdFx0XHRzaGVhcmluZzogc2hlYXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG5cdH0sXG5cblx0Z2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG5cdH0sXG5cblx0aW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcblx0XHRcdFx0dGhpcy5fZCAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2MgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9iIC8gZGV0LFxuXHRcdFx0XHR0aGlzLl9hIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYiAqIHRoaXMuX3R5IC0gdGhpcy5fZCAqIHRoaXMuX3R4KSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuXHR9LFxuXG5cdHNoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdHByb3AgPSAnXycgKyBuYW1lO1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGludGVyc2VjdDogZnVuY3Rpb24oYXB4LCBhcHksIGF2eCwgYXZ5LCBicHgsIGJweSwgYnZ4LCBidnksIGFzVmVjdG9yLFxuXHRcdFx0XHRpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdGF2eCAtPSBhcHg7XG5cdFx0XHRcdGF2eSAtPSBhcHk7XG5cdFx0XHRcdGJ2eCAtPSBicHg7XG5cdFx0XHRcdGJ2eSAtPSBicHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3Jvc3MgPSBhdnggKiBidnkgLSBhdnkgKiBidng7XG5cdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IGFweCAtIGJweCxcblx0XHRcdFx0XHRkeSA9IGFweSAtIGJweSxcblx0XHRcdFx0XHR0YSA9IChidnggKiBkeSAtIGJ2eSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHRiID0gKGF2eCAqIGR5IC0gYXZ5ICogZHgpIC8gY3Jvc3M7XG5cdFx0XHRcdGlmIChpc0luZmluaXRlIHx8IDAgPD0gdGEgJiYgdGEgPD0gMSAmJiAwIDw9IHRiICYmIHRiIDw9IDEpXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHRhcHggKyB0YSAqIGF2eCxcblx0XHRcdFx0XHRcdFx0XHRhcHkgKyB0YSAqIGF2eSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFNpZGU6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdjJ4ID0geCAtIHB4LFxuXHRcdFx0XHR2MnkgPSB5IC0gcHksXG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cdFx0XHRpZiAoY2N3ID09PSAwKSB7XG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ4ICsgdjJ5ICogdnk7XG5cdFx0XHRcdGlmIChjY3cgPiAwKSB7XG5cdFx0XHRcdFx0djJ4IC09IHZ4O1xuXHRcdFx0XHRcdHYyeSAtPSB2eTtcblx0XHRcdFx0XHRjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5O1xuXHRcdFx0XHRcdGlmIChjY3cgPCAwKVxuXHRcdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh2eClcblx0XHRcdFx0XHQ/IHZ5ID49IDAgPyBweCAtIHggOiB4IC0gcHhcblx0XHRcdFx0XHQ6IE51bWVyaWNhbC5pc1plcm8odnkpXG5cdFx0XHRcdFx0XHQ/IHZ4ID49IDAgPyB5IC0gcHkgOiBweSAtIHlcblx0XHRcdFx0XHRcdDogKHZ4ICogKHkgLSBweSkgLSB2eSAqICh4IC0gcHgpKSAvIE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBudWxsO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZSA9IG5ldyBTdHlsZShudWxsLCBudWxsLCB0aGlzKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG5cdFx0aWYgKCFyZW1vdmUuYmFzZS5jYWxsKHRoaXMpKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmICh0aGlzLl92aWV3KVxuXHRcdFx0dGhpcy5fdmlldy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdmlldztcblx0fSxcblxuXHRnZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jdXJyZW50U3R5bGU7XG5cdH0sXG5cblx0c2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuX2N1cnJlbnRTdHlsZS5pbml0aWFsaXplKHN0eWxlKTtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGdldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY29wZS5zZXR0aW5ncztcblx0fSxcblxuXHRnZXRBY3RpdmVMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcih7IHByb2plY3Q6IHRoaXMgfSk7XG5cdH0sXG5cblx0Z2V0U2VsZWN0ZWRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW1zID0gW107XG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fc2VsZWN0ZWRJdGVtcykge1xuXHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHRcdGlmIChpdGVtLmlzSW5zZXJ0ZWQoKSlcblx0XHRcdFx0aXRlbXMucHVzaChpdGVtKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBMYXllcikge1xuXHRcdFx0aXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbaXRlbV0sIGluZGV4LCAwKTtcblx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcywgdHJ1ZSk7XG5cdFx0XHRpZiAodGhpcy5fY2hhbmdlcylcblx0XHRcdFx0aXRlbS5fY2hhbmdlZCg1KTtcblx0XHRcdGlmICghdGhpcy5fYWN0aXZlTGF5ZXIpXG5cdFx0XHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gaXRlbTtcblx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5fYWN0aXZlTGF5ZXJcblx0XHRcdFx0fHwgdGhpcy5pbnNlcnRDaGlsZChpbmRleCwgbmV3IExheWVyKEl0ZW0uTk9fSU5TRVJUKSkpXG5cdFx0XHRcdFx0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRpZiAoaXRlbS5fc2VsZWN0ZWQpIHtcblx0XHRcdGlmIChzZWxlY3RlZEl0ZW1zW2lkXSAhPT0gaXRlbSkge1xuXHRcdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCsrO1xuXHRcdFx0XHRzZWxlY3RlZEl0ZW1zW2lkXSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChzZWxlY3RlZEl0ZW1zW2lkXSA9PT0gaXRlbSkge1xuXHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQtLTtcblx0XHRcdGRlbGV0ZSBzZWxlY3RlZEl0ZW1zW2lkXTtcblx0XHR9XG5cdH0sXG5cblx0c2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZGVzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxlY3RlZEl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcztcblx0XHRmb3IgKHZhciBpIGluIHNlbGVjdGVkSXRlbXMpXG5cdFx0XHRzZWxlY3RlZEl0ZW1zW2ldLnNldEZ1bGx5U2VsZWN0ZWQoZmFsc2UpO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdG9wdGlvbnMgPSBIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcmVzID0gdGhpcy5sYXllcnNbaV0uX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBudWxsLCBudWxsLCB0cnVlKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0dmFyIGxheWVyID0gdGhpcy5fYWN0aXZlTGF5ZXI7XG5cdFx0cmV0dXJuIEJhc2UuaW1wb3J0SlNPTihqc29uLCBsYXllciAmJiBsYXllci5pc0VtcHR5KCkgJiYgbGF5ZXIpO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBwaXhlbFJhdGlvKSB7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbisrO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIHBhcmFtID0gbmV3IEJhc2Uoe1xuXHRcdFx0b2Zmc2V0OiBuZXcgUG9pbnQoMCwgMCksXG5cdFx0XHRwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuXHRcdFx0dmlld01hdHJpeDogbWF0cml4LmlzSWRlbnRpdHkoKSA/IG51bGwgOiBtYXRyaXgsXG5cdFx0XHRtYXRyaWNlczogW25ldyBNYXRyaXgoKV0sXG5cdFx0XHR1cGRhdGVNYXRyaXg6IHRydWVcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGF5ZXJzID0gdGhpcy5sYXllcnMsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bGF5ZXJzW2ldLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblxuXHRcdGlmICh0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA+IDApIHtcblx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRjdHguc3Ryb2tlV2lkdGggPSAxO1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5fc2VsZWN0ZWRJdGVtcyxcblx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdHZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uO1xuXHRcdFx0Zm9yICh2YXIgaWQgaW4gaXRlbXMpXG5cdFx0XHRcdGl0ZW1zW2lkXS5fZHJhd1NlbGVjdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgaXRlbXMsIHZlcnNpb24pO1xuXHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU3ltYm9sID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTeW1ib2wnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFN5bWJvbChpdGVtLCBkb250Q2VudGVyKSB7XG5cdFx0dGhpcy5faWQgPSBTeW1ib2wuX2lkID0gKFN5bWJvbC5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0dGhpcy5wcm9qZWN0LnN5bWJvbHMucHVzaCh0aGlzKTtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5fZGVmaW5pdGlvbl0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHRoaXMucHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9wYXJlbnRTeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9kZWZpbml0aW9uKVxuXHRcdFx0dGhpcy5fZGVmaW5pdGlvbi5fcGFyZW50U3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9wYXJlbnRTeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0cGxhY2U6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBQbGFjZWRTeW1ib2wodGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbCh0aGlzLl9kZWZpbml0aW9uLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRyZXR1cm4gc3ltYm9sID09PSB0aGlzXG5cdFx0XHRcdHx8IHN5bWJvbCAmJiB0aGlzLmRlZmluaXRpb24uZXF1YWxzKHN5bWJvbC5kZWZpbml0aW9uKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRzdGF0aWNzOiB7XG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc3JjKSB7XG5cdFx0XHRpZiAoc3JjLl9zZXJpYWxpemVGaWVsZHMpXG5cdFx0XHRcdHNyYy5fc2VyaWFsaXplRmllbGRzID0gbmV3IEJhc2UoXG5cdFx0XHRcdFx0XHR0aGlzLnByb3RvdHlwZS5fc2VyaWFsaXplRmllbGRzLCBzcmMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Tk9fSU5TRVJUOiB7IGluc2VydDogZmFsc2UgfVxuXHR9LFxuXG5cdF9jbGFzczogJ0l0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcblx0X2JvdW5kc1NlbGVjdGVkOiBmYWxzZSxcblx0X3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdG5hbWU6IG51bGwsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0bWF0cml4OiBuZXcgTWF0cml4KCksXG5cdFx0cGl2b3Q6IG51bGwsXG5cdFx0bG9ja2VkOiBmYWxzZSxcblx0XHR2aXNpYmxlOiB0cnVlLFxuXHRcdGJsZW5kTW9kZTogJ25vcm1hbCcsXG5cdFx0b3BhY2l0eTogMSxcblx0XHRndWlkZTogZmFsc2UsXG5cdFx0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdGNsaXBNYXNrOiBmYWxzZSxcblx0XHRkYXRhOiB7fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7XG5cdH0sXG5cblx0X2luaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzLCBwb2ludCkge1xuXHRcdHZhciBoYXNQcm9wcyA9IHByb3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcyksXG5cdFx0XHRpbnRlcm5hbCA9IGhhc1Byb3BzICYmIHByb3BzLmludGVybmFsID09PSB0cnVlLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0cHJvamVjdCA9IGhhc1Byb3BzICYmIHByb3BzLnByb2plY3QgfHwgcGFwZXIucHJvamVjdDtcblx0XHRpZiAoIWludGVybmFsKVxuXHRcdFx0dGhpcy5faWQgPSBJdGVtLl9pZCA9IChJdGVtLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmICghdGhpcy5fcHJvamVjdCkge1xuXHRcdFx0aWYgKGludGVybmFsIHx8IGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoaGFzUHJvcHMgJiYgcHJvcHMucGFyZW50KSB7XG5cdFx0XHRcdHRoaXMuc2V0UGFyZW50KHByb3BzLnBhcmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQocHJvamVjdC5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKCkpLmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaGFzUHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSwgcGFyZW50OiB0cnVlIH0sIHRydWUpO1xuXHRcdHJldHVybiBoYXNQcm9wcztcblx0fSxcblxuXHRfZXZlbnRzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbW91c2VGbGFncyA9IHtcblx0XHRcdG1vdXNlZG93bjoge1xuXHRcdFx0XHRtb3VzZWRvd246IDEsXG5cdFx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0XHR9LFxuXHRcdFx0bW91c2V1cDoge1xuXHRcdFx0XHRtb3VzZXVwOiAxLFxuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0XHRkb3VibGVjbGljazogMVxuXHRcdFx0fSxcblx0XHRcdG1vdXNlbW92ZToge1xuXHRcdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdFx0bW91c2VlbnRlcjogMSxcblx0XHRcdFx0bW91c2VsZWF2ZTogMVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgbW91c2VFdmVudCA9IHtcblx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5nZXRWaWV3KCkuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKSB7XG5cdFx0XHRcdFx0XHRjb3VudGVyc1trZXldID0gKGNvdW50ZXJzW2tleV0gfHwgMClcblx0XHRcdFx0XHRcdFx0XHQrIChtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuZ2V0VmlldygpLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncylcblx0XHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gLT0gbW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0cmV0dXJuIEJhc2UuZWFjaChbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXSxcblx0XHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IG1vdXNlRXZlbnQ7XG5cdFx0XHR9LCB7XG5cdFx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKHRydWUpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FuaW1hdGVJdGVtKGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0b25Mb2FkOiB7fVxuXHRcdFx0fVxuXHRcdCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihhbmltYXRlKSB7XG5cdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGFuaW1hdGUpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9wYXJlbnRTeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPVxuXHRcdFx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY2FjaGVQYXJlbnRcblx0XHRcdFx0JiYgKGZsYWdzICYgNDApKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMikge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb2plY3QuX2NoYW5nZXMpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gcHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdO1xuXHRcdFx0XHRpZiAoZW50cnkpIHtcblx0XHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbnRyeSA9IHsgaXRlbTogdGhpcywgZmxhZ3M6IGZsYWdzIH07XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdID0gZW50cnk7XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlcy5wdXNoKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3ltYm9sKVxuXHRcdFx0c3ltYm9sLl9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKHByb3BzKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9LFxuXG5cdGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9LFxuXG5cdHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUsIHVuaXF1ZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKG5hbWUgJiYgcGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRvcmlnID0gbmFtZSxcblx0XHRcdFx0aSA9IDE7XG5cdFx0XHR3aGlsZSAodW5pcXVlICYmIGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgxMjgpO1xuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3R5bGU7XG5cdH0sXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0fTtcblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXNbbmFtZV0pIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKG5hbWUgPT09ICdfbG9ja2VkJ1xuXHRcdFx0XHRcdFx0PyAxMjggOiAxMjkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG57fSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2xvY2tlZDogZmFsc2UsXG5cblx0X3Zpc2libGU6IHRydWUsXG5cblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cblx0X29wYWNpdHk6IDEsXG5cblx0X2d1aWRlOiBmYWxzZSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG5vQ2hpbGRyZW4pIHtcblx0XHRpZiAoIW5vQ2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0aWYgKChzZWxlY3RlZCA9ICEhc2VsZWN0ZWQpIF4gdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll91cGRhdGVTZWxlY3Rpb24odGhpcyk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWxlY3RlZDogZmFsc2UsXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoIWNoaWxkcmVuW2ldLmlzRnVsbHlTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdHJ1ZSk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgxMDI0KTtcblx0XHR9XG5cdH0sXG5cblx0X2NsaXBNYXNrOiBmYWxzZSxcblxuXHRnZXREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2RhdGEpXG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH0sXG5cblx0c2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHR9LFxuXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbixcblx0XHRcdGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdGlmICghcG9zaXRpb24pIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiA9IHBpdm90XG5cdFx0XHRcdFx0PyB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgY3Rvcihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB0aGlzLCAnc2V0UG9zaXRpb24nKTtcblx0fSxcblxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLnN1YnRyYWN0KHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fSxcblxuXHRnZXRQaXZvdDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0aWYgKHBpdm90KSB7XG5cdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRwaXZvdCA9IG5ldyBjdG9yKHBpdm90LngsIHBpdm90LnksIHRoaXMsICdzZXRQaXZvdCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl2b3Q7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9waXZvdDogbnVsbCxcblxuXHRnZXRSZWdpc3RyYXRpb246ICcjZ2V0UGl2b3QnLFxuXHRzZXRSZWdpc3RyYXRpb246ICcjc2V0UGl2b3QnXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgeDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkLl92aXNpYmxlICYmICFjaGlsZC5pc0VtcHR5KCkpIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBjaGlsZC5fZ2V0Q2FjaGVkQm91bmRzKGdldHRlcixcblx0XHRcdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksIGNhY2hlSXRlbSk7XG5cdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdHgyID0gTWF0aC5tYXgocmVjdC54ICsgcmVjdC53aWR0aCwgeDIpO1xuXHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0PyBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSlcblx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCk7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0aWYgKHJlY3Qud2lkdGggIT0gYm91bmRzLndpZHRoIHx8IHJlY3QuaGVpZ2h0ICE9IGJvdW5kcy5oZWlnaHQpIHtcblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAxLFxuXHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQgIT0gMCA/IHJlY3QuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCA6IDEpO1xuXHRcdH1cblx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZSgtY2VudGVyLngsIC1jZW50ZXIueSk7XG5cdFx0dGhpcy50cmFuc2Zvcm0obWF0cml4KTtcblx0fSxcblxuXHRfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtLCBpbnRlcm5hbEdldHRlcikge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHZhciBfbWF0cml4ID0gaW50ZXJuYWxHZXR0ZXIgPyBudWxsIDogdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdGNhY2hlID0gKCFtYXRyaXggfHwgbWF0cml4LmVxdWFscyhfbWF0cml4KSkgJiYgZ2V0dGVyO1xuXHRcdHZhciBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnRTeW1ib2w7XG5cdFx0aWYgKGNhY2hlUGFyZW50KSB7XG5cdFx0XHR2YXIgaWQgPSBjYWNoZUl0ZW0uX2lkLFxuXHRcdFx0XHRyZWYgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgPSBjYWNoZVBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdGlkczoge30sXG5cdFx0XHRcdFx0bGlzdDogW11cblx0XHRcdFx0fTtcblx0XHRcdGlmICghcmVmLmlkc1tpZF0pIHtcblx0XHRcdFx0cmVmLmxpc3QucHVzaChjYWNoZUl0ZW0pO1xuXHRcdFx0XHRyZWYuaWRzW2lkXSA9IGNhY2hlSXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhY2hlICYmIHRoaXMuX2JvdW5kcyAmJiB0aGlzLl9ib3VuZHNbY2FjaGVdKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2JvdW5kc1tjYWNoZV0uY2xvbmUoKTtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzKGludGVybmFsR2V0dGVyIHx8IGdldHRlcixcblx0XHRcdFx0bWF0cml4IHx8IF9tYXRyaXgsIGNhY2hlSXRlbSk7XG5cdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgY2FjaGVkID0gdGhpcy5fYm91bmRzW2NhY2hlXSA9IGJvdW5kcy5jbG9uZSgpO1xuXHRcdFx0Y2FjaGVkLl9pbnRlcm5hbCA9ICEhaW50ZXJuYWxHZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBvdGhlciA9IGxpc3RbaV07XG5cdFx0XHRcdFx0aWYgKG90aGVyICE9PSBpdGVtKSB7XG5cdFx0XHRcdFx0XHRvdGhlci5fYm91bmRzID0gb3RoZXIuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyLl9ib3VuZHNDYWNoZSlcblx0XHRcdFx0XHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShvdGhlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbn0pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9kZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWNvbXBvc2VkID0gdGhpcy5fbWF0cml4LmRlY29tcG9zZSgpO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCk7XG5cdFx0cmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5yb3RhdGlvbjtcblx0fSxcblxuXHRzZXRSb3RhdGlvbjogZnVuY3Rpb24ocm90YXRpb24pIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0Um90YXRpb24oKTtcblx0XHRpZiAoY3VycmVudCAhPSBudWxsICYmIHJvdGF0aW9uICE9IG51bGwpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMucm90YXRlKHJvdGF0aW9uIC0gY3VycmVudCk7XG5cdFx0XHRkZWNvbXBvc2VkLnJvdGF0aW9uID0gcm90YXRpb247XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpLFxuXHRcdFx0c2NhbGluZyA9IGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nLFxuXHRcdFx0Y3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIHNjYWxpbmcgJiYgbmV3IGN0b3Ioc2NhbGluZy54LCBzY2FsaW5nLnksIHRoaXMsICdzZXRTY2FsaW5nJyk7XG5cdH0sXG5cblx0c2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFNjYWxpbmcoKTtcblx0XHRpZiAoY3VycmVudCkge1xuXHRcdFx0dmFyIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSB9KSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHRcdGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmluaXRpYWxpemUobWF0cml4KTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguX3VwZGF0ZVZlcnNpb24gIT09IHVwZGF0ZVZlcnNpb24pXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdGlmICghbWF0cml4KSB7XG5cdFx0XHRtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG5cdH0sXG5cblx0c2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xuXHRcdGlmICh0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmICEhdHJhbnNmb3JtKVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uIF9pbnN0YWxsRXZlbnRzKGluc3RhbGwpIHtcblx0XHRfaW5zdGFsbEV2ZW50cy5iYXNlLmNhbGwodGhpcywgaW5zdGFsbCk7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5faW5zdGFsbEV2ZW50cyhpbnN0YWxsKTtcblx0fSxcblxuXHRnZXRMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgTGF5ZXIpXG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudDtcblx0fSxcblxuXHRzZXRQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRnZXRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuXHR9LFxuXG5cdHNldENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcykge1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHR0aGlzLmFkZENoaWxkcmVuKGl0ZW1zKTtcblx0fSxcblxuXHRnZXRGaXJzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bMF0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRMYXN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblt0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxXVxuXHRcdFx0XHR8fCBudWxsO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fY2hpbGRyZW5bdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID09PSB0aGlzIHx8IGl0ZW0gJiYgdGhpcy5fY2xhc3MgPT09IGl0ZW0uX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSlcblx0XHRcdFx0JiYgdGhpcy5fbWF0cml4LmVxdWFscyhpdGVtLl9tYXRyaXgpXG5cdFx0XHRcdCYmIHRoaXMuX2xvY2tlZCA9PT0gaXRlbS5fbG9ja2VkXG5cdFx0XHRcdCYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGVcblx0XHRcdFx0JiYgdGhpcy5fYmxlbmRNb2RlID09PSBpdGVtLl9ibGVuZE1vZGVcblx0XHRcdFx0JiYgdGhpcy5fb3BhY2l0eSA9PT0gaXRlbS5fb3BhY2l0eVxuXHRcdFx0XHQmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2tcblx0XHRcdFx0JiYgdGhpcy5fZ3VpZGUgPT09IGl0ZW0uX2d1aWRlXG5cdFx0XHRcdCYmIHRoaXMuX2VxdWFscyhpdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX2NoaWxkcmVuLCBpdGVtLl9jaGlsZHJlbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbihjb3B5LCBpbnNlcnQpIHtcblx0XHRjb3B5LnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb3B5LmFkZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Lmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLFxuXHRcdFx0XHQnX2NsaXBNYXNrJywgJ19ndWlkZScsICdfYXBwbHlNYXRyaXgnXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdGNvcHlba2V5XSA9IHRoaXNba2V5XTtcblx0XHR9XG5cdFx0Y29weS5fbWF0cml4LmluaXRpYWxpemUodGhpcy5fbWF0cml4KTtcblx0XHRjb3B5Ll9kYXRhID0gdGhpcy5fZGF0YSA/IEJhc2UuY2xvbmUodGhpcy5fZGF0YSkgOiBudWxsO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0Y29weS5zZXROYW1lKHRoaXMuX25hbWUsIHRydWUpO1xuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24oaXRlbU9yUHJvamVjdCkge1xuXHRcdHJldHVybiBpdGVtT3JQcm9qZWN0LmFkZENoaWxkKHRoaXMuY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRyYXN0ZXJpemU6IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcblx0XHRcdHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuXHRcdFx0dG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcblx0XHRcdGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyBtYXRyaWNlczogW21hdHJpeF0gfSkpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRDYW52YXMoY2FudmFzKTtcblx0XHRyYXN0ZXIudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUodG9wTGVmdC5hZGQoc2l6ZS5kaXZpZGUoMikpKVxuXHRcdFx0XHQuc2NhbGUoMSAvIHNjYWxlKSk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2NvbnRhaW5zKFxuXHRcdFx0XHR0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9jaGlsZHJlbltpXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0luc2lkZSh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzLmdldEJvdW5kcygpKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRyZWN0YW5nbGU6IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSxcblx0XHRcdG1hdHJpeDogdGhpcy5fbWF0cml4LFxuXHRcdFx0aW5zZXJ0OiBmYWxzZSxcblx0XHR9KTtcblx0fSxcblxuXHRpbnRlcnNlY3RzOiBmdW5jdGlvbihpdGVtLCBfbWF0cml4KSB7XG5cdFx0aWYgKCEoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLl9hc1BhdGhJdGVtKCkuZ2V0SW50ZXJzZWN0aW9ucyhpdGVtLl9hc1BhdGhJdGVtKCksXG5cdFx0XHRcdF9tYXRyaXggfHwgaXRlbS5fbWF0cml4KS5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGhpdFRlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oaXRUZXN0KFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKSk7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKHRoaXMuX2xvY2tlZCB8fCAhdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9ndWlkZSAmJiAhb3B0aW9ucy5ndWlkZXNcblx0XHRcdFx0fHwgdGhpcy5pc0VtcHR5KCkpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRwYXJlbnRUb3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4LFxuXHRcdFx0dmlldyA9IHRoaXMuZ2V0VmlldygpLFxuXHRcdFx0dG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCA9IHBhcmVudFRvdGFsTWF0cml4XG5cdFx0XHRcdFx0PyBwYXJlbnRUb3RhbE1hdHJpeC5jaGFpbihtYXRyaXgpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLnByZUNvbmNhdGVuYXRlKHZpZXcuX21hdHJpeCksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZygxLCB0b3RhbE1hdHJpeC5pbnZlcnRlZCgpKVxuXHRcdFx0XHRcdCkubXVsdGlwbHkoXG5cdFx0XHRcdFx0XHRNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMC4wMDAwMDEpXG5cdFx0XHRcdFx0KTtcblx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEludGVybmFsUm91Z2hCb3VuZHMoKVxuXHRcdFx0XHQuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuXHRcdFx0XHR8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZFxuXHRcdFx0XHR8fCBvcHRpb25zLnR5cGUgJiYgb3B0aW9ucy50eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0fHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdHJlcztcblxuXHRcdGZ1bmN0aW9uIGNoZWNrQm91bmRzKHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IGJvdW5kc1snZ2V0JyArIHBhcnRdKCk7XG5cdFx0XHRpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSlcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCxcblx0XHRcdFx0XHRcdHsgbmFtZTogQmFzZS5oeXBoZW5hdGUocGFydCksIHBvaW50OiBwdCB9KTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tTZWxmICYmIChvcHRpb25zLmNlbnRlciB8fCBvcHRpb25zLmJvdW5kcykgJiYgdGhpcy5fcGFyZW50KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuXHRcdFx0aWYgKG9wdGlvbnMuY2VudGVyKVxuXHRcdFx0XHRyZXMgPSBjaGVja0JvdW5kcygnY2VudGVyJywgJ0NlbnRlcicpO1xuXHRcdFx0aWYgKCFyZXMgJiYgb3B0aW9ucy5ib3VuZHMpIHtcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKVxuXHRcdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdib3VuZHMnLCBwb2ludHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9ICFyZXMgJiYgdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHR2YXIgb3B0cyA9IHRoaXMuX2dldENoaWxkSGl0VGVzdE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmICFyZXM7IGktLSlcblx0XHRcdFx0cmVzID0gY2hpbGRyZW5baV0uX2hpdFRlc3QocG9pbnQsIG9wdHMpO1xuXHRcdH1cblx0XHRpZiAoIXJlcyAmJiBjaGVja1NlbGYpXG5cdFx0XHRyZXMgPSB0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpXG5cdFx0XHRyZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG5cdFx0b3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeDtcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcblx0fSxcblxuXHRtYXRjaGVzOiBmdW5jdGlvbihuYW1lLCBjb21wYXJlKSB7XG5cdFx0ZnVuY3Rpb24gbWF0Y2hPYmplY3Qob2JqMSwgb2JqMikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dmFyIHZhbDEgPSBvYmoxW2ldLFxuXHRcdFx0XHRcdFx0dmFsMiA9IG9iajJbaV07XG5cdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG5cdFx0XHRcdGlmIChuYW1lLmhhc093blByb3BlcnR5KGtleSkgJiYgIXRoaXMubWF0Y2hlcyhrZXksIG5hbWVba2V5XSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdFx0PyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKClcblx0XHRcdFx0XHQ6IG5hbWUgPT09ICd0eXBlJ1xuXHRcdFx0XHRcdFx0PyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogdGhpc1tuYW1lXTtcblx0XHRcdGlmICgvXihjb25zdHJ1Y3RvcnxjbGFzcykkLy50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBjb21wYXJlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlKHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KGNvbXBhcmUsIHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBtYXRjaCwgdGhpcy5fbWF0cml4LCBudWxsLCB0cnVlKVxuXHRcdFx0XHRbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoY2hpbGRyZW4sIG1hdGNoLCBtYXRyaXgsIHBhcmFtLFxuXHRcdFx0XHRmaXJzdE9ubHkpIHtcblx0XHRcdGlmICghcGFyYW0pIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBwaW5nID0gbWF0Y2gub3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0aW5zaWRlID0gbWF0Y2guaW5zaWRlLFxuXHRcdFx0XHRcdGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcblx0XHRcdFx0XHRyZWN0ID1cdGJvdW5kcyAmJiBSZWN0YW5nbGUucmVhZChbYm91bmRzXSk7XG5cdFx0XHRcdHBhcmFtID0ge1xuXHRcdFx0XHRcdGl0ZW1zOiBbXSxcblx0XHRcdFx0XHRpbnNpZGU6IHJlY3QsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmc6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGJvdW5kcylcblx0XHRcdFx0XHRtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcblx0XHRcdFx0XHRcdFx0eyBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlIH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGl0ZW1zID0gcGFyYW0uaXRlbXMsXG5cdFx0XHRcdGluc2lkZSA9IHBhcmFtLmluc2lkZSxcblx0XHRcdFx0b3ZlcmxhcHBpbmcgPSBwYXJhbS5vdmVybGFwcGluZztcblx0XHRcdG1hdHJpeCA9IGluc2lkZSAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGluc2lkZSkge1xuXHRcdFx0XHRcdHZhciBib3VuZHMgPSBjaGlsZC5nZXRCb3VuZHMoY2hpbGRNYXRyaXgpO1xuXHRcdFx0XHRcdGlmICghaW5zaWRlLmludGVyc2VjdHMoYm91bmRzKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmICghKGluc2lkZSAmJiBpbnNpZGUuY29udGFpbnMoYm91bmRzKSkgJiYgIShvdmVybGFwcGluZ1xuXHRcdFx0XHRcdFx0XHQmJiBvdmVybGFwcGluZy5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKVxuXHRcdFx0XHRcdFx0YWRkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFkZCAmJiBjaGlsZC5tYXRjaGVzKG1hdGNoKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdGlmIChmaXJzdE9ubHkpXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRfZ2V0SXRlbXMoY2hpbGQuX2NoaWxkcmVuLCBtYXRjaCxcblx0XHRcdFx0XHRcdGNoaWxkTWF0cml4LCBwYXJhbSxcblx0XHRcdFx0XHRcdGZpcnN0T25seSk7XG5cdFx0XHRcdGlmIChmaXJzdE9ubHkgJiYgaXRlbXMubGVuZ3RoID4gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9XG5cdH1cbn0sIHtcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dmFyIHJlcyA9IEJhc2UuaW1wb3J0SlNPTihqc29uLCB0aGlzKTtcblx0XHRyZXR1cm4gcmVzICE9PSB0aGlzXG5cdFx0XHRcdD8gdGhpcy5hZGRDaGlsZChyZXMpXG5cdFx0XHRcdDogcmVzO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHR2YXIgcmVzID0gaXRlbSA/IHRoaXMuaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIFtpdGVtXSwgX3ByZXNlcnZlKSA6IG51bGw7XG5cdFx0cmV0dXJuIHJlcyAmJiByZXNbMF07XG5cdH0sXG5cblx0YWRkQ2hpbGRyZW46IGZ1bmN0aW9uKGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZHJlbih0aGlzLl9jaGlsZHJlbi5sZW5ndGgsIGl0ZW1zLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSwgX3Byb3RvKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdGl0ZW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGl0ZW1zKTtcblx0XHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpZiAoX3Byb3RvICYmICEoaXRlbSBpbnN0YW5jZW9mIF9wcm90bykpIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHNoaWZ0ID0gaXRlbS5fcGFyZW50ID09PSB0aGlzICYmIGl0ZW0uX2luZGV4IDwgaW5kZXg7XG5cdFx0XHRcdFx0aWYgKGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSkgJiYgc2hpZnQpXG5cdFx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0bm90aWZ5U2VsZiA9IHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cdFx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcy5fcHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtLl9uYW1lKVxuXHRcdFx0XHRcdGl0ZW0uc2V0TmFtZShpdGVtLl9uYW1lKTtcblx0XHRcdFx0aWYgKG5vdGlmeVNlbGYpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtcyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnRcblx0XHRcdFx0PyB0aGlzLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGluc2VydEFib3ZlOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gaXRlbS5faW5zZXJ0U2libGluZyhpdGVtLl9pbmRleCArIDEsIHRoaXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QmVsb3c6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiBpdGVtLl9pbnNlcnRTaWJsaW5nKGl0ZW0uX2luZGV4LCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5fcGFyZW50IHx8IHRoaXMgaW5zdGFuY2VvZiBMYXllciAmJiB0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHQuaW5zZXJ0Q2hpbGQoMCwgdGhpcyk7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BhcmVudCB8fCB0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcy5fcHJvamVjdClcblx0XHRcdFx0LmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG5cblx0YXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG5cdH0sXG5cblx0bW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcblxuXHRtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuXG5cdHJlZHVjZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bMF0ucmVkdWNlKCk7XG5cdFx0XHRjaGlsZC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdGNoaWxkLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9yZW1vdmVOYW1lZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRuYW1lID0gdGhpcy5fbmFtZSxcblx0XHRcdFx0bmFtZWRBcnJheSA9IG5hbWVkQ2hpbGRyZW5bbmFtZV0sXG5cdFx0XHRcdGluZGV4ID0gbmFtZWRBcnJheSA/IG5hbWVkQXJyYXkuaW5kZXhPZih0aGlzKSA6IC0xO1xuXHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRpZiAoY2hpbGRyZW5bbmFtZV0gPT0gdGhpcylcblx0XHRcdFx0XHRkZWxldGUgY2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdG5hbWVkQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0aWYgKG5hbWVkQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSBuYW1lZEFycmF5W25hbWVkQXJyYXkubGVuZ3RoIC0gMV07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVsZXRlIG5hbWVkQ2hpbGRyZW5bbmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24obm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKVxuXHRcdFx0XHRCYXNlLnNwbGljZShwYXJlbnQuX2NoaWxkcmVuLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmKSB7XG5cdFx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRcdFx0aWYgKHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vdGlmeVBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jaGFuZ2VkKDExKTtcblx0XHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBvayA9IGl0ZW0gJiYgaXRlbS5pbnNlcnRCZWxvdyh0aGlzKTtcblx0XHRpZiAob2spXG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdHJldHVybiBvaztcblx0fSxcblxuXHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcblx0XHR2YXIgcmVtb3ZlZCA9IEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBudWxsLCBmcm9tLCB0byAtIGZyb20pO1xuXHRcdGZvciAodmFyIGkgPSByZW1vdmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRyZW1vdmVkW2ldLl9yZW1vdmUodHJ1ZSwgZmFsc2UpO1xuXHRcdH1cblx0XHRpZiAocmVtb3ZlZC5sZW5ndGggPiAwKVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlQ2hpbGRyZW4nLFxuXG5cdHJldmVyc2VDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbi5yZXZlcnNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uX2luZGV4ID0gaTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH1cblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbSA9IHRoaXM7XG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmICghaXRlbS5fdmlzaWJsZSB8fCBpdGVtLl9sb2NrZWQpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdGl0ZW0gPSBpdGVtLl9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzRmlsbCgpO1xuXHR9LFxuXG5cdGhhc1N0cm9rZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTdHJva2UoKTtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU2hhZG93KCk7XG5cdH0sXG5cblx0X2dldE9yZGVyOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0ZnVuY3Rpb24gZ2V0TGlzdChpdGVtKSB7XG5cdFx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXN0LnVuc2hpZnQoaXRlbSk7XG5cdFx0XHR9IHdoaWxlIChpdGVtID0gaXRlbS5fcGFyZW50KTtcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblx0XHR2YXIgbGlzdDEgPSBnZXRMaXN0KHRoaXMpLFxuXHRcdFx0bGlzdDIgPSBnZXRMaXN0KGl0ZW0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4obGlzdDEubGVuZ3RoLCBsaXN0Mi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAobGlzdDFbaV0gIT0gbGlzdDJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGxpc3QxW2ldLl9pbmRleCA8IGxpc3QyW2ldLl9pbmRleCA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0aGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaXNJbnNlcnRlZCgpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNBYm92ZTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gLTE7XG5cdH0sXG5cblx0aXNCZWxvdzogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9nZXRPcmRlcihpdGVtKSA9PT0gMTtcblx0fSxcblxuXHRpc1BhcmVudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPT09IGl0ZW07XG5cdH0sXG5cblx0aXNDaGlsZDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtICYmIGl0ZW0uX3BhcmVudCA9PT0gdGhpcztcblx0fSxcblxuXHRpc0Rlc2NlbmRhbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcztcblx0XHR3aGlsZSAocGFyZW50ID0gcGFyZW50Ll9wYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQgPT0gaXRlbSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0FuY2VzdG9yOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gPyBpdGVtLmlzRGVzY2VuZGFudCh0aGlzKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQuX3BhcmVudFxuXHRcdFx0XHQmJiAvXihHcm91cHxMYXllcnxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKVxuXHRcdFx0XHQmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KCkucm90YXRlKGFuZ2xlLFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cywgMSwgeyByZWFkTnVsbDogdHJ1ZSB9KVxuXHRcdFx0XHRcdHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fVxufSwgQmFzZS5lYWNoKFsnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW25hbWVdKHBvaW50LFxuXHRcdFx0XHRjZW50ZXIgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9O1xufSwge1xuXG59KSwge1xuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCwgX2FwcGx5TWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSxcblx0XHRcdF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG5cdFx0XHRcdFx0JiYgKCghX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgbWF0cml4KVxuXHRcdFx0XHRcdFx0fHwgX2FwcGx5TWF0cml4ICYmIF9hcHBseVJlY3Vyc2l2ZWx5ICYmIHRoaXMuX2NoaWxkcmVuKTtcblx0XHRpZiAoIW1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0X21hdHJpeC5wcmVDb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdGlmIChhcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4ICYmIHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCxcblx0XHRcdFx0XHRfYXBwbHlSZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSkge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3QsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcih0cnVlKSxcblx0XHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcblx0XHRcdGlmIChwaXZvdClcblx0XHRcdFx0X21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QsIHBpdm90LCB0cnVlKTtcblx0XHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRcdGZpbGxDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRpZiAoc3Ryb2tlQ29sb3IpXG5cdFx0XHRcdHN0cm9rZUNvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0XHRpZiAoX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4KVxuXHRcdFx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0dmFyIGRlY29tcCA9IGJvdW5kcyAmJiBtYXRyaXggJiYgbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdGlmIChkZWNvbXAgJiYgIWRlY29tcC5zaGVhcmluZyAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGJvdW5kc1trZXldO1xuXHRcdFx0XHRpZiAoYXBwbHlNYXRyaXggfHwgIXJlY3QuX2ludGVybmFsKVxuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGdldHRlciA9IHRoaXMuX2JvdW5kc0dldHRlcixcblx0XHRcdFx0cmVjdCA9IGJvdW5kc1tnZXR0ZXIgJiYgZ2V0dGVyLmdldEJvdW5kcyB8fCBnZXR0ZXIgfHwgJ2dldEJvdW5kcyddO1xuXHRcdFx0aWYgKHJlY3QpXG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXggJiYgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUsIGFwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRcdFx0XHRzZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl9pbnZlcnNlVHJhbnNmb3JtKFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9HbG9iYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cGFyZW50VG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9QYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Zml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcblx0XHRyZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0aXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcblx0XHRcdHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG5cdFx0XHRzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKVxuXHRcdFx0XHRcdD8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0OiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcblx0XHRcdG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksXG5cdFx0XHRcdFx0bmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuXHRcdG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcblx0XHR0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuXHR9LFxuXG5cdF9zZXRTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKCksXG5cdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCk7XG5cdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdGlmIChzdHJva2VDb2xvcikge1xuXHRcdFx0dmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcblx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDApIHtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdHZhciBzdHJva2VKb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0XHRcdHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdGlmIChzdHJva2VKb2luKVxuXHRcdFx0XHRcdGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG5cdFx0XHRcdGlmIChzdHJva2VDYXApXG5cdFx0XHRcdFx0Y3R4LmxpbmVDYXAgPSBzdHJva2VDYXA7XG5cdFx0XHRcdGlmIChtaXRlckxpbWl0KVxuXHRcdFx0XHRcdGN0eC5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblx0XHRcdFx0aWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuXHRcdFx0XHRcdHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0XHRcdGRhc2hPZmZzZXQgPSBzdHlsZS5nZXREYXNoT2Zmc2V0KCk7XG5cdFx0XHRcdFx0aWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaCA9IGRhc2hBcnJheTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2hhZG93Q29sb3IpIHtcblx0XHRcdHZhciBzaGFkb3dCbHVyID0gc3R5bGUuZ2V0U2hhZG93Qmx1cigpO1xuXHRcdFx0aWYgKHNoYWRvd0JsdXIgPiAwKSB7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LnNoYWRvd0JsdXIgPSBzaGFkb3dCbHVyO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRTaGFkb3dPZmZzZXQoKTtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFggPSBvZmZzZXQueDtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fb3BhY2l0eSA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0Z2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uY2hhaW4obWF0cml4KTtcblx0XHRpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdHJldHVybjtcblxuXHRcdGZ1bmN0aW9uIGdldFZpZXdNYXRyaXgobWF0cml4KSB7XG5cdFx0XHRyZXR1cm4gdmlld01hdHJpeCA/IHZpZXdNYXRyaXguY2hhaW4obWF0cml4KSA6IG1hdHJpeDtcblx0XHR9XG5cblx0XHRtYXRyaWNlcy5wdXNoKGdsb2JhbE1hdHJpeCk7XG5cdFx0aWYgKHBhcmFtLnVwZGF0ZU1hdHJpeCkge1xuXHRcdFx0Z2xvYmFsTWF0cml4Ll91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IGdsb2JhbE1hdHJpeDtcblx0XHR9XG5cblx0XHR2YXIgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlLFxuXHRcdFx0b3BhY2l0eSA9IHRoaXMuX29wYWNpdHksXG5cdFx0XHRub3JtYWxCbGVuZCA9IGJsZW5kTW9kZSA9PT0gJ25vcm1hbCcsXG5cdFx0XHRuYXRpdmVCbGVuZCA9IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1tibGVuZE1vZGVdLFxuXHRcdFx0ZGlyZWN0ID0gbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA9PT0gMVxuXHRcdFx0XHRcdHx8IHBhcmFtLmRvbnRTdGFydFxuXHRcdFx0XHRcdHx8IHBhcmFtLmNsaXBcblx0XHRcdFx0XHR8fCAobmF0aXZlQmxlbmQgfHwgbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA8IDEpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLl9jYW5Db21wb3NpdGUoKSxcblx0XHRcdHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvLFxuXHRcdFx0bWFpbkN0eCwgaXRlbU9mZnNldCwgcHJldk9mZnNldDtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSk7XG5cdFx0XHRpZiAoIWJvdW5kcy53aWR0aCB8fCAhYm91bmRzLmhlaWdodClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0cHJldk9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGl0ZW1PZmZzZXQgPSBwYXJhbS5vZmZzZXQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCk7XG5cdFx0XHRtYWluQ3R4ID0gY3R4O1xuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChib3VuZHMuZ2V0U2l6ZSgpLmNlaWwoKS5hZGQoMSlcblx0XHRcdFx0XHQubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpXG5cdFx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgc3Ryb2tlTWF0cml4ID0gcGFyZW50U3Ryb2tlTWF0cml4XG5cdFx0XHRcdD8gcGFyZW50U3Ryb2tlTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0OiAhdGhpcy5nZXRTdHJva2VTY2FsaW5nKHRydWUpICYmIGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSxcblx0XHRcdGNsaXAgPSAhZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtLFxuXHRcdFx0dHJhbnNmb3JtID0gIXN0cm9rZU1hdHJpeCB8fCBjbGlwO1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cdFx0XHRpZiAobmF0aXZlQmxlbmQpXG5cdFx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGU7XG5cdFx0fSBlbHNlIGlmICh0cmFuc2Zvcm0pIHtcblx0XHRcdGN0eC50cmFuc2xhdGUoLWl0ZW1PZmZzZXQueCwgLWl0ZW1PZmZzZXQueSk7XG5cdFx0fVxuXHRcdGlmICh0cmFuc2Zvcm0pXG5cdFx0XHQoZGlyZWN0ID8gbWF0cml4IDogZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmIChjbGlwKVxuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdGlmIChzdHJva2VNYXRyaXgpIHtcblx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aWYgKG9mZnNldClcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtb2Zmc2V0LngsIC1vZmZzZXQueSk7XG5cdFx0fVxuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG1hdHJpY2VzLnBvcCgpO1xuXHRcdGlmIChwYXJhbS5jbGlwICYmICFwYXJhbS5kb250RmluaXNoKVxuXHRcdFx0Y3R4LmNsaXAoKTtcblx0XHRpZiAoIWRpcmVjdCkge1xuXHRcdFx0QmxlbmRNb2RlLnByb2Nlc3MoYmxlbmRNb2RlLCBjdHgsIG1haW5DdHgsIG9wYWNpdHksXG5cdFx0XHRcdFx0aXRlbU9mZnNldC5zdWJ0cmFjdChwcmV2T2Zmc2V0KS5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHRwYXJhbS5vZmZzZXQgPSBwcmV2T2Zmc2V0O1xuXHRcdH1cblx0fSxcblxuXHRfaXNVcGRhdGVkOiBmdW5jdGlvbih1cGRhdGVWZXJzaW9uKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0cmV0dXJuIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pO1xuXHRcdHZhciB1cGRhdGVkID0gdGhpcy5fdXBkYXRlVmVyc2lvbiA9PT0gdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXVwZGF0ZWQgJiYgcGFyZW50ICYmIHBhcmVudC5fdmlzaWJsZVxuXHRcdFx0XHQmJiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0XHR1cGRhdGVkID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHVwZGF0ZWQ7XG5cdH0sXG5cblx0X2RyYXdTZWxlY3Rpb246IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBzZWxlY3RlZEl0ZW1zLCB1cGRhdGVWZXJzaW9uKSB7XG5cdFx0aWYgKCh0aGlzLl9kcmF3U2VsZWN0ZWQgfHwgdGhpcy5fYm91bmRzU2VsZWN0ZWQpXG5cdFx0XHRcdCYmIHRoaXMuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKSkge1xuXHRcdFx0dmFyIGNvbG9yID0gdGhpcy5nZXRTZWxlY3RlZENvbG9yKHRydWUpXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRMYXllcigpLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSksXG5cdFx0XHRcdG14ID0gbWF0cml4LmNoYWluKHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcblx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBjb2xvclxuXHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0aWYgKHRoaXMuX2RyYXdTZWxlY3RlZClcblx0XHRcdFx0dGhpcy5fZHJhd1NlbGVjdGVkKGN0eCwgbXgsIHNlbGVjdGVkSXRlbXMpO1xuXHRcdFx0aWYgKHRoaXMuX2JvdW5kc1NlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBoYWxmID0gc2l6ZSAvIDI7XG5cdFx0XHRcdFx0Y29vcmRzID0gbXguX3RyYW5zZm9ybUNvcm5lcnModGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHhbaSA9PT0gMCA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKGNvb3Jkc1tpXSwgY29vcmRzWysraV0pO1xuXHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KGNvb3Jkc1tpXSAtIGhhbGYsIGNvb3Jkc1srK2ldIC0gaGFsZixcblx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSwgQmFzZS5lYWNoKFsnZG93bicsICdkcmFnJywgJ3VwJywgJ21vdmUnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzWydyZW1vdmVPbicgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhhc2ggPSB7fTtcblx0XHRoYXNoW25hbWVdID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVPbihoYXNoKTtcblx0fTtcbn0sIHtcblxuXHRyZW1vdmVPbjogZnVuY3Rpb24ob2JqKSB7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGlmIChvYmpbbmFtZV0pIHtcblx0XHRcdFx0dmFyIGtleSA9ICdtb3VzZScgKyBuYW1lLFxuXHRcdFx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRcdHNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldID0gc2V0c1trZXldIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV1bdGhpcy5faWRdID0gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pKTtcblxudmFyIEdyb3VwID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcm91cCcsXG5cdF9zZWxlY3RDaGlsZHJlbjogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyb3VwKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKVxuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbiBfY2hhbmdlZChmbGFncykge1xuXHRcdF9jaGFuZ2VkLmJhc2UuY2FsbCh0aGlzLCBmbGFncyk7XG5cdFx0aWYgKGZsYWdzICYgMTAyNikge1xuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRDbGlwSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNsaXBJdGVtID0gdGhpcy5fY2xpcEl0ZW07XG5cdFx0aWYgKGNsaXBJdGVtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNsaXBJdGVtID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQuX2NsaXBNYXNrKSB7XG5cdFx0XHRcdFx0Y2xpcEl0ZW0gPSBjaGlsZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2xpcEl0ZW0gPSBjbGlwSXRlbTtcblx0XHR9XG5cdFx0cmV0dXJuIGNsaXBJdGVtO1xuXHR9LFxuXG5cdGlzQ2xpcHBlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fZ2V0Q2xpcEl0ZW0oKTtcblx0fSxcblxuXHRzZXRDbGlwcGVkOiBmdW5jdGlvbihjbGlwcGVkKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0aWYgKGNoaWxkKVxuXHRcdFx0Y2hpbGQuc2V0Q2xpcE1hc2soY2xpcHBlZCk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2xpcCA9IHBhcmFtLmNsaXAsXG5cdFx0XHRjbGlwSXRlbSA9ICFjbGlwICYmIHRoaXMuX2dldENsaXBJdGVtKCksXG5cdFx0XHRkcmF3ID0gdHJ1ZTtcblx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGNsaXBJdGVtOiBjbGlwSXRlbSwgY2xpcDogZmFsc2UgfSk7XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdGlmICh0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdFx0ZHJhdyA9IGZhbHNlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRwYXJhbS5kb250U3RhcnQgPSBwYXJhbS5kb250RmluaXNoID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNsaXBJdGVtKSB7XG5cdFx0XHRjbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0fVxuXHRcdGlmIChkcmF3KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gY2xpcEl0ZW0pXG5cdFx0XHRcdFx0aXRlbS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIExheWVyID0gR3JvdXAuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGF5ZXInLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExheWVyKGFyZykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdD8gbmV3IEJhc2UoYXJnKVxuXHRcdFx0XHQ6IHsgY2hpbGRyZW46IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyB9LFxuXHRcdFx0aW5zZXJ0ID0gcHJvcHMuaW5zZXJ0O1xuXHRcdHByb3BzLmluc2VydCA9IGZhbHNlO1xuXHRcdEdyb3VwLmNhbGwodGhpcywgcHJvcHMpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Byb2plY3QuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uIF9yZW1vdmUobm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdHJldHVybiBfcmVtb3ZlLmJhc2UuY2FsbCh0aGlzLCBub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpO1xuXHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRpZiAocHJvamVjdC5fYWN0aXZlTGF5ZXIgPT09IHRoaXMpXG5cdFx0XHRcdHByb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcy5nZXROZXh0U2libGluZygpXG5cdFx0XHRcdFx0XHR8fCB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuXHRcdFx0QmFzZS5zcGxpY2UocHJvamVjdC5sYXllcnMsIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdGlmIChub3RpZnlQYXJlbnQpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldE5leHRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uIGdldFByZXZpb3VzU2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0UHJldmlvdXNTaWJsaW5nLmJhc2UuY2FsbCh0aGlzKVxuXHRcdFx0XHQ6IHRoaXMuX3Byb2plY3QubGF5ZXJzW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbiBpc0luc2VydGVkKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBpc0luc2VydGVkLmJhc2UuY2FsbCh0aGlzKSA6IHRoaXMuX2luZGV4ICE9IG51bGw7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX2FjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaW5zZXJ0U2libGluZzogZnVuY3Rpb24gX2luc2VydFNpYmxpbmcoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiAhdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcHJvamVjdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKVxuXHRcdFx0XHQ6IF9pbnNlcnRTaWJsaW5nLmJhc2UuY2FsbCh0aGlzLCBpbmRleCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fVxufSk7XG5cbnZhciBTaGFwZSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2hhcGUnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHR0eXBlOiBudWxsLFxuXHRcdHNpemU6IG51bGwsXG5cdFx0cmFkaXVzOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2hhcGUocHJvcHMpIHtcblx0XHR0aGlzLl9pbml0aWFsaXplKHByb3BzKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IGl0ZW0uX3R5cGVcblx0XHRcdCYmIHRoaXMuX3NpemUuZXF1YWxzKGl0ZW0uX3NpemUpXG5cdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9yYWRpdXMsIGl0ZW0uX3JhZGl1cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFNoYXBlKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFR5cGUodGhpcy5fdHlwZSk7XG5cdFx0Y29weS5zZXRTaXplKHRoaXMuX3NpemUpO1xuXHRcdGNvcHkuc2V0UmFkaXVzKHRoaXMuX3JhZGl1cyk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdH0sXG5cblx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHR9LFxuXG5cdGdldFNoYXBlOiAnI2dldFR5cGUnLFxuXHRzZXRTaGFwZTogJyNzZXRUeXBlJyxcblxuXHRnZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLl9zaXplKSB7XG5cdFx0XHR0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuXHRcdH0gZWxzZSBpZiAoIXRoaXMuX3NpemUuZXF1YWxzKHNpemUpKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUubWluKHRoaXMuX3JhZGl1cywgc2l6ZS5kaXZpZGUoMikpO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdHdpZHRoID0gaGVpZ2h0ID0gKHdpZHRoICsgaGVpZ2h0KSAvIDI7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHdpZHRoIC8gMjtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NpemUuc2V0KHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UmFkaXVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmFkID0gdGhpcy5fcmFkaXVzO1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSAnY2lyY2xlJ1xuXHRcdFx0XHQ/IHJhZFxuXHRcdFx0XHQ6IG5ldyBMaW5rZWRTaXplKHJhZC53aWR0aCwgcmFkLmhlaWdodCwgdGhpcywgJ3NldFJhZGl1cycpO1xuXHR9LFxuXG5cdHNldFJhZGl1czogZnVuY3Rpb24ocmFkaXVzKSB7XG5cdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0aWYgKHJhZGl1cyA9PT0gdGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgc2l6ZSA9IHJhZGl1cyAqIDI7XG5cdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0XHR0aGlzLl9zaXplLnNldChzaXplLCBzaXplKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoIXRoaXMuX3JhZGl1cykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSByYWRpdXMuY2xvbmUoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0aGlzLl9yYWRpdXMuZXF1YWxzKHJhZGl1cykpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHJhZGl1cy53aWR0aCwgcmFkaXVzLmhlaWdodCk7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBzaXplID0gU2l6ZS5tYXgodGhpcy5fc2l6ZSwgcmFkaXVzLm11bHRpcGx5KDIpKTtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKSB7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQocmFkaXVzLndpZHRoICogMiwgcmFkaXVzLmhlaWdodCAqIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRvUGF0aDogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aFtCYXNlLmNhcGl0YWxpemUodGhpcy5fdHlwZSldKHtcblx0XHRcdGNlbnRlcjogbmV3IFBvaW50KCksXG5cdFx0XHRzaXplOiB0aGlzLl9zaXplLFxuXHRcdFx0cmFkaXVzOiB0aGlzLl9yYWRpdXMsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0fSk7XG5cdFx0cGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0cGF0aC50cmFuc2Zvcm0odGhpcy5fbWF0cml4KTtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHR1bnRyYW5zZm9ybWVkID0gIXN0cm9rZU1hdHJpeDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0aXNDaXJjbGUgPSB0eXBlID09PSAnY2lyY2xlJztcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiBpc0NpcmNsZSkge1xuXHRcdFx0XHRjdHguYXJjKDAsIDAsIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJ4ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3NpemUsXG5cdFx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRpZiAodW50cmFuc2Zvcm1lZCAmJiB0eXBlID09PSAncmVjdCcgJiYgcnggPT09IDAgJiYgcnkgPT09IDApIHtcblx0XHRcdFx0XHRjdHgucmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHggPSB3aWR0aCAvIDIsXG5cdFx0XHRcdFx0XHR5ID0gaGVpZ2h0IC8gMixcblx0XHRcdFx0XHRcdGthcHBhID0gMSAtIDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRcdFx0XHRcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdGN5ID0gcnkgKiBrYXBwYSxcblx0XHRcdFx0XHRcdGMgPSBbXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIC15LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIHksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gcnlcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0aWYgKHN0cm9rZU1hdHJpeClcblx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeC50cmFuc2Zvcm0oYywgYywgMzIpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzhdLCBjWzldKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gcnkpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMTZdLCBjWzE3XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxOF0sIGNbMTldLCBjWzIwXSwgY1syMV0sIGNbMjJdLCBjWzIzXSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMjZdLCBjWzI3XSwgY1syOF0sIGNbMjldLCBjWzMwXSwgY1szMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdGlmIChnZXR0ZXIgIT09ICdnZXRCb3VuZHMnICYmIHRoaXMuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZWN0ID0gcmVjdC5leHBhbmQodGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldENvcm5lckNlbnRlcih0aGF0LCBwb2ludCwgZXhwYW5kKSB7XG5cdFx0dmFyIHJhZGl1cyA9IHRoYXQuX3JhZGl1cztcblx0XHRpZiAoIXJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGhhbGZTaXplID0gdGhhdC5fc2l6ZS5kaXZpZGUoMik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0XHR2YXIgZGlyID0gbmV3IFBvaW50KGkgJiAxID8gMSA6IC0xLCBpID4gMSA/IDEgOiAtMSksXG5cdFx0XHRcdFx0Y29ybmVyID0gZGlyLm11bHRpcGx5KGhhbGZTaXplKSxcblx0XHRcdFx0XHRjZW50ZXIgPSBjb3JuZXIuc3VidHJhY3QoZGlyLm11bHRpcGx5KHJhZGl1cykpLFxuXHRcdFx0XHRcdHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvcm5lciwgY2VudGVyKTtcblx0XHRcdFx0aWYgKChleHBhbmQgPyByZWN0LmV4cGFuZChleHBhbmQpIDogcmVjdCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiBjZW50ZXI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKSB7XG5cdFx0dmFyIGFuZ2xlID0gcG9pbnQuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdHdpZHRoID0gcmFkaXVzLndpZHRoICogMixcblx0XHRcdGhlaWdodCA9IHJhZGl1cy5oZWlnaHQgKiAyLFxuXHRcdFx0eCA9IHdpZHRoICogTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0eSA9IGhlaWdodCAqIE1hdGguY29zKGFuZ2xlKTtcblx0XHRyZXR1cm4gd2lkdGggKiBoZWlnaHQgLyAoMiAqIE1hdGguc3FydCh4ICogeCArIHkgKiB5KSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9jb250YWluczogZnVuY3Rpb24gX2NvbnRhaW5zKHBvaW50KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0dmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCk7XG5cdFx0XHRcdHJldHVybiBjZW50ZXJcblx0XHRcdFx0XHRcdD8gcG9pbnQuc3VidHJhY3QoY2VudGVyKS5kaXZpZGUodGhpcy5fcmFkaXVzKVxuXHRcdFx0XHRcdFx0XHQuZ2V0TGVuZ3RoKCkgPD0gMVxuXHRcdFx0XHRcdFx0OiBfY29udGFpbnMuYmFzZS5jYWxsKHRoaXMsIHBvaW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBwb2ludC5kaXZpZGUodGhpcy5zaXplKS5nZXRMZW5ndGgoKSA8PSAwLjU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24gX2hpdFRlc3RTZWxmKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgaGl0ID0gZmFsc2U7XG5cdFx0XHRpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRcdHN0cm9rZVdpZHRoID0gdGhpcy5nZXRTdHJva2VXaWR0aCgpICsgMiAqIG9wdGlvbnMudG9sZXJhbmNlO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50LCBzdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0aWYgKGNlbnRlcikge1xuXHRcdFx0XHRcdFx0dmFyIHB0ID0gcG9pbnQuc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwdC5nZXRMZW5ndGgoKVxuXHRcdFx0XHRcdFx0XHRcdC0gZ2V0RWxsaXBzZVJhZGl1cyhwdCwgcmFkaXVzKSkgPD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCksXG5cdFx0XHRcdFx0XHRcdG91dGVyID0gcmVjdC5leHBhbmQoc3Ryb2tlV2lkdGgpLFxuXHRcdFx0XHRcdFx0XHRpbm5lciA9IHJlY3QuZXhwYW5kKC1zdHJva2VXaWR0aCk7XG5cdFx0XHRcdFx0XHRoaXQgPSBvdXRlci5fY29udGFpbnNQb2ludChwb2ludClcblx0XHRcdFx0XHRcdFx0XHQmJiAhaW5uZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2VsbGlwc2UnKVxuXHRcdFx0XHRcdFx0cmFkaXVzID0gZ2V0RWxsaXBzZVJhZGl1cyhwb2ludCwgcmFkaXVzKTtcblx0XHRcdFx0XHRoaXQgPSAyICogTWF0aC5hYnMocG9pbnQuZ2V0TGVuZ3RoKCkgLSByYWRpdXMpXG5cdFx0XHRcdFx0XHRcdDw9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGl0XG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdzdHJva2UnLCB0aGlzKVxuXHRcdFx0XHRcdDogX2hpdFRlc3RTZWxmLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59LCB7XG5cbnN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gY3JlYXRlU2hhcGUodHlwZSwgcG9pbnQsIHNpemUsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBpdGVtID0gbmV3IFNoYXBlKEJhc2UuZ2V0TmFtZWQoYXJncykpO1xuXHRcdGl0ZW0uX3R5cGUgPSB0eXBlO1xuXHRcdGl0ZW0uX3NpemUgPSBzaXplO1xuXHRcdGl0ZW0uX3JhZGl1cyA9IHJhZGl1cztcblx0XHRyZXR1cm4gaXRlbS50cmFuc2xhdGUocG9pbnQpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2NpcmNsZScsIGNlbnRlciwgbmV3IFNpemUocmFkaXVzICogMiksIHJhZGl1cyxcblx0XHRcdFx0XHRhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdyZWN0YW5nbGUnLCByZWN0LmdldENlbnRlcih0cnVlKSxcblx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSksIHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpLFxuXHRcdFx0XHRyYWRpdXMgPSBlbGxpcHNlLnJhZGl1cztcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnZWxsaXBzZScsIGVsbGlwc2UuY2VudGVyLCByYWRpdXMubXVsdGlwbHkoMiksXG5cdFx0XHRcdFx0cmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRfcmVhZEVsbGlwc2U6IGZ1bmN0aW9uKGFyZ3MpIHtcblx0XHRcdHZhciBjZW50ZXIsXG5cdFx0XHRcdHJhZGl1cztcblx0XHRcdGlmIChCYXNlLmhhc05hbWVkKGFyZ3MsICdyYWRpdXMnKSkge1xuXHRcdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJncywgJ2NlbnRlcicpO1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmdzLCAncmFkaXVzJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJncywgJ3JlY3RhbmdsZScpO1xuXHRcdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdFx0cmFkaXVzID0gcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7IGNlbnRlcjogY2VudGVyLCByYWRpdXM6IHJhZGl1cyB9O1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIFJhc3RlciA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmFzdGVyJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogJ2dldEJvdW5kcycsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHNvdXJjZTogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJhc3RlcihvYmplY3QsIHBvc2l0aW9uKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKG9iamVjdCxcblx0XHRcdFx0cG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKSB7XG5cdFx0XHRpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRTb3VyY2Uob2JqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2Uob2JqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF0aGlzLl9zaXplKVxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKCk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgpID09PSBpdGVtLmdldFNvdXJjZSgpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0aW1hZ2UgPSB0aGlzLl9pbWFnZSxcblx0XHRcdGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdGNvcHkuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdH0gZWxzZSBpZiAoY2FudmFzKSB7XG5cdFx0XHR2YXIgY29weUNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyh0aGlzLl9zaXplKTtcblx0XHRcdGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdGNvcHkuc2V0SW1hZ2UoY29weUNhbnZhcyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLFxuXHRcdFx0XHR0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuXHRcdFx0aWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IG51bGw7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg1MjEpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihtb2RpZnkpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRleHQpXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChtb2RpZnkpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoNTEzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0aW1hZ2U7XG5cblx0XHRmdW5jdGlvbiBsb2FkZWQoKSB7XG5cdFx0XHR2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpO1xuXHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0cGFwZXIgPSB2aWV3Ll9zY29wZTtcblx0XHRcdFx0dGhhdC5zZXRJbWFnZShpbWFnZSk7XG5cdFx0XHRcdHRoYXQuZW1pdCgnbG9hZCcpO1xuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFx0aW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzcmMpIHx8IG5ldyBJbWFnZSgpO1xuXG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiBpbWFnZS5uYXR1cmFsSGVpZ2h0KSB7XG5cdFx0XHRzZXRUaW1lb3V0KGxvYWRlZCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbUV2ZW50LmFkZChpbWFnZSwge1xuXHRcdFx0XHRsb2FkOiBsb2FkZWRcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCFpbWFnZS5zcmMpXG5cdFx0XHRcdGltYWdlLnNyYyA9IHNyYztcblx0XHR9XG5cdFx0dGhpcy5zZXRJbWFnZShpbWFnZSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9pbWFnZTtcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0U3ViQ2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHJlY3QuZ2V0U2l6ZSgpKTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0Q2FudmFzKCksIHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCwgMCwgMCwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBjdHguY2FudmFzO1xuXHR9LFxuXG5cdGdldFN1YlJhc3RlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0cmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldEltYWdlKHRoaXMuZ2V0U3ViQ2FudmFzKHJlY3QpKTtcblx0XHRyYXN0ZXIudHJhbnNsYXRlKHJlY3QuZ2V0Q2VudGVyKCkuc3VidHJhY3QodGhpcy5nZXRTaXplKCkuZGl2aWRlKDIpKSk7XG5cdFx0cmFzdGVyLl9tYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fbWF0cml4KTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHR0b0RhdGFVUkw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzcmMgPSB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5zcmM7XG5cdFx0aWYgKC9eZGF0YTovLnRlc3Qoc3JjKSlcblx0XHRcdHJldHVybiBzcmM7XG5cdFx0dmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cdFx0cmV0dXJuIGNhbnZhcyA/IGNhbnZhcy50b0RhdGFVUkwoKSA6IG51bGw7XG5cdH0sXG5cblx0ZHJhd0ltYWdlOiBmdW5jdGlvbihpbWFnZSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbihvYmplY3QpIHtcblx0XHR2YXIgYm91bmRzLCBwYXRoO1xuXHRcdGlmICghb2JqZWN0KSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcblx0XHRcdHBhdGggPSBvYmplY3Q7XG5cdFx0XHRib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3Qud2lkdGgpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC54KSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG5cdFx0fVxuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuXHRcdFx0XHRvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcblx0XHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcGFjaXR5O1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFBsYWNlZFN5bWJvbCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGxhY2VkU3ltYm9sJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogeyBnZXRCb3VuZHM6ICdnZXRTdHJva2VCb3VuZHMnIH0sXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBsYWNlZFN5bWJvbChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZzAsXG5cdFx0XHRcdGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKVxuXHRcdFx0dGhpcy5zZXRTeW1ib2woYXJnMCBpbnN0YW5jZW9mIFN5bWJvbCA/IGFyZzAgOiBuZXcgU3ltYm9sKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbCA9PT0gaXRlbS5fc3ltYm9sO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbDtcblx0fSxcblxuXHRzZXRTeW1ib2w6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHRoaXMuX3N5bWJvbCA9IHN5bWJvbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQbGFjZWRTeW1ib2woSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U3ltYm9sKHRoaXMuX3N5bWJvbCk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBkZWZpbml0aW9uID0gdGhpcy5zeW1ib2wuX2RlZmluaXRpb247XG5cdFx0cmV0dXJuIGRlZmluaXRpb24uX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oZGVmaW5pdGlvbi5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5zeW1ib2wuX2RlZmluaXRpb24uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHZhbHVlcy5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5qZWN0KHZhbHVlcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJhc2Uoe1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHR0b2xlcmFuY2U6IHBhcGVyLnNldHRpbmdzLmhpdFRvbGVyYW5jZSxcblx0XHRcdFx0ZmlsbDogIW9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZTogIW9wdGlvbnMsXG5cdFx0XHRcdHNlZ21lbnRzOiAhb3B0aW9ucyxcblx0XHRcdFx0aGFuZGxlczogZmFsc2UsXG5cdFx0XHRcdGVuZHM6IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0O1xuXHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcwLnBvaW50KSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMC5wb2ludDtcblx0XHRcdFx0aGFuZGxlSW4gPSBhcmcwLmhhbmRsZUluO1xuXHRcdFx0XHRoYW5kbGVPdXQgPSBhcmcwLmhhbmRsZU91dDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyICYmIHR5cGVvZiBhcmcwID09PSAnbnVtYmVyJykge1xuXHRcdFx0cG9pbnQgPSBhcmd1bWVudHM7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA8PSAzKSB7XG5cdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzE7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmcyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb2ludCA9IGFyZzAgIT09IHVuZGVmaW5lZCA/IFsgYXJnMCwgYXJnMSBdIDogbnVsbDtcblx0XHRcdGhhbmRsZUluID0gYXJnMiAhPT0gdW5kZWZpbmVkID8gWyBhcmcyLCBhcmczIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnNCAhPT0gdW5kZWZpbmVkID8gWyBhcmc0LCBhcmc1IF0gOiBudWxsO1xuXHRcdH1cblx0XHRuZXcgU2VnbWVudFBvaW50KHBvaW50LCB0aGlzLCAnX3BvaW50Jyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVJbiwgdGhpcywgJ19oYW5kbGVJbicpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlT3V0LCB0aGlzLCAnX2hhbmRsZU91dCcpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5pc0xpbmVhcigpID8gdGhpcy5fcG9pbnRcblx0XHRcdFx0OiBbdGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXRdLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgJiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpO1xuXHR9LFxuXG5cdHNldExpbmVhcjogZnVuY3Rpb24obGluZWFyKSB7XG5cdFx0aWYgKGxpbmVhcikge1xuXHRcdFx0dGhpcy5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHRcdFx0dGhpcy5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdH1cblx0fSxcblxuXHRpc0NvbGluZWFyOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0dmFyIG5leHQxID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRuZXh0MiA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dDEuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdCYmIHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBuZXh0Mi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0JiYgbmV4dDEuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KS5pc0NvbGluZWFyKFxuXHRcdFx0XHRcdG5leHQyLl9wb2ludC5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHR9LFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLmdldFByZXZpb3VzKCksXG5cdFx0XHRuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG5cdFx0cmV0dXJuIHByZXYuX2hhbmRsZU91dC5pc1plcm8oKSAmJiB0aGlzLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHQmJiB0aGlzLl9wb2ludC5zdWJ0cmFjdChwcmV2Ll9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdG5leHQuX3BvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSk7XG5cdH0sXG5cblx0aXNBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCksXG5cdFx0XHRoYW5kbGUxID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0aGFuZGxlMiA9IG5leHQuX2hhbmRsZUluLFxuXHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0aWYgKGhhbmRsZTEuaXNPcnRob2dvbmFsKGhhbmRsZTIpKSB7XG5cdFx0XHR2YXIgZnJvbSA9IHRoaXMuX3BvaW50LFxuXHRcdFx0XHR0byA9IG5leHQuX3BvaW50LFxuXHRcdFx0XHRjb3JuZXIgPSBuZXcgTGluZShmcm9tLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRuZXcgTGluZSh0bywgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdChmcm9tKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdGNvcm5lci5zdWJ0cmFjdCh0bykuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihzZWdtZW50MCwgc2VnbWVudDEsIGNvZWYpIHtcblx0XHR2YXIgZHhQb2ludCA9IHNlZ21lbnQxLl9wb2ludC5feCAtIHNlZ21lbnQwLl9wb2ludC5feCxcblx0XHRcdGR5UG9pbnQgPSBzZWdtZW50MS5fcG9pbnQuX3kgLSBzZWdtZW50MC5fcG9pbnQuX3ksXG5cdFx0XHRkeEhhbmRsZUluID0gc2VnbWVudDEuX2hhbmRsZUluLl94IC0gc2VnbWVudDAuX2hhbmRsZUluLl94LFxuXHRcdFx0ZHlIYW5kbGVJbiA9IHNlZ21lbnQxLl9oYW5kbGVJbi5feSAtIHNlZ21lbnQwLl9oYW5kbGVJbi5feSxcblx0XHRcdGR4SGFuZGxlT3V0ID0gc2VnbWVudDEuX2hhbmRsZU91dC5feCAtIHNlZ21lbnQwLl9oYW5kbGVPdXQuX3gsXG5cdFx0XHRkeUhhbmRsZU91dCA9IHNlZ21lbnQxLl9oYW5kbGVPdXQuX3kgLSBzZWdtZW50MC5faGFuZGxlT3V0Ll95O1xuXG5cdFx0dGhpcy5fcG9pbnQuX3ggPSBzZWdtZW50MC5fcG9pbnQuX3ggKyBkeFBvaW50ICogY29lZjtcblx0XHR0aGlzLl9wb2ludC5feSA9IHNlZ21lbnQwLl9wb2ludC5feSArIGR5UG9pbnQgKiBjb2VmO1xuXHRcdHRoaXMuX2hhbmRsZUluLl94ID0gc2VnbWVudDAuX2hhbmRsZUluLl94ICsgZHhIYW5kbGVJbiAqIGNvZWY7XG5cdFx0dGhpcy5faGFuZGxlSW4uX3kgPSBzZWdtZW50MC5faGFuZGxlSW4uX3kgKyBkeUhhbmRsZUluICogY29lZjtcblx0XHR0aGlzLl9oYW5kbGVPdXQuX3ggPSBzZWdtZW50MC5faGFuZGxlT3V0Ll94ICsgZHhIYW5kbGVPdXQgKiBjb2VmO1xuXHRcdHRoaXMuX2hhbmRsZU91dC5feSA9IHNlZ21lbnQwLl9oYW5kbGVPdXQuX3kgKyBkeUhhbmRsZU91dCAqIGNvZWY7XG5cblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihtYXRyaXgsIGNvb3JkcywgY2hhbmdlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG5cdFx0XHRoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG5cdFx0XHR4ID0gcG9pbnQuX3gsXG5cdFx0XHR5ID0gcG9pbnQuX3ksXG5cdFx0XHRpID0gMjtcblx0XHRjb29yZHNbMF0gPSB4O1xuXHRcdGNvb3Jkc1sxXSA9IHk7XG5cdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcblx0XHRcdHggPSBjb29yZHNbMF07XG5cdFx0XHR5ID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRwb2ludC5feCA9IHg7XG5cdFx0XHRcdHBvaW50Ll95ID0geTtcblx0XHRcdFx0aSAgPSAyO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRoYW5kbGVJbi5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVJbi5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCFoYW5kbGVJbikge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb29yZHM7XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudFBvaW50KHBvaW50LCBvd25lciwga2V5KSB7XG5cdFx0dmFyIHgsIHksIHNlbGVjdGVkO1xuXHRcdGlmICghcG9pbnQpIHtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHkgPSBwb2ludFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQ7XG5cdFx0XHRpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR4ID0gcHQueDtcblx0XHRcdH1cblx0XHRcdHkgPSBwdC55O1xuXHRcdFx0c2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcblx0XHR9XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHRvd25lcltrZXldID0gdGhpcztcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyLFxuXHRcdFx0eCA9IGYubnVtYmVyKHRoaXMuX3gpLFxuXHRcdFx0eSA9IGYubnVtYmVyKHRoaXMuX3kpO1xuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQ/IHsgeDogeCwgeTogeSwgc2VsZWN0ZWQ6IHRydWUgfVxuXHRcdFx0XHQ6IFt4LCB5XTtcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy5feCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLl95KTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdGhpcyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX293bmVyLmlzU2VsZWN0ZWQodGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgQ3VydmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAoY291bnQgPT09IDMpIHtcblx0XHRcdHRoaXMuX3BhdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBhcmcxO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBhcmcyO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQoKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDEpO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQyKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KGFyZzApO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudChhcmcxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50MSwgaGFuZGxlMSwgaGFuZGxlMiwgcG9pbnQyO1xuXHRcdFx0aWYgKGNvdW50ID09PSA0KSB7XG5cdFx0XHRcdHBvaW50MSA9IGFyZzA7XG5cdFx0XHRcdGhhbmRsZTEgPSBhcmcxO1xuXHRcdFx0XHRoYW5kbGUyID0gYXJnMjtcblx0XHRcdFx0cG9pbnQyID0gYXJnMztcblx0XHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDgpIHtcblx0XHRcdFx0cG9pbnQxID0gW2FyZzAsIGFyZzFdO1xuXHRcdFx0XHRwb2ludDIgPSBbYXJnNiwgYXJnN107XG5cdFx0XHRcdGhhbmRsZTEgPSBbYXJnMiAtIGFyZzAsIGFyZzMgLSBhcmcxXTtcblx0XHRcdFx0aGFuZGxlMiA9IFthcmc0IC0gYXJnNiwgYXJnNSAtIGFyZzddO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChwb2ludDEsIG51bGwsIGhhbmRsZTEpO1xuXHRcdFx0dGhpcy5fc2VnbWVudDIgPSBuZXcgU2VnbWVudChwb2ludDIsIGhhbmRsZTIsIG51bGwpO1xuXHRcdH1cblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdGdldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50MS5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZTE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDE7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5nZXRQb2ludDEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldFBvaW50MigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRWYWx1ZXModGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyLCBtYXRyaXgpO1xuXHR9LFxuXG5cdGdldFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pKTtcblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLmlzTGluZWFyKClcblx0XHRcdFx0PyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQuZ2V0RGlzdGFuY2UodGhpcy5fc2VnbWVudDEuX3BvaW50KVxuXHRcdFx0XHQ6IEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCAwLCAxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0QXJlYSh0aGlzLmdldFZhbHVlcygpKTtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgQ3VydmUoQ3VydmUuZ2V0UGFydCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0bykpO1xuXHR9LFxuXG5cdGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0byk7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdCYmIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBDdXJ2ZS5maWx0ZXJJbnRlcnNlY3Rpb25zKEN1cnZlLmdldEludGVyc2VjdGlvbnMoXG5cdFx0XHRcdHRoaXMuZ2V0VmFsdWVzKCksIGN1cnZlLmdldFZhbHVlcygpLCB0aGlzLCBjdXJ2ZSwgW10pKTtcblx0fSxcblxuXHRfZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIGlzUGFyYW1ldGVyXG5cdFx0XHRcdD8gb2Zmc2V0XG5cdFx0XHRcdDogb2Zmc2V0ICYmIG9mZnNldC5jdXJ2ZSA9PT0gdGhpc1xuXHRcdFx0XHRcdD8gb2Zmc2V0LnBhcmFtZXRlclxuXHRcdFx0XHRcdDogb2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgaXNQYXJhbWV0ZXIgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0PyAwLjVcblx0XHRcdFx0XHRcdDogdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQsIDApO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlciwgaWdub3JlTGluZWFyKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSxcblx0XHRcdHRvbGVyYW5jZSA9IDAuMDAwMDAxLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAocGFyYW1ldGVyID4gdG9sZXJhbmNlICYmIHBhcmFtZXRlciA8IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIpLFxuXHRcdFx0XHRpc0xpbmVhciA9IGlnbm9yZUxpbmVhciA/IGZhbHNlIDogdGhpcy5pc0xpbmVhcigpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV07XG5cblx0XHRcdGlmICghaXNMaW5lYXIpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQobGVmdFsyXSAtIGxlZnRbMF0sXG5cdFx0XHRcdFx0XHRsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocmlnaHRbNF0gLSByaWdodFs2XSxcblx0XHRcdFx0XHRcdHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgeCA9IGxlZnRbNl0sIHkgPSBsZWZ0WzddLFxuXHRcdFx0XHRzZWdtZW50ID0gbmV3IFNlZ21lbnQobmV3IFBvaW50KHgsIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXG5cdFx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc2VnbWVudDEuX2luZGV4ID4gMCAmJiB0aGlzLl9zZWdtZW50Mi5faW5kZXggPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmFkZChzZWdtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmluc2VydCh0aGlzLl9zZWdtZW50Mi5faW5kZXgsIHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZW5kID0gdGhpcy5fc2VnbWVudDI7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnbWVudDtcblx0XHRcdFx0cmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIGVuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aFxuXHRcdFx0PyB0aGlzLl9wYXRoLnNwbGl0KHRoaXMuX3NlZ21lbnQxLl9pbmRleCxcblx0XHRcdFx0XHR0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlcikpXG5cdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2UoKSk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLl9wYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudDIgPSB0aGlzLl9zZWdtZW50Mixcblx0XHRcdFx0aGFuZGxlT3V0ID0gc2VnbWVudDIuX2hhbmRsZU91dDtcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50Mi5yZW1vdmUoKTtcblx0XHRcdGlmIChyZW1vdmVkKVxuXHRcdFx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChoYW5kbGVPdXQueCwgaGFuZGxlT3V0LnkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDIpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDE6ICcgKyB0aGlzLl9zZWdtZW50MS5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUxOiAnICsgdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dCk7XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGUyOiAnICsgdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluKTtcblx0XHRwYXJ0cy5wdXNoKCdwb2ludDI6ICcgKyB0aGlzLl9zZWdtZW50Mi5fcG9pbnQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCkge1xuXHRcdHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcblx0XHRcdGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuXHRcdFx0cDIgPSBzZWdtZW50Mi5fcG9pbnQsXG5cdFx0XHR2YWx1ZXMgPSBbXG5cdFx0XHRcdHAxLl94LCBwMS5feSxcblx0XHRcdFx0cDEuX3ggKyBoMS5feCwgcDEuX3kgKyBoMS5feSxcblx0XHRcdFx0cDIuX3ggKyBoMi5feCwgcDIuX3kgKyBoMi5feSxcblx0XHRcdFx0cDIuX3gsIHAyLl95XG5cdFx0XHRdO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHZhbHVlcywgdmFsdWVzLCA0KTtcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbih2LCB0LCB0eXBlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMSxcblx0XHRcdHgsIHk7XG5cblx0XHRpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdHZhciBpc1plcm8gPSB0IDwgdG9sZXJhbmNlO1xuXHRcdFx0eCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcblx0XHRcdHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblx0XHRcdFx0YnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcblx0XHRcdFx0YXggPSBwMnggLSBwMXggLSBjeCAtIGJ4LFxuXG5cdFx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpLFxuXHRcdFx0XHRieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuXHRcdFx0XHRheSA9IHAyeSAtIHAxeSAtIGN5IC0gYnk7XG5cdFx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0XHR4ID0gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHAxeDtcblx0XHRcdFx0eSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodCA8IHRvbGVyYW5jZSAmJiBjMXggPT09IHAxeCAmJiBjMXkgPT09IHAxeVxuXHRcdFx0XHRcdFx0fHwgdCA+IDEgLSB0b2xlcmFuY2UgJiYgYzJ4ID09PSBwMnggJiYgYzJ5ID09PSBwMnkpIHtcblx0XHRcdFx0XHR4ID0gYzJ4IC0gYzF4O1xuXHRcdFx0XHRcdHkgPSBjMnkgLSBjMXk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA8IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0XHR5ID0gY3k7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA+IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gMyAqIChwMnggLSBjMngpO1xuXHRcdFx0XHRcdHkgPSAzICogKHAyeSAtIGMyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieTtcblx0XHRcdFx0XHRyZXR1cm4gKHggKiB5MiAtIHkgKiB4MikgLyBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHR5cGUgPT09IDIgPyBuZXcgUG9pbnQoeSwgLXgpIDogbmV3IFBvaW50KHgsIHkpO1xuXHR9LFxuXG5cdHN1YmRpdmlkZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdGlmICh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHR0ID0gMC41O1xuXHRcdHZhciB1ID0gMSAtIHQsXG5cdFx0XHRwM3ggPSB1ICogcDF4ICsgdCAqIGMxeCwgcDN5ID0gdSAqIHAxeSArIHQgKiBjMXksXG5cdFx0XHRwNHggPSB1ICogYzF4ICsgdCAqIGMyeCwgcDR5ID0gdSAqIGMxeSArIHQgKiBjMnksXG5cdFx0XHRwNXggPSB1ICogYzJ4ICsgdCAqIHAyeCwgcDV5ID0gdSAqIGMyeSArIHQgKiBwMnksXG5cdFx0XHRwNnggPSB1ICogcDN4ICsgdCAqIHA0eCwgcDZ5ID0gdSAqIHAzeSArIHQgKiBwNHksXG5cdFx0XHRwN3ggPSB1ICogcDR4ICsgdCAqIHA1eCwgcDd5ID0gdSAqIHA0eSArIHQgKiBwNXksXG5cdFx0XHRwOHggPSB1ICogcDZ4ICsgdCAqIHA3eCwgcDh5ID0gdSAqIHA2eSArIHQgKiBwN3k7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtwMXgsIHAxeSwgcDN4LCBwM3ksIHA2eCwgcDZ5LCBwOHgsIHA4eV0sXG5cdFx0XHRbcDh4LCBwOHksIHA3eCwgcDd5LCBwNXgsIHA1eSwgcDJ4LCBwMnldXG5cdFx0XTtcblx0fSxcblxuXHRzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHAxID0gdltjb29yZF0sXG5cdFx0XHRjMSA9IHZbY29vcmQgKyAyXSxcblx0XHRcdGMyID0gdltjb29yZCArIDRdLFxuXHRcdFx0cDIgPSB2W2Nvb3JkICsgNl0sXG5cdFx0XHRjID0gMyAqIChjMSAtIHAxKSxcblx0XHRcdGIgPSAzICogKGMyIC0gYzEpIC0gYyxcblx0XHRcdGEgPSBwMiAtIHAxIC0gYyAtIGIsXG5cdFx0XHRpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdGlmIChpc1plcm8oYSkgJiYgaXNaZXJvKGIpKVxuXHRcdFx0YSA9IGIgPSAwO1xuXHRcdHJldHVybiBOdW1lcmljYWwuc29sdmVDdWJpYyhhLCBiLCBjLCBwMSAtIHZhbCwgcm9vdHMsIG1pbiwgbWF4KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24odiwgeCwgeSkge1xuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRpZiAoTWF0aC5hYnModlswXSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbMV0gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAwO1xuXHRcdGlmIChNYXRoLmFicyh2WzZdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModls3XSAtIHkpIDwgdG9sZXJhbmNlKVxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0dmFyIHR4cyA9IFtdLFxuXHRcdFx0dHlzID0gW10sXG5cdFx0XHRzeCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMCwgeCwgdHhzLCAwLCAxKSxcblx0XHRcdHN5ID0gQ3VydmUuc29sdmVDdWJpYyh2LCAxLCB5LCB0eXMsIDAsIDEpLFxuXHRcdFx0dHgsIHR5O1xuXHRcdGZvciAodmFyIGN4ID0gMDsgIHN4ID09IC0xIHx8IGN4IDwgc3g7KSB7XG5cdFx0XHRpZiAoc3ggPT0gLTEgfHwgKHR4ID0gdHhzW2N4KytdKSA+PSAwICYmIHR4IDw9IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBzeSA9PSAtMSB8fCBjeSA8IHN5Oykge1xuXHRcdFx0XHRcdGlmIChzeSA9PSAtMSB8fCAodHkgPSB0eXNbY3krK10pID49IDAgJiYgdHkgPD0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKHN4ID09IC0xKSB0eCA9IHR5O1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc3kgPT0gLTEpIHR5ID0gdHg7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModHggLSB0eSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0XHRcdHJldHVybiAodHggKyB0eSkgKiAwLjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCA9PSAtMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHRpZiAoZnJvbSA+IDApXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsIGZyb20pWzFdO1xuXHRcdGlmICh0byA8IDEpXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsICh0byAtIGZyb20pIC8gKDEgLSBmcm9tKSlbMF07XG5cdFx0cmV0dXJuIHY7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gaXNaZXJvKHZbMF0gLSB2WzJdKSAmJiBpc1plcm8odlsxXSAtIHZbM10pXG5cdFx0XHRcdCYmIGlzWmVybyh2WzRdIC0gdls2XSkgJiYgaXNaZXJvKHZbNV0gLSB2WzddKTtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIHRvbGVyYW5jZSkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dXggPSAzICogYzF4IC0gMiAqIHAxeCAtIHAyeCxcblx0XHRcdHV5ID0gMyAqIGMxeSAtIDIgKiBwMXkgLSBwMnksXG5cdFx0XHR2eCA9IDMgKiBjMnggLSAyICogcDJ4IC0gcDF4LFxuXHRcdFx0dnkgPSAzICogYzJ5IC0gMiAqIHAyeSAtIHAxeTtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8IDEwICogdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRyZXR1cm4gKCAgMy4wICogYzF5ICogcDF4IC0gMS41ICogYzF5ICogYzJ4XG5cdFx0XHRcdC0gMS41ICogYzF5ICogcDJ4IC0gMy4wICogcDF5ICogYzF4XG5cdFx0XHRcdC0gMS41ICogcDF5ICogYzJ4IC0gMC41ICogcDF5ICogcDJ4XG5cdFx0XHRcdCsgMS41ICogYzJ5ICogcDF4ICsgMS41ICogYzJ5ICogYzF4XG5cdFx0XHRcdC0gMy4wICogYzJ5ICogcDJ4ICsgMC41ICogcDJ5ICogcDF4XG5cdFx0XHRcdCsgMS41ICogcDJ5ICogYzF4ICsgMy4wICogcDJ5ICogYzJ4KSAvIDEwO1xuXHR9LFxuXG5cdGdldEVkZ2VTdW06IGZ1bmN0aW9uKHYpIHtcblx0XHRyZXR1cm5cdCAgKHZbMF0gLSB2WzJdKSAqICh2WzNdICsgdlsxXSlcblx0XHRcdFx0KyAodlsyXSAtIHZbNF0pICogKHZbNV0gKyB2WzNdKVxuXHRcdFx0XHQrICh2WzRdIC0gdls2XSkgKiAodls3XSArIHZbNV0pO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IFswLCAwXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKylcblx0XHRcdEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSxcblx0XHRcdFx0XHRpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0X2FkZEJvdW5kczogZnVuY3Rpb24odjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcblx0XHRmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcblx0XHRcdHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuXHRcdFx0XHRyaWdodCA9IHZhbHVlICsgcGFkZGluZztcblx0XHRcdGlmIChsZWZ0IDwgbWluW2Nvb3JkXSlcblx0XHRcdFx0bWluW2Nvb3JkXSA9IGxlZnQ7XG5cdFx0XHRpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuXHRcdFx0XHRtYXhbY29vcmRdID0gcmlnaHQ7XG5cdFx0fVxuXHRcdHZhciBhID0gMyAqICh2MSAtIHYyKSAtIHYwICsgdjMsXG5cdFx0XHRiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcblx0XHRcdGMgPSB2MSAtIHYwLFxuXHRcdFx0Y291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMpLFxuXHRcdFx0dE1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGFkZCh2MywgMCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdCA9IHJvb3RzW2ldLFxuXHRcdFx0XHR1ID0gMSAtIHQ7XG5cdFx0XHRpZiAodE1pbiA8IHQgJiYgdCA8IHRNYXgpXG5cdFx0XHRcdGFkZCh1ICogdSAqIHUgKiB2MFxuXHRcdFx0XHRcdCsgMyAqIHUgKiB1ICogdCAqIHYxXG5cdFx0XHRcdFx0KyAzICogdSAqIHQgKiB0ICogdjJcblx0XHRcdFx0XHQrIHQgKiB0ICogdCAqIHYzLFxuXHRcdFx0XHRcdHBhZGRpbmcpO1xuXHRcdH1cblx0fVxufX0sIEJhc2UuZWFjaChbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJywgJ2dldFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShbdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuXHRcdH07XG5cdH0sXG57XG5cbn0pLCBCYXNlLmVhY2goWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXSxcblx0ZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgaXNQYXJhbWV0ZXJcblx0XHRcdFx0XHQ/IG9mZnNldCA6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSwgaW5kZXgpO1xuXHRcdH07XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuXHRcdFx0cmV0dXJuIEN1cnZlLmV2YWx1YXRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciwgaW5kZXgpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLmdldFZhbHVlcygpLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0aWYgKCFpc1BhcmFtZXRlcilcblx0XHRcdG9mZnNldCA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gb2Zmc2V0ID49IDAgJiYgb2Zmc2V0IDw9IDEgJiYgbmV3IEN1cnZlTG9jYXRpb24odGhpcywgb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbkF0KHRoaXMuZ2V0UGFyYW1ldGVyT2YoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0dHJ1ZSk7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRjb3VudCA9IDEwMCxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pblQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lKHQpIHtcblx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG5cdFx0XHRcdHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoXG5cdFx0XHRcdFx0XHRDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDApLCB0cnVlKTtcblx0XHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XG5cdFx0XHRcdFx0bWluVCA9IHQ7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKVxuXHRcdFx0cmVmaW5lKGkgLyBjb3VudCk7XG5cblx0XHR2YXIgc3RlcCA9IDEgLyAoY291bnQgKiAyKTtcblx0XHR3aGlsZSAoc3RlcCA+IDAuMDAwMDAxKSB7XG5cdFx0XHRpZiAoIXJlZmluZShtaW5UIC0gc3RlcCkgJiYgIXJlZmluZShtaW5UICsgc3RlcCkpXG5cdFx0XHRcdHN0ZXAgLz0gMjtcblx0XHR9XG5cdFx0dmFyIHB0ID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCBtaW5ULCAwKTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgbWluVCwgcHQsIG51bGwsIG51bGwsIG51bGwsXG5cdFx0XHRcdHBvaW50LmdldERpc3RhbmNlKHB0KSk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKS5nZXRQb2ludCgpO1xuXHR9XG5cbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldExlbmd0aEludGVncmFuZCh2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cblx0XHRcdGF4ID0gOSAqIChjMXggLSBjMngpICsgMyAqIChwMnggLSBwMXgpLFxuXHRcdFx0YnggPSA2ICogKHAxeCArIGMyeCkgLSAxMiAqIGMxeCxcblx0XHRcdGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXG5cdFx0XHRheSA9IDkgKiAoYzF5IC0gYzJ5KSArIDMgKiAocDJ5IC0gcDF5KSxcblx0XHRcdGJ5ID0gNiAqIChwMXkgKyBjMnkpIC0gMTIgKiBjMXksXG5cdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KTtcblxuXHRcdHJldHVybiBmdW5jdGlvbih0KSB7XG5cdFx0XHR2YXIgZHggPSAoYXggKiB0ICsgYngpICogdCArIGN4LFxuXHRcdFx0XHRkeSA9IChheSAqIHQgKyBieSkgKiB0ICsgY3k7XG5cdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SXRlcmF0aW9ucyhhLCBiKSB7XG5cdFx0cmV0dXJuIE1hdGgubWF4KDIsIE1hdGgubWluKDE2LCBNYXRoLmNlaWwoTWF0aC5hYnMoYiAtIGEpICogMzIpKSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdHN0YXRpY3M6IHRydWUsXG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKHYsIGEsIGIpIHtcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGEgPSAwO1xuXHRcdFx0aWYgKGIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YiA9IDE7XG5cdFx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRcdGlmIChhID09PSAwICYmIGIgPT09IDFcblx0XHRcdFx0XHQmJiBpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0XHQmJiBpc1plcm8odls2XSAtIHZbNF0pICYmIGlzWmVybyh2WzddIC0gdls1XSkpIHtcblx0XHRcdFx0dmFyIGR4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdFx0ZHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodik7XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYiwgZ2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0fSxcblxuXHRcdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDBcblx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiBzdGFydDtcblx0XHRcdHZhciBmb3J3YXJkID0gb2Zmc2V0ID4gMCxcblx0XHRcdFx0YSA9IGZvcndhcmQgPyBzdGFydCA6IDAsXG5cdFx0XHRcdGIgPSBmb3J3YXJkID8gMSA6IHN0YXJ0LFxuXHRcdFx0XHRkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcblx0XHRcdFx0cmFuZ2VMZW5ndGggPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLFxuXHRcdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0XHRpZiAoTWF0aC5hYnMob2Zmc2V0KSA+PSByYW5nZUxlbmd0aClcblx0XHRcdFx0cmV0dXJuIGZvcndhcmQgPyBiIDogYTtcblx0XHRcdHZhciBndWVzcyA9IG9mZnNldCAvIHJhbmdlTGVuZ3RoLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0ZnVuY3Rpb24gZih0KSB7XG5cdFx0XHRcdGxlbmd0aCArPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCxcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoc3RhcnQsIHQpKTtcblx0XHRcdFx0c3RhcnQgPSB0O1xuXHRcdFx0XHRyZXR1cm4gbGVuZ3RoIC0gb2Zmc2V0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5maW5kUm9vdChmLCBkcywgc3RhcnQgKyBndWVzcywgYSwgYiwgMTYsXG5cdFx0XHRcdFx0MC4wMDAwMDEpO1xuXHRcdH1cblx0fTtcbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gYWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsXG5cdFx0XHRwb2ludDIpIHtcblx0XHR2YXIgbG9jID0gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUxLCB0MSwgcG9pbnQxLCBjdXJ2ZTIsIHQyLCBwb2ludDIpO1xuXHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpXG5cdFx0XHRsb2NhdGlvbnMucHVzaChsb2MpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdHRNaW4sIHRNYXgsIHVNaW4sIHVNYXgsIG9sZFREaWZmLCByZXZlcnNlLCByZWN1cnNpb24pIHtcblx0XHRpZiAocmVjdXJzaW9uID4gMzIpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHEweCA9IHYyWzBdLCBxMHkgPSB2MlsxXSwgcTN4ID0gdjJbNl0sIHEzeSA9IHYyWzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSB8fCAwLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSkgfHwgMCxcblx0XHRcdGZhY3RvciA9IGQxICogZDIgPiAwID8gMyAvIDQgOiA0IC8gOSxcblx0XHRcdGRNaW4gPSBmYWN0b3IgKiBNYXRoLm1pbigwLCBkMSwgZDIpLFxuXHRcdFx0ZE1heCA9IGZhY3RvciAqIE1hdGgubWF4KDAsIGQxLCBkMiksXG5cdFx0XHRkcDAgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzBdLCB2MVsxXSksXG5cdFx0XHRkcDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzJdLCB2MVszXSksXG5cdFx0XHRkcDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzRdLCB2MVs1XSksXG5cdFx0XHRkcDMgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYxWzZdLCB2MVs3XSksXG5cdFx0XHR0TWluTmV3LCB0TWF4TmV3LCB0RGlmZjtcblx0XHRpZiAocTB4ID09PSBxM3ggJiYgdU1heCAtIHVNaW4gPD0gdG9sZXJhbmNlICYmIHJlY3Vyc2lvbiA+IDMpIHtcblx0XHRcdHRNYXhOZXcgPSB0TWluTmV3ID0gKHRNYXggKyB0TWluKSAvIDI7XG5cdFx0XHR0RGlmZiA9IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBodWxsID0gZ2V0Q29udmV4SHVsbChkcDAsIGRwMSwgZHAyLCBkcDMpLFxuXHRcdFx0XHR0b3AgPSBodWxsWzBdLFxuXHRcdFx0XHRib3R0b20gPSBodWxsWzFdLFxuXHRcdFx0XHR0TWluQ2xpcCwgdE1heENsaXA7XG5cdFx0XHR0TWluQ2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KTtcblx0XHRcdHRvcC5yZXZlcnNlKCk7XG5cdFx0XHRib3R0b20ucmV2ZXJzZSgpO1xuXHRcdFx0dE1heENsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCk7XG5cdFx0XHRpZiAodE1pbkNsaXAgPT0gbnVsbCB8fCB0TWF4Q2xpcCA9PSBudWxsKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG5cdFx0XHR0RGlmZiA9IHRNYXhDbGlwIC0gdE1pbkNsaXA7XG5cdFx0XHR0TWluTmV3ID0gdE1heCAqIHRNaW5DbGlwICsgdE1pbiAqICgxIC0gdE1pbkNsaXApO1xuXHRcdFx0dE1heE5ldyA9IHRNYXggKiB0TWF4Q2xpcCArIHRNaW4gKiAoMSAtIHRNYXhDbGlwKTtcblx0XHR9XG5cdFx0aWYgKG9sZFREaWZmID4gMC41ICYmIHREaWZmID4gMC41KSB7XG5cdFx0XHRpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1TWF4IC0gdU1pbikge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjEsIDAuNSksXG5cdFx0XHRcdFx0dCA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMjtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHYyLCBwYXJ0c1swXSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0TWluTmV3LCB0LCB0RGlmZiwgIXJldmVyc2UsICsrcmVjdXJzaW9uKTtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHYyLCBwYXJ0c1sxXSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjIsIDAuNSksXG5cdFx0XHRcdFx0dCA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHBhcnRzWzBdLCB2MSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHR1TWluLCB0LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsICsrcmVjdXJzaW9uKTtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHBhcnRzWzFdLCB2MSwgY3VydmUyLCBjdXJ2ZTEsIGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHR0LCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChNYXRoLm1heCh1TWF4IC0gdU1pbiwgdE1heE5ldyAtIHRNaW5OZXcpIDwgdG9sZXJhbmNlKSB7XG5cdFx0XHR2YXIgdDEgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDIsXG5cdFx0XHRcdHQyID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0aWYgKHJldmVyc2UpIHtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0Y3VydmUyLCB0MiwgQ3VydmUuZXZhbHVhdGUodjIsIHQyLCAwKSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodERpZmYgPiAwKSB7XG5cdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnModjIsIHYxLCBjdXJ2ZTIsIGN1cnZlMSwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgKytyZWN1cnNpb24pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldENvbnZleEh1bGwoZHEwLCBkcTEsIGRxMiwgZHEzKSB7XG5cdFx0dmFyIHAwID0gWyAwLCBkcTAgXSxcblx0XHRcdHAxID0gWyAxIC8gMywgZHExIF0sXG5cdFx0XHRwMiA9IFsgMiAvIDMsIGRxMiBdLFxuXHRcdFx0cDMgPSBbIDEsIGRxMyBdLFxuXHRcdFx0Z2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuXHRcdFx0ZGlzdDEgPSBnZXRTaWduZWREaXN0YW5jZSgwLCBkcTAsIDEsIGRxMywgMSAvIDMsIGRxMSksXG5cdFx0XHRkaXN0MiA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAyIC8gMywgZHEyKSxcblx0XHRcdGZsaXAgPSBmYWxzZSxcblx0XHRcdGh1bGw7XG5cdFx0aWYgKGRpc3QxICogZGlzdDIgPCAwKSB7XG5cdFx0XHRodWxsID0gW1twMCwgcDEsIHAzXSwgW3AwLCBwMiwgcDNdXTtcblx0XHRcdGZsaXAgPSBkaXN0MSA8IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwbWF4LCBjcm9zcyA9IDAsXG5cdFx0XHRcdGRpc3RaZXJvID0gZGlzdDEgPT09IDAgfHwgZGlzdDIgPT09IDA7XG5cdFx0XHRpZiAoTWF0aC5hYnMoZGlzdDEpID4gTWF0aC5hYnMoZGlzdDIpKSB7XG5cdFx0XHRcdHBtYXggPSBwMTtcblx0XHRcdFx0Y3Jvc3MgPSAoZHEzIC0gZHEyIC0gKGRxMyAtIGRxMCkgLyAzKVxuXHRcdFx0XHRcdFx0KiAoMiAqIChkcTMgLSBkcTIpIC0gZHEzICsgZHExKSAvIDM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwbWF4ID0gcDI7XG5cdFx0XHRcdGNyb3NzID0gKGRxMSAtIGRxMCArIChkcTAgLSBkcTMpIC8gMylcblx0XHRcdFx0XHRcdCogKC0yICogKGRxMCAtIGRxMSkgKyBkcTAgLSBkcTIpIC8gMztcblx0XHRcdH1cblx0XHRcdGh1bGwgPSBjcm9zcyA8IDAgfHwgZGlzdFplcm9cblx0XHRcdFx0XHQ/IFtbcDAsIHBtYXgsIHAzXSwgW3AwLCBwM11dXG5cdFx0XHRcdFx0OiBbW3AwLCBwMSwgcDIsIHAzXSwgW3AwLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxID8gZGlzdDEgPCAwIDogZGlzdDIgPCAwO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxpcCA/IGh1bGwucmV2ZXJzZSgpIDogaHVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsKGh1bGxUb3AsIGh1bGxCb3R0b20sIGRNaW4sIGRNYXgpIHtcblx0XHRpZiAoaHVsbFRvcFswXVsxXSA8IGRNaW4pIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbFRvcCwgdHJ1ZSwgZE1pbik7XG5cdFx0fSBlbHNlIGlmIChodWxsQm90dG9tWzBdWzFdID4gZE1heCkge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsQm90dG9tLCBmYWxzZSwgZE1heCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBodWxsVG9wWzBdWzBdO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNsaXBDb252ZXhIdWxsUGFydChwYXJ0LCB0b3AsIHRocmVzaG9sZCkge1xuXHRcdHZhciBweCA9IHBhcnRbMF1bMF0sXG5cdFx0XHRweSA9IHBhcnRbMF1bMV07XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBwYXJ0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHF4ID0gcGFydFtpXVswXSxcblx0XHRcdFx0cXkgPSBwYXJ0W2ldWzFdO1xuXHRcdFx0aWYgKHRvcCA/IHF5ID49IHRocmVzaG9sZCA6IHF5IDw9IHRocmVzaG9sZClcblx0XHRcdFx0cmV0dXJuIHB4ICsgKHRocmVzaG9sZCAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdHB4ID0gcXg7XG5cdFx0XHRweSA9IHF5O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLFxuXHRcdFx0aW5jbHVkZSkge1xuXHRcdHZhciBmbGlwID0gQ3VydmUuaXNMaW5lYXIodjEpLFxuXHRcdFx0dmMgPSBmbGlwID8gdjIgOiB2MSxcblx0XHRcdHZsID0gZmxpcCA/IHYxIDogdjIsXG5cdFx0XHRseDEgPSB2bFswXSwgbHkxID0gdmxbMV0sXG5cdFx0XHRseDIgPSB2bFs2XSwgbHkyID0gdmxbN10sXG5cdFx0XHRsZHggPSBseDIgLSBseDEsXG5cdFx0XHRsZHkgPSBseTIgLSBseTEsXG5cdFx0XHRhbmdsZSA9IE1hdGguYXRhbjIoLWxkeSwgbGR4KSxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcblx0XHRcdHJseDIgPSBsZHggKiBjb3MgLSBsZHkgKiBzaW4sXG5cdFx0XHRydmwgPSBbMCwgMCwgMCwgMCwgcmx4MiwgMCwgcmx4MiwgMF0sXG5cdFx0XHRydmMgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG5cdFx0XHR2YXIgeCA9IHZjW2ldIC0gbHgxLFxuXHRcdFx0XHR5ID0gdmNbaSArIDFdIC0gbHkxO1xuXHRcdFx0cnZjLnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR5ICogY29zICsgeCAqIHNpbik7XG5cdFx0fVxuXHRcdHZhciByb290cyA9IFtdLFxuXHRcdFx0Y291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHJ2YywgMSwgMCwgcm9vdHMsIDAsIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHRjID0gcm9vdHNbaV0sXG5cdFx0XHRcdHggPSBDdXJ2ZS5ldmFsdWF0ZShydmMsIHRjLCAwKS54O1xuXHRcdFx0aWYgKHggPj0gMCAmJiB4IDw9IHJseDIpIHtcblx0XHRcdFx0dmFyIHRsID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YocnZsLCB4LCAwKSxcblx0XHRcdFx0XHR0MSA9IGZsaXAgPyB0bCA6IHRjLFxuXHRcdFx0XHRcdHQyID0gZmxpcCA/IHRjIDogdGw7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgY3VydmUxLCBjdXJ2ZTIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdHZhciBwb2ludCA9IExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR2MVswXSwgdjFbMV0sIHYxWzZdLCB2MVs3XSxcblx0XHRcdFx0djJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuXHRcdGlmIChwb2ludCkge1xuXHRcdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0XHR5ID0gcG9pbnQueTtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRjdXJ2ZTEsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYxLCB4LCB5KSwgcG9pbnQsXG5cdFx0XHRcdFx0Y3VydmUyLCBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MiwgeCwgeSksIHBvaW50KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24odjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgaW5jbHVkZSkge1xuXHRcdFx0dmFyIGxpbmVhcjEgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG5cdFx0XHRcdGxpbmVhcjIgPSBDdXJ2ZS5pc0xpbmVhcih2MiksXG5cdFx0XHRcdGMxcDEgPSBjMS5nZXRQb2ludDEoKSxcblx0XHRcdFx0YzFwMiA9IGMxLmdldFBvaW50MigpLFxuXHRcdFx0XHRjMnAxID0gYzIuZ2V0UG9pbnQxKCksXG5cdFx0XHRcdGMycDIgPSBjMi5nZXRQb2ludDIoKSxcblx0XHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0XHRpZiAoYzFwMS5pc0Nsb3NlKGMycDEsIHRvbGVyYW5jZSkpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIDAsIGMxcDEsIGMyLCAwLCBjMXAxKTtcblx0XHRcdGlmIChjMXAxLmlzQ2xvc2UoYzJwMiwgdG9sZXJhbmNlKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLCBjMSwgMCwgYzFwMSwgYzIsIDEsIGMxcDEpO1xuXHRcdFx0KGxpbmVhcjEgJiYgbGluZWFyMlxuXHRcdFx0XHQ/IGFkZExpbmVJbnRlcnNlY3Rpb25cblx0XHRcdFx0OiBsaW5lYXIxIHx8IGxpbmVhcjJcblx0XHRcdFx0XHQ/IGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnNcblx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHR2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0MCwgMSwgMCwgMSwgMCwgZmFsc2UsIDApO1xuXHRcdFx0aWYgKGMxcDIuaXNDbG9zZShjMnAxLCB0b2xlcmFuY2UpKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGMxLCAxLCBjMXAyLCBjMiwgMCwgYzFwMik7XG5cdFx0XHRpZiAoYzFwMi5pc0Nsb3NlKGMycDIsIHRvbGVyYW5jZSkpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSwgYzEsIDEsIGMxcDIsIGMyLCAxLCBjMXAyKTtcblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fSxcblxuXHRcdGZpbHRlckludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGxvY2F0aW9ucywgX2V4cGFuZCkge1xuXHRcdFx0dmFyIGxhc3QgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMSxcblx0XHRcdFx0dE1heCA9IDEgLSAwLjAwMDAwMTtcblx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgbG9jID0gbG9jYXRpb25zW2ldLFxuXHRcdFx0XHRcdG5leHQgPSBsb2MuX2N1cnZlLmdldE5leHQoKSxcblx0XHRcdFx0XHRuZXh0MiA9IGxvYy5fY3VydmUyLmdldE5leHQoKTtcblx0XHRcdFx0aWYgKG5leHQgJiYgbG9jLl9wYXJhbWV0ZXIgPj0gdE1heCkge1xuXHRcdFx0XHRcdGxvYy5fcGFyYW1ldGVyID0gMDtcblx0XHRcdFx0XHRsb2MuX2N1cnZlID0gbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmV4dDIgJiYgbG9jLl9wYXJhbWV0ZXIyID49IHRNYXgpIHtcblx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwO1xuXHRcdFx0XHRcdGxvYy5fY3VydmUyID0gbmV4dDI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY29tcGFyZShsb2MxLCBsb2MyKSB7XG5cdFx0XHRcdHZhciBwYXRoMSA9IGxvYzEuZ2V0UGF0aCgpLFxuXHRcdFx0XHRcdHBhdGgyID0gbG9jMi5nZXRQYXRoKCk7XG5cdFx0XHRcdHJldHVybiBwYXRoMSA9PT0gcGF0aDJcblx0XHRcdFx0XHRcdD8gKGxvYzEuZ2V0SW5kZXgoKSArIGxvYzEuZ2V0UGFyYW1ldGVyKCkpXG5cdFx0XHRcdFx0XHRcdFx0LSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0XHRcdDogcGF0aDEuX2lkIC0gcGF0aDIuX2lkO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGFzdCA+IDApIHtcblx0XHRcdFx0bG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBsYXN0OyBpID4gMDsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGxvY2F0aW9uc1tpXS5lcXVhbHMobG9jYXRpb25zW2kgLSAxXSkpIHtcblx0XHRcdFx0XHRcdGxvY2F0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRsYXN0LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoX2V4cGFuZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gbGFzdDsgaSA+PSAwOyBpLS0pXG5cdFx0XHRcdFx0bG9jYXRpb25zLnB1c2gobG9jYXRpb25zW2ldLmdldEludGVyc2VjdGlvbigpKTtcblx0XHRcdFx0bG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdH1cblx0fX07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCBwYXJhbWV0ZXIsIHBvaW50LCBfY3VydmUyLFxuXHRcdFx0X3BhcmFtZXRlcjIsIF9wb2ludDIsIF9kaXN0YW5jZSkge1xuXHRcdHRoaXMuX2lkID0gQ3VydmVMb2NhdGlvbi5faWQgPSAoQ3VydmVMb2NhdGlvbi5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0dGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdFx0dGhpcy5fY3VydmUyID0gX2N1cnZlMjtcblx0XHR0aGlzLl9wYXJhbWV0ZXIyID0gX3BhcmFtZXRlcjI7XG5cdFx0dGhpcy5fcG9pbnQyID0gX3BvaW50Mjtcblx0XHR0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbihfcHJlZmVyRmlyc3QpIHtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0cGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyID09PSAwIHx8IF9wcmVmZXJGaXJzdCkge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcilcblx0XHRcdFx0XHQ8IGN1cnZlLmdldFBhcnRMZW5ndGgocGFyYW1ldGVyLCAxKVxuXHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHRcdDogY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG5cdFx0aWYgKCF0aGlzLl9jdXJ2ZSB8fCBfdW5jYWNoZWQpIHtcblx0XHRcdHRoaXMuX2N1cnZlID0gdGhpcy5fc2VnbWVudDEuZ2V0Q3VydmUoKTtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLl9wb2ludCkgPT0gbnVsbClcblx0XHRcdFx0dGhpcy5fY3VydmUgPSB0aGlzLl9zZWdtZW50Mi5nZXRQcmV2aW91cygpLmdldEN1cnZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jdXJ2ZTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcnNlY3Rpb24gJiYgdGhpcy5fY3VydmUyKSB7XG5cdFx0XHR2YXIgcGFyYW0gPSB0aGlzLl9wYXJhbWV0ZXIyO1xuXHRcdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uID0gbmV3IEN1cnZlTG9jYXRpb24oXG5cdFx0XHRcdFx0dGhpcy5fY3VydmUyLCBwYXJhbSwgdGhpcy5fcG9pbnQyIHx8IHRoaXMuX3BvaW50LCB0aGlzKTtcblx0XHRcdGludGVyc2VjdGlvbi5faW50ZXJzZWN0aW9uID0gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xuXHRcdHJldHVybiBwYXRoID8gcGF0aC5fZ2V0T2Zmc2V0KHRoaXMpIDogdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdHJldHVybiBwYXJhbWV0ZXIgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcik7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyOiBmdW5jdGlvbihfdW5jYWNoZWQpIHtcblx0XHRpZiAoKHRoaXMuX3BhcmFtZXRlciA9PSBudWxsIHx8IF91bmNhY2hlZCkgJiYgdGhpcy5fcG9pbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoX3VuY2FjaGVkKTtcblx0XHRcdHRoaXMuX3BhcmFtZXRlciA9IGN1cnZlICYmIGN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuX3BvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmFtZXRlcjtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG5cdFx0aWYgKCghdGhpcy5fcG9pbnQgfHwgX3VuY2FjaGVkKSAmJiB0aGlzLl9wYXJhbWV0ZXIgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZShfdW5jYWNoZWQpO1xuXHRcdFx0dGhpcy5fcG9pbnQgPSBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQb2ludEF0KHRoaXMuX3BhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZGl2aWRlKHRoaXMuZ2V0UGFyYW1ldGVyKHRydWUpLCB0cnVlKTtcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSh0cnVlKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuc3BsaXQodGhpcy5nZXRQYXJhbWV0ZXIodHJ1ZSksIHRydWUpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obG9jKSB7XG5cdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMDE7XG5cdFx0cmV0dXJuIHRoaXMgPT09IGxvY1xuXHRcdFx0XHR8fCBsb2Ncblx0XHRcdFx0XHQmJiB0aGlzLl9jdXJ2ZSA9PT0gbG9jLl9jdXJ2ZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2N1cnZlMiA9PT0gbG9jLl9jdXJ2ZTJcblx0XHRcdFx0XHQmJiBhYnModGhpcy5fcGFyYW1ldGVyIC0gbG9jLl9wYXJhbWV0ZXIpIDw9IHRvbGVyYW5jZVxuXHRcdFx0XHRcdCYmIGFicyh0aGlzLl9wYXJhbWV0ZXIyIC0gbG9jLl9wYXJhbWV0ZXIyKSA8PSB0b2xlcmFuY2Vcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdGlmIChwYXJhbWV0ZXIgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3BhcmFtZXRlcjogJyArIGYubnVtYmVyKHBhcmFtZXRlcikpO1xuXHRcdGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0ocGFyYW1ldGVyLCB0cnVlKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIF9tYXRyaXgsIF9leHBhbmQpIHtcblx0XHRpZiAodGhpcyA9PT0gcGF0aClcblx0XHRcdHBhdGggPSBudWxsO1xuXHRcdHZhciBsb2NhdGlvbnMgPSBbXSxcblx0XHRcdGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHBhdGggPyAoX21hdHJpeCB8fCBwYXRoLl9tYXRyaXgpLm9yTnVsbElmSWRlbnRpdHkoKVxuXHRcdFx0XHQ6IG1hdHJpeDEsXG5cdFx0XHRsZW5ndGgxID0gY3VydmVzMS5sZW5ndGgsXG5cdFx0XHRsZW5ndGgyID0gcGF0aCA/IGN1cnZlczIubGVuZ3RoIDogbGVuZ3RoMSxcblx0XHRcdHZhbHVlczIgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAocGF0aCAmJiAhdGhpcy5nZXRCb3VuZHMobWF0cml4MSkudG91Y2hlcyhwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSkpXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG5cdFx0XHR2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2ldLFxuXHRcdFx0XHR2YWx1ZXMxID0gcGF0aCA/IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSkgOiB2YWx1ZXMyW2ldO1xuXHRcdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRcdHZhciBzZWcxID0gY3VydmUxLmdldFNlZ21lbnQxKCksXG5cdFx0XHRcdFx0c2VnMiA9IGN1cnZlMS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdGgxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdGgyID0gc2VnMi5faGFuZGxlSW47XG5cdFx0XHRcdGlmIChuZXcgTGluZShzZWcxLl9wb2ludC5zdWJ0cmFjdChoMSksIGgxLm11bHRpcGx5KDIpLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmludGVyc2VjdChuZXcgTGluZShzZWcyLl9wb2ludC5zdWJ0cmFjdChoMiksXG5cdFx0XHRcdFx0XHRoMi5tdWx0aXBseSgyKSwgdHJ1ZSksIGZhbHNlKSkge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2YWx1ZXMxKTtcblx0XHRcdFx0XHRDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0cGFydHNbMF0sIHBhcnRzWzFdLCBjdXJ2ZTEsIGN1cnZlMSwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsb2MuX3BhcmFtZXRlciA8PSB0TWF4KSB7XG5cdFx0XHRcdFx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgLz0gMjtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlcjIgPSAwLjUgKyBsb2MuX3BhcmFtZXRlcjIgLyAyO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHBhdGggPyAwIDogaSArIDE7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0Q3VydmUuZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlczJbal0sIGxvY2F0aW9ucyxcblx0XHRcdFx0XHQhcGF0aCAmJiAoaiA9PT0gaSArIDEgfHwgaiA9PT0gbGVuZ3RoMiAtIDEgJiYgaSA9PT0gMClcblx0XHRcdFx0XHRcdCYmIGZ1bmN0aW9uKGxvYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdCA+PSB0TWluICYmIHQgPD0gdE1heDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIEN1cnZlLmZpbHRlckludGVyc2VjdGlvbnMobG9jYXRpb25zLCBfZXhwYW5kKTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQgPSBzdGFydCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGlmIChtb3ZlICYmIHByZXZpb3VzICYmIHByZXZpb3VzICE9PSAneicpXG5cdFx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpXG5cdFx0XHRcdFx0dGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChtb3ZlKVxuXHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuXHRcdHJldHVybiAhISh0aGlzLmdldFdpbmRpbmdSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcgJiAxIDogd2luZGluZyk7XG5cdH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR2YXIgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZylcblx0XHRcdD8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0PyBhcmdcblx0XHRcdFx0OiBhcmd1bWVudHNcblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3VtZW50c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHVuZGVmaW5lZDtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZXMgJiYgIShmbGFncyAmIDE2KSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9tb25vQ3VydmVzID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSlcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goJ2wnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuXHRcdFx0cGFydHMucHVzaCgneicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMuam9pbignJyk7XG5cdH1cbn0sIHtcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5fc2VnbWVudHNbaV0uaXNMaW5lYXIoKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgdHJ1ZSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2FkZDogZnVuY3Rpb24oc2VncywgaW5kZXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGFtb3VudCA9IHNlZ3MubGVuZ3RoLFxuXHRcdFx0YXBwZW5kID0gaW5kZXggPT0gbnVsbCxcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gc2VnbWVudHMubGVuZ3RoIDogaW5kZXg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdzW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3BhdGgpXG5cdFx0XHRcdHNlZ21lbnQgPSBzZWdzW2ldID0gc2VnbWVudC5jbG9uZSgpO1xuXHRcdFx0c2VnbWVudC5fcGF0aCA9IHRoaXM7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIDAsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKTtcblx0XHR9XG5cdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgc2Vncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNlZ21lbnRzLnNwbGljZS5hcHBseShzZWdtZW50cywgW2luZGV4LCAwXS5jb25jYXQoc2VncykpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdH1cblx0XHRpZiAoY3VydmVzIHx8IHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0aWYgKCFjdXJ2ZXMpXG5cdFx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGZyb20gPSBpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBpbmRleCxcblx0XHRcdFx0c3RhcnQgPSBmcm9tLFxuXHRcdFx0XHR0byA9IE1hdGgubWluKGZyb20gKyBhbW91bnQsIHRoaXMuX2NvdW50Q3VydmVzKCkpO1xuXHRcdFx0aWYgKHNlZ3MuX2N1cnZlcykge1xuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlLmFwcGx5KGN1cnZlcywgW2Zyb20sIDBdLmNvbmNhdChzZWdzLl9jdXJ2ZXMpKTtcblx0XHRcdFx0c3RhcnQgKz0gc2Vncy5fY3VydmVzLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHRvOyBpKyspXG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UoaSwgMCwgbmV3IEN1cnZlKHRoaXMsIG51bGwsIG51bGwpKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhmcm9tLCB0byk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiBzZWdzO1xuXHR9LFxuXG5cdF9hZGp1c3RDdXJ2ZXM6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjdXJ2ZTtcblx0XHRmb3IgKHZhciBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcblx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0Y3VydmUuX3BhdGggPSB0aGlzO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbaV07XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tpICsgMV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmIGZyb20gPT09IDAgPyBzZWdtZW50cy5sZW5ndGggLSAxXG5cdFx0XHRcdDogZnJvbSAtIDFdKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDIgPSBzZWdtZW50c1tmcm9tXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0b10pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW3RvXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jb3VudEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzKSlcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbihpbmRleCwgc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMsIDEpLCBpbmRleClcblx0XHRcdDogdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50OiBmdW5jdGlvbihpbmRleCApIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cywgMSkgXSwgaW5kZXgpWzBdO1xuXHR9LFxuXG5cdGFkZFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudHM6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50cykge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSwgaW5kZXgpO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIGluZGV4ICsgMSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50czogZnVuY3Rpb24oZnJvbSwgdG8sIF9pbmNsdWRlQ3VydmVzKSB7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fc2VnbWVudHMubGVuZ3RoKTtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnRzLnNwbGljZShmcm9tLCB0byAtIGZyb20pLFxuXHRcdFx0YW1vdW50ID0gcmVtb3ZlZC5sZW5ndGg7XG5cdFx0aWYgKCFhbW91bnQpXG5cdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHJlbW92ZWRbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSwgMCk7XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IHNlZ21lbnQuX3BhdGggPSBudWxsO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gZnJvbSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIGluZGV4ID0gZnJvbSA+IDAgJiYgdG8gPT09IGNvdW50ICsgKHRoaXMuX2Nsb3NlZCA/IDEgOiAwKVxuXHRcdFx0XHRcdD8gZnJvbSAtIDFcblx0XHRcdFx0XHQ6IGZyb20sXG5cdFx0XHRcdGN1cnZlcyA9IGN1cnZlcy5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG5cdFx0XHRpZiAoX2luY2x1ZGVDdXJ2ZXMpXG5cdFx0XHRcdHJlbW92ZWQuX2N1cnZlcyA9IGN1cnZlcy5zbGljZSgxKTtcblx0XHRcdHRoaXMuX2FkanVzdEN1cnZlcyhpbmRleCwgaW5kZXgpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVTZWdtZW50cycsXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fbGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHR2YXIgYXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjdXJ2ZXNbaV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9LFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQgJiYgbGVuZ3RoID4gMCAmJiB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZVxuXHRcdFx0XHQ9PT0gbGVuZ3RoICogNztcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbiBzZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuXHRcdGlmICghc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG5cdFx0c2V0U2VsZWN0ZWQuYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRfc2VsZWN0U2VnbWVudHM6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdD8gbGVuZ3RoICogNyA6IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl9zZWxlY3Rpb25TdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdFx0PyA3IDogMDtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzZWdtZW50LCBvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcblx0XHRzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdHZhciB0b3RhbCA9IHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlICs9IG5ld1N0YXRlIC0gb2xkU3RhdGU7XG5cdFx0aWYgKHRvdGFsID4gMClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR2YXIgaXRlcmF0b3IgPSBuZXcgUGF0aEl0ZXJhdG9yKHRoaXMsIDY0LCAwLjEpLFxuXHRcdFx0cG9zID0gMCxcblx0XHRcdHN0ZXAgPSBpdGVyYXRvci5sZW5ndGggLyBNYXRoLmNlaWwoaXRlcmF0b3IubGVuZ3RoIC8gbWF4RGlzdGFuY2UpLFxuXHRcdFx0ZW5kID0gaXRlcmF0b3IubGVuZ3RoICsgKHRoaXMuX2Nsb3NlZCA/IC1zdGVwIDogc3RlcCkgLyAyO1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdHdoaWxlIChwb3MgPD0gZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGl0ZXJhdG9yLmV2YWx1YXRlKHBvcywgMCkpKTtcblx0XHRcdHBvcyArPSBzdGVwO1xuXHRcdH1cblx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSBjdXJ2ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGlmIChjdXJ2ZS5pc0xpbmVhcigpICYmIGN1cnZlLmdldExlbmd0aCgpID09PSAwKVxuXHRcdFx0XHRjdXJ2ZS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2ltcGxpZnk6IGZ1bmN0aW9uKHRvbGVyYW5jZSkge1xuXHRcdGlmICh0aGlzLl9zZWdtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0XHR2YXIgZml0dGVyID0gbmV3IFBhdGhGaXR0ZXIodGhpcywgdG9sZXJhbmNlIHx8IDIuNSk7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKGZpdHRlci5maXQoKSk7XG5cdFx0fVxuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihpbmRleCwgcGFyYW1ldGVyKSB7XG5cdFx0aWYgKHBhcmFtZXRlciA9PT0gbnVsbClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgYXJnID0gaW5kZXg7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpXG5cdFx0XHRcdGFyZyA9IHRoaXMuZ2V0TG9jYXRpb25BdChhcmcpO1xuXHRcdFx0aWYgKCFhcmcpXG5cdFx0XHRcdHJldHVybiBudWxsXG5cdFx0XHRpbmRleCA9IGFyZy5pbmRleDtcblx0XHRcdHBhcmFtZXRlciA9IGFyZy5wYXJhbWV0ZXI7XG5cdFx0fVxuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblx0XHRpZiAocGFyYW1ldGVyID49IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdGluZGV4Kys7XG5cdFx0XHRwYXJhbWV0ZXItLTtcblx0XHR9XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0aWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBjdXJ2ZXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAocGFyYW1ldGVyID4gdG9sZXJhbmNlKSB7XG5cdFx0XHRcdGN1cnZlc1tpbmRleCsrXS5kaXZpZGUocGFyYW1ldGVyLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcblx0XHRcdFx0cGF0aDtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9zZWQoZmFsc2UpO1xuXHRcdFx0XHRwYXRoID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGggPSB0aGlzLl9jbG9uZShuZXcgUGF0aCgpLmluc2VydEFib3ZlKHRoaXMsIHRydWUpKTtcblx0XHRcdH1cblx0XHRcdHBhdGguX2FkZChzZWdzLCAwKTtcblx0XHRcdHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2Nsb2Nrd2lzZTtcblx0XHRyZXR1cm4gUGF0aC5pc0Nsb2Nrd2lzZSh0aGlzLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0XHR0aGlzLl9jbG9ja3dpc2UgPSBjbG9ja3dpc2U7XG5cdH0sXG5cblx0cmV2ZXJzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudHMucmV2ZXJzZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHRoaXMuX3NlZ21lbnRzW2ldO1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dCA9IGhhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpO1xuXHRcdH1cblx0XHR0aGlzLl9jdXJ2ZXMgPSBudWxsO1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHRoaXMuX2Nsb2Nrd2lzZSA9ICF0aGlzLl9jbG9ja3dpc2U7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRqb2luOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0XHRsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAoIWxhc3QyKVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpXG5cdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0dmFyIGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSkge1xuXHRcdFx0XHRsYXN0MS5zZXRIYW5kbGVPdXQoZmlyc3QyLl9oYW5kbGVPdXQpO1xuXHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGZpcnN0MSA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpXG5cdFx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0XHRmaXJzdDEuc2V0SGFuZGxlSW4obGFzdDIuX2hhbmRsZUluKTtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguY2xvc2VkKVxuXHRcdFx0XHR0aGlzLl9hZGQoW3NlZ21lbnRzWzBdXSk7XG5cdFx0XHRwYXRoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0bGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRpZiAoZmlyc3QgIT09IGxhc3QgJiYgZmlyc3QuX3BvaW50LmVxdWFscyhsYXN0Ll9wb2ludCkpIHtcblx0XHRcdGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcblx0XHRcdGxhc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKHBhdGgwLCBwYXRoMSwgY29lZikge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoICFwYXRoMC5fc2VnbWVudHNbaV0gfHwgIXBhdGgxLl9zZWdtZW50c1tpXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLmludGVycG9sYXRlKFxuXHRcdFx0XHRwYXRoMC5fc2VnbWVudHNbaV0sXG5cdFx0XHRcdHBhdGgxLl9zZWdtZW50c1tpXSxcblx0XHRcdFx0Y29lZlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdHRvU2hhcGU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdGlmICghdGhpcy5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRzaXplLFxuXHRcdFx0cmFkaXVzLFxuXHRcdFx0dG9wQ2VudGVyO1xuXG5cdFx0ZnVuY3Rpb24gaXNDb2xpbmVhcihpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNDb2xpbmVhcihzZWdtZW50c1tqXSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcblx0XHRcdHJldHVybiBzZWdtZW50c1tpXS5pc09ydGhvZ29uYWwoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0FyYyhpKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNBcmMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNQb2x5Z29uKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQ29saW5lYXIoMCwgMikgJiYgaXNDb2xpbmVhcigxLCAzKSAmJiBpc09ydGhvZ29uYWwoMSkpIHtcblx0XHRcdHR5cGUgPSBTaGFwZS5SZWN0YW5nbGU7XG5cdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0RGlzdGFuY2UoMCwgMyksIGdldERpc3RhbmNlKDAsIDEpKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludC5hZGQoc2VnbWVudHNbMl0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDggJiYgaXNBcmMoMCkgJiYgaXNBcmMoMikgJiYgaXNBcmMoNClcblx0XHRcdFx0JiYgaXNBcmMoNikgJiYgaXNDb2xpbmVhcigxLCA1KSAmJiBpc0NvbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gbmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdHNoYXBlLnJvdGF0ZSh0b3BDZW50ZXIuc3VidHJhY3QoY2VudGVyKS5nZXRBbmdsZSgpICsgOTApO1xuXHRcdFx0c2hhcGUuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c2hhcGUuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRyZXR1cm4gc2hhcGU7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcblx0XHRcdHJhZGl1cyA9IGhpdFN0cm9rZVxuXHRcdFx0XHRcdD8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuXHRcdFx0XHRcdFx0PyAwIDogbnVsbDtcblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAocmFkaXVzID4gMCkge1xuXHRcdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuXHRcdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcuYWRkKG5ldyBQb2ludChyYWRpdXMsIHJhZGl1cykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0am9pbiA9IGNhcCA9ICdyb3VuZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDbG9zZUVub3VnaChwdCwgcGFkZGluZykge1xuXHRcdFx0cmV0dXJuIHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuXHRcdFx0aWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2VnLl9wb2ludDtcblx0XHRcdFx0aWYgKHB0ICE9PSBhbmNob3IpXG5cdFx0XHRcdFx0cHQgPSBwdC5hZGQoYW5jaG9yKTtcblx0XHRcdFx0aWYgKGlzQ2xvc2VFbm91Z2gocHQsIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQobmFtZSwgdGhhdCwge1xuXHRcdFx0XHRcdFx0c2VnbWVudDogc2VnLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludHMoc2VnLCBlbmRzKSB7XG5cdFx0XHRyZXR1cm4gKGVuZHMgfHwgb3B0aW9ucy5zZWdtZW50cylcblx0XHRcdFx0JiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpXG5cdFx0XHRcdHx8ICghZW5kcyAmJiBvcHRpb25zLmhhbmRsZXMpICYmIChcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVPdXQsICdoYW5kbGUtb3V0JykpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuXHRcdFx0YXJlYS5hZGQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSB7XG5cdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyB8fCBjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YXJlYSA9IG5ldyBQYXRoKHsgaW50ZXJuYWw6IHRydWUsIGNsb3NlZDogdHJ1ZSB9KTtcblx0XHRcdFx0aWYgKGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcblx0XHRcdFx0XHRcdCYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgJiYgKHNlZ21lbnQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0XHRcdHx8IHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSkpXG5cdFx0XHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LFxuXHRcdFx0XHRcdFx0XHRcdGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYXJlYS5pc0VtcHR5KCkpIHtcblx0XHRcdFx0XHR2YXIgbG9jO1xuXHRcdFx0XHRcdHJldHVybiBhcmVhLmNvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHRcdFx0fHwgKGxvYyA9IGFyZWEuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KSlcblx0XHRcdFx0XHRcdFx0JiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpc0Nsb3NlRW5vdWdoKHNlZ21lbnQuX3BvaW50LCBzdHJva2VQYWRkaW5nKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5lbmRzICYmICFvcHRpb25zLnNlZ21lbnRzICYmICFjbG9zZWQpIHtcblx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbMF0sIHRydWUpXG5cdFx0XHRcdFx0fHwgY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0sIHRydWUpKVxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5zZWdtZW50cyB8fCBvcHRpb25zLmhhbmRsZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKylcblx0XHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0aWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0bG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYykge1xuXHRcdFx0XHR2YXIgcGFyYW1ldGVyID0gbG9jLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyID09PSAwIHx8IHBhcmFtZXRlciA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0XHRpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcblx0XHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFsb2MgJiYgam9pbiA9PT0gJ21pdGVyJyAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpIDw9IG1pdGVyTGltaXRcblx0XHRcdFx0XHRcdFx0JiYgY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpKSB7XG5cdFx0XHRcdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICFsb2MgJiYgaGl0RmlsbCAmJiB0aGlzLl9jb250YWlucyhwb2ludClcblx0XHRcdFx0fHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlc1xuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdFx0OiBsb2Ncblx0XHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdjdXJ2ZScsIHRoaXMsIHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IGxvYyxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGxvYy5nZXRQb2ludCgpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cbn0sIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lICsgJ0F0J10gPSBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIGxvYyAmJiBsb2NbbmFtZV0oKTtcblx0XHR9O1xuXHR9LFxue1xuXHRiZWFuczogZmFsc2UsXG5cblx0X2dldE9mZnNldDogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0XHR2YXIgaW5kZXggPSBsb2NhdGlvbiAmJiBsb2NhdGlvbi5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcblx0XHRcdFx0b2Zmc2V0ICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpbmRleF0sXG5cdFx0XHRcdHBhcmFtZXRlciA9IGxvY2F0aW9uLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+IDApXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcik7XG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcblx0XHRcdGlmIChsb2MpXG5cdFx0XHRcdHJldHVybiBsb2M7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRpZiAoaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciBpbmRleCA9IH5+b2Zmc2V0O1xuXHRcdFx0cmV0dXJuIGN1cnZlc1tpbmRleF0uZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpXG5cdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluTG9jID0gbnVsbDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuXHRcdFx0XHRtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcblx0XHRcdFx0bWluTG9jID0gbG9jO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluTG9jO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZ2V0UG9pbnQoKTtcblx0fVxufSksIG5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcblx0XHR2YXIgaGFsZiA9IHNpemUgLyAyO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuXHRcdFx0dmFyIGhYID0gY29vcmRzW2luZGV4XSxcblx0XHRcdFx0aFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblx0XHRcdGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocFgsIHBZKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhoWCwgaFkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0XHRwWCA9IGNvb3Jkc1swXSxcblx0XHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc3RhdGUgJiAxKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDIpO1xuXHRcdFx0aWYgKHN0YXRlICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSg0KTtcblx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cdFx0XHRpZiAoIShzdGF0ZSAmIDQpKSB7XG5cdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmICsgMSwgcFkgLSBoYWxmICsgMSwgc2l6ZSAtIDIsIHNpemUgLSAyKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3U2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0ICYmIHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRPZmZzZXQoaSkge1xuXHRcdFx0XHRyZXR1cm4gZGFzaEFycmF5WygoaSAlIGRhc2hMZW5ndGgpICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGl0ZXJhdG9yID0gbmV3IFBhdGhJdGVyYXRvcih0aGlzLCAzMiwgMC4yNSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBpdGVyYXRvci5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHRmcm9tID0gZnJvbSAlIGxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID4gMCkge1xuXHRcdFx0XHRcdFx0XHRmcm9tIC09IGdldE9mZnNldChpLS0pICsgZ2V0T2Zmc2V0KGktLSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZyb20gPiAwIHx8IHRvID4gMClcblx0XHRcdFx0XHRcdFx0XHRpdGVyYXRvci5kcmF3UGFydChjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuXHRcdFx0XHRcdFx0XHRmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0ZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocykge1xuXHRcdHZhciBuID0gcmhzLmxlbmd0aCxcblx0XHRcdHggPSBbXSxcblx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0YiA9IDI7XG5cdFx0eFswXSA9IHJoc1swXSAvIGI7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdHRtcFtpXSA9IDEgLyBiO1xuXHRcdFx0YiA9IChpIDwgbiAtIDEgPyA0IDogMikgLSB0bXBbaV07XG5cdFx0XHR4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuXHRcdH1cblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRzaXplID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHRcdG4gPSBzaXplLFxuXHRcdFx0XHRvdmVybGFwID0gMDtcblx0XHRcdGlmIChzaXplIDw9IDIpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0b3ZlcmxhcCA9IE1hdGgubWluKHNpemUsIDQpO1xuXHRcdFx0XHRuICs9IE1hdGgubWluKHNpemUsIG92ZXJsYXApICogMjtcblx0XHRcdH1cblx0XHRcdHZhciBrbm90cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG5cdFx0XHRcdGtub3RzW2kgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzW2kgKyBzaXplIC0gb3ZlcmxhcF0uX3BvaW50O1xuXHRcdFx0XHRcdGtub3RzW2kgKyBzaXplICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciByaHMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuXHRcdFx0XHRyaHNbaV0gPSA0ICoga25vdHNbaV0uX3ggKyAyICoga25vdHNbaSArIDFdLl94O1xuXHRcdFx0cmhzWzBdID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3g7XG5cdFx0XHRyaHNbbiAtIDFdID0gMyAqIGtub3RzW24gLSAxXS5feDtcblx0XHRcdHZhciB4ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl95ICsgMiAqIGtub3RzW2kgKyAxXS5feTtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3k7XG5cdFx0XHR2YXIgeSA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gc2l6ZTsgaSA8IG92ZXJsYXA7IGkrKywgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGYxID0gaSAvIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRmMiA9IDEgLSBmMSxcblx0XHRcdFx0XHRcdGllID0gaSArIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRqZSA9IGogKyBvdmVybGFwO1xuXHRcdFx0XHRcdHhbal0gPSB4W2ldICogZjEgKyB4W2pdICogZjI7XG5cdFx0XHRcdFx0eVtqXSA9IHlbaV0gKiBmMSArIHlbal0gKiBmMjtcblx0XHRcdFx0XHR4W2plXSA9IHhbaWVdICogZjIgKyB4W2plXSAqIGYxO1xuXHRcdFx0XHRcdHlbamVdID0geVtpZV0gKiBmMiArIHlbamVdICogZjE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bi0tO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZUluID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSBvdmVybGFwOyBpIDw9IG4gLSBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpIC0gb3ZlcmxhcF07XG5cdFx0XHRcdGlmIChoYW5kbGVJbilcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdGlmIChpIDwgbikge1xuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KFxuXHRcdFx0XHRcdFx0XHRuZXcgUG9pbnQoeFtpXSwgeVtpXSkuc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGkgPCBuIC0gMVxuXHRcdFx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQyICoga25vdHNbaSArIDFdLl94IC0geFtpICsgMV0sXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feSAtIHlbaSArIDFdKVxuXHRcdFx0XHRcdFx0XHQ6IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3ggKyB4W24gLSAxXSkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdChrbm90c1tuXS5feSArIHlbbiAtIDFdKSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkICYmIGhhbmRsZUluKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHR0aGlzLnJlbW92ZVNlZ21lbnQoMCk7XG5cdFx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbW92ZUJ5KCkgaXMgdW5zdXBwb3J0ZWQgb24gUGF0aCBpdGVtcy4nKTtcblx0XHR9LFxuXG5cdFx0bGluZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKTtcblx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KGhhbmRsZTEuc3VidHJhY3QoY3VycmVudC5fcG9pbnQpKTtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KHRvLCBoYW5kbGUyLnN1YnRyYWN0KHRvKSkgXSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0aGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0aGFuZGxlLmFkZCh0by5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdHRvXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dCA9IEJhc2UucGljayhCYXNlLnJlYWQoYXJndW1lbnRzKSwgMC41KSxcblx0XHRcdFx0dDEgPSAxIC0gdCxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0aGFuZGxlID0gdGhyb3VnaC5zdWJ0cmFjdChjdXJyZW50Lm11bHRpcGx5KHQxICogdDEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdCh0by5tdWx0aXBseSh0ICogdCkpLmRpdmlkZSgyICogdCAqIHQxKTtcblx0XHRcdGlmIChoYW5kbGUuaXNOYU4oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdDYW5ub3QgcHV0IGEgY3VydmUgdGhyb3VnaCBwb2ludHMgd2l0aCBwYXJhbWV0ZXIgPSAnICsgdCk7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlLCB0byk7XG5cdFx0fSxcblxuXHRcdGFyY1RvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyksXG5cdFx0XHRcdGZyb20gPSBjdXJyZW50Ll9wb2ludCxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRocm91Z2gsXG5cdFx0XHRcdHBlZWsgPSBCYXNlLnBlZWsoYXJndW1lbnRzKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKHBlZWssIHRydWUpLFxuXHRcdFx0XHRjZW50ZXIsIGV4dGVudCwgdmVjdG9yLCBtYXRyaXg7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHR0aHJvdWdoID0gbWlkZGxlLmFkZChtaWRkbGUuc3VidHJhY3QoZnJvbSkucm90YXRlKFxuXHRcdFx0XHRcdFx0Y2xvY2t3aXNlID8gLTkwIDogOTApKTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5yZW1haW4oYXJndW1lbnRzKSA8PSAyKSB7XG5cdFx0XHRcdHRocm91Z2ggPSB0bztcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0Y2xvY2t3aXNlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRwdCA9IGZyb20uc3VidHJhY3QobWlkZGxlKS5yb3RhdGUoLXJvdGF0aW9uKSxcblx0XHRcdFx0XHR4ID0gcHQueCxcblx0XHRcdFx0XHR5ID0gcHQueSxcblx0XHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdFx0cnggPSBhYnMocmFkaXVzLndpZHRoKSxcblx0XHRcdFx0XHRyeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeCxcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeSxcblx0XHRcdFx0XHR4U3EgPSAgeCAqIHgsXG5cdFx0XHRcdFx0eVNxID0gIHkgKiB5O1xuXHRcdFx0XHR2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KHhTcSAvIHJ4U3EgKyB5U3EgLyByeVNxKTtcblx0XHRcdFx0aWYgKGZhY3RvciA+IDEpIHtcblx0XHRcdFx0XHRyeCAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnkgKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4O1xuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvXG5cdFx0XHRcdFx0XHQocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuXHRcdFx0XHRpZiAoYWJzKGZhY3RvcikgPCBlcHNpbG9uKVxuXHRcdFx0XHRcdGZhY3RvciA9IDA7XG5cdFx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeClcblx0XHRcdFx0XHRcdC5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSlcblx0XHRcdFx0XHRcdFx0KiBNYXRoLnNxcnQoZmFjdG9yKSlcblx0XHRcdFx0XHRcdC5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikucm90YXRlKHJvdGF0aW9uKVxuXHRcdFx0XHRcdFx0LnNjYWxlKHJ4LCByeSk7XG5cdFx0XHRcdHZlY3RvciA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShmcm9tKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG5cdFx0XHRcdGlmICghY2xvY2t3aXNlICYmIGV4dGVudCA+IDApXG5cdFx0XHRcdFx0ZXh0ZW50IC09IDM2MDtcblx0XHRcdFx0ZWxzZSBpZiAoY2xvY2t3aXNlICYmIGV4dGVudCA8IDApXG5cdFx0XHRcdFx0ZXh0ZW50ICs9IDM2MDtcblx0XHRcdH1cblx0XHRcdGlmICh0aHJvdWdoKSB7XG5cdFx0XHRcdHZhciBsMSA9IG5ldyBMaW5lKGZyb20uYWRkKHRocm91Z2gpLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dGhyb3VnaC5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsMiA9IG5ldyBMaW5lKHRocm91Z2guYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRvLnN1YnRyYWN0KHRocm91Z2gpLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byksXG5cdFx0XHRcdFx0dGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG5cdFx0XHRcdGNlbnRlciA9IGwxLmludGVyc2VjdChsMiwgdHJ1ZSk7XG5cdFx0XHRcdGlmICghY2VudGVyKSB7XG5cdFx0XHRcdFx0aWYgKCF0aHJvdWdoU2lkZSlcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZSh0by5zdWJ0cmFjdChjZW50ZXIpKTtcblx0XHRcdFx0dmFyIGNlbnRlclNpZGUgPSBsaW5lLmdldFNpZGUoY2VudGVyKTtcblx0XHRcdFx0aWYgKGNlbnRlclNpZGUgPT09IDApIHtcblx0XHRcdFx0XHRleHRlbnQgPSB0aHJvdWdoU2lkZSAqIE1hdGguYWJzKGV4dGVudCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcblx0XHRcdFx0XHRleHRlbnQgKz0gZXh0ZW50IDwgMCA/IDM2MCA6IC0zNjA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBleHQgPSBNYXRoLmFicyhleHRlbnQpLFxuXHRcdFx0XHRjb3VudCA9IGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKGV4dCAvIDkwKSxcblx0XHRcdFx0aW5jID0gZXh0ZW50IC8gY291bnQsXG5cdFx0XHRcdGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuXHRcdFx0XHR6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgcHQgPSB0byxcblx0XHRcdFx0XHRvdXQgPSBudWxsO1xuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0b3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG5cdFx0XHRcdFx0XHRvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0X2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMpO1xuXHRcdH0sXG5cblx0XHRsaW5lQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0Y3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksXG5cdFx0XHRcdFx0Y3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHRpZiAoam9pbilcblx0XHRcdFx0dGhpcy5qb2luKCk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIFBhdGhbZ2V0dGVyXSh0aGlzLl9zZWdtZW50cywgdGhpcy5fY2xvc2VkLCB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRcdG1hdHJpeCk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0dmFyIHN1bSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzdW0gKz0gQ3VydmUuZ2V0RWRnZVN1bShDdXJ2ZS5nZXRWYWx1ZXMoXG5cdFx0XHRcdFx0c2VnbWVudHNbaV0sIHNlZ21lbnRzW2kgKyAxIDwgbCA/IGkgKyAxIDogMF0pKTtcblx0XHRyZXR1cm4gc3VtID4gMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgZmFsc2UpLFxuXHRcdFx0bWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBuZXcgQXJyYXkoMik7XG5cblx0XHRmdW5jdGlvbiBwcm9jZXNzU2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcblx0XHRcdFx0Q3VydmUuX2FkZEJvdW5kcyhcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2ldLFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaSArIDRdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpICsgMl0sXG5cdFx0XHRcdFx0Y29vcmRzW2ldLFxuXHRcdFx0XHRcdGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRcdH1cblx0XHRcdHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuXHRcdFx0cHJldkNvb3JkcyA9IGNvb3Jkcztcblx0XHRcdGNvb3JkcyA9IHRtcDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0Z2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0aWYgKCFzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdHJldHVybiBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KTtcblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKSxcblx0XHRcdHJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuXHRcdFx0cGFkZGluZyA9IFBhdGguX2dldFBlblBhZGRpbmcocmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0Ym91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgcGFkZGluZyksXG5cdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdHZhciBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShwYWRkaW5nKS5tdWx0aXBseSgyKSk7XG5cblx0XHRmdW5jdGlvbiBhZGQocG9pbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50KSA6IHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMudW5pdGUoam9pbkJvdW5kcy5zZXRDZW50ZXIobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChzZWdtZW50Ll9wb2ludCkgOiBzZWdtZW50Ll9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW4sXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdGlmIChqb2luID09PSAncm91bmQnIHx8ICFoYW5kbGVJbi5pc1plcm8oKSAmJiAhaGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdFx0JiYgaGFuZGxlSW4uaXNDb2xpbmVhcihoYW5kbGVPdXQpKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcblx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0UGVuUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBteCA9IG1hdHJpeC5zaGlmdGxlc3MoKSxcblx0XHRcdGhvciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQocmFkaXVzLCAwKSksXG5cdFx0XHR2ZXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KDAsIHJhZGl1cykpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSAtTWF0aC5hdGFuKGIgKiB0YW4gLyBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuKGIgLyAodGFuICogYSkpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyAtIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgY3VydmUyID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuXHRcdFx0Y3VydmUxID0gY3VydmUyLmdldFByZXZpb3VzKCksXG5cdFx0XHRwb2ludCA9IGN1cnZlMi5nZXRQb2ludEF0KDAsIHRydWUpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdCgxLCB0cnVlKSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXQoMCwgdHJ1ZSksXG5cdFx0XHRzdGVwID0gbm9ybWFsMS5nZXREaXJlY3RlZEFuZ2xlKG5vcm1hbDIpIDwgMCA/IC1yYWRpdXMgOiByYWRpdXM7XG5cdFx0bm9ybWFsMS5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0bm9ybWFsMi5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50KTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0fVxuXHRcdGlmIChqb2luID09PSAnbWl0ZXInKSB7XG5cdFx0XHR2YXIgY29ybmVyID0gbmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDEpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlXG5cdFx0XHRcdCkuaW50ZXJzZWN0KG5ldyBMaW5lKFxuXHRcdFx0XHRcdHBvaW50LmFkZChub3JtYWwyKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuXHRcdFx0XHQpLCB0cnVlKTtcblx0XHRcdGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0KSB7XG5cdFx0XHRcdGFkZFBvaW50KGNvcm5lcik7XG5cdFx0XHRcdGlmICghYXJlYSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghYXJlYSlcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcblx0fSxcblxuXHRfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbihzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5ub3JtYWxpemUocmFkaXVzKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdFx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0fVxuXHRcdGlmIChjYXAgPT09ICdzcXVhcmUnKVxuXHRcdFx0cG9pbnQgPSBwb2ludC5hZGQobm9ybWFsLnJvdGF0ZShsb2MuZ2V0UGFyYW1ldGVyKCkgPT09IDAgPyAtOTAgOiA5MCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0fSxcblxuXHRnZXRIYW5kbGVCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRqb2luUGFkZGluZykge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHR4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuXHRcdFx0XHR2YXIgcGFkZGluZyA9IGogPT09IDAgPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0Z2V0Um91Z2hCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG5cdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXHRcdGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguc3FydCgyKSk7XG5cdFx0fVxuXHRcdHJldHVybiBQYXRoLmdldEhhbmRsZUJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKHN0cm9rZVJhZGl1cywgbWF0cml4KSxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhqb2luUmFkaXVzLCBtYXRyaXgpKTtcblx0fVxufX0pO1xuXG5QYXRoLmluamVjdCh7IHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0ZWxsaXBzZVNlZ21lbnRzID0gW1xuXHRcdFx0bmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhIF0sIFswLCAta2FwcGFdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDAgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGEgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMCBdLCBbLWthcHBhLCAwXSlcblx0XHRdO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChbXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSAhKHNpZGVzICUgMyksXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0U3RhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMxJyksXG5cdFx0XHRcdHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0aXRlbXMgPSBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIFBhdGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gIV9wcmVzZXJ2ZSAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoaXRlbS5fY2xvY2t3aXNlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0uc2V0Q2xvY2t3aXNlKGl0ZW0uX2luZGV4ID09PSAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0ucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5zbW9vdGgoKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZSgpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRwYXRoLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gcGF0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlZHVjZS5iYXNlLmNhbGwodGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbihjb21wb3VuZHBhdGgwLCBjb21wb3VuZHBhdGgxLCBjb2VmKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmICggIWNvbXBvdW5kcGF0aDAuX2NoaWxkcmVuW2ldIHx8ICFjb21wb3VuZHBhdGgxLl9jaGlsZHJlbltpXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLmludGVycG9sYXRlKFxuXHRcdFx0XHRjb21wb3VuZHBhdGgwLl9jaGlsZHJlbltpXSxcblx0XHRcdFx0Y29tcG91bmRwYXRoMS5fY2hpbGRyZW5baV0sXG5cdFx0XHRcdGNvZWZcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gY2hpbGQgJiYgY2hpbGQuaXNDbG9ja3dpc2UoKTtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT09ICEhY2xvY2t3aXNlKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGN1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y3VydmVzLnB1c2guYXBwbHkoY3VydmVzLCBjaGlsZHJlbltpXS5nZXRDdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0YXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGNoaWxkcmVuW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGF0aHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpXG5cdFx0XHRcdFx0PyBfbWF0cml4LmNoYWluKG14KSA6IG14LCBfcHJlY2lzaW9uKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocy5qb2luKCcgJyk7XG5cdH1cbn0sIHtcblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJ1xuXHRcdFx0XHQ/IG9wdGlvbnNcblx0XHRcdFx0OiBuZXcgQmFzZShvcHRpb25zLCB7IGZpbGw6IGZhbHNlIH0pO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJhbS5jbGlwKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzZWxlY3RlZEl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRpZiAoIXNlbGVjdGVkSXRlbXNbY2hpbGQuX2lkXSlcblx0XHRcdFx0Y2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuXHRcdFx0XHRcdFx0OiBtYXRyaXguY2hhaW4obXgpKTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0dmFyIGZpZWxkcyA9IHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcblx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50IDogbmV3IFBhdGgoKTtcblx0XHRcdGlmIChwYXRoICE9PSBjdXJyZW50KVxuXHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG5cdFx0XHRcdGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHRnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgoam9pbik7XG5cdFx0fVxuXHR9O1xuXG5cdEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJywgJ2FyY1RvJyxcblx0XHRcdCdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsICdhcmNCeSddLFxuXHRcdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGZpZWxkc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHRwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0KTtcblxuXHRyZXR1cm4gZmllbGRzO1xufSk7XG5cblBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxIHx8IHcgPT09IDA7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKSB7XG5cdFx0dmFyIG9wZXJhdG9yID0gb3BlcmF0b3JzW29wZXJhdGlvbl07XG5cdFx0ZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSgpLnJlb3JpZW50KCkudHJhbnNmb3JtKG51bGwsIHRydWUsXG5cdFx0XHRcdFx0dHJ1ZSk7XG5cdFx0fVxuXG5cdFx0dmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxKSxcblx0XHRcdF9wYXRoMiA9IHBhdGgyICYmIHBhdGgxICE9PSBwYXRoMiAmJiBwcmVwYXJlUGF0aChwYXRoMik7XG5cdFx0aWYgKF9wYXRoMiAmJiAvXihzdWJ0cmFjdHxleGNsdWRlKSQvLnRlc3Qob3BlcmF0aW9uKVxuXHRcdFx0XHReIChfcGF0aDIuaXNDbG9ja3dpc2UoKSAhPT0gX3BhdGgxLmlzQ2xvY2t3aXNlKCkpKVxuXHRcdFx0X3BhdGgyLnJldmVyc2UoKTtcblx0XHRzcGxpdFBhdGgoX3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBudWxsLCB0cnVlKSk7XG5cblx0XHR2YXIgY2hhaW4gPSBbXSxcblx0XHRcdHNlZ21lbnRzID0gW10sXG5cdFx0XHRtb25vQ3VydmVzID0gW10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAwMTtcblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3QocGF0aHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIHBhdGguX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sbGVjdChfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0Y29sbGVjdChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKTtcblx0XHRzZWdtZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBfYSA9IGEuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0X2IgPSBiLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRyZXR1cm4gIV9hICYmICFfYiB8fCBfYSAmJiBfYiA/IDAgOiBfYSA/IC0xIDogMTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll93aW5kaW5nICE9IG51bGwpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Y2hhaW4ubGVuZ3RoID0gMDtcblx0XHRcdHZhciBzdGFydFNlZyA9IHNlZ21lbnQsXG5cdFx0XHRcdHRvdGFsTGVuZ3RoID0gMCxcblx0XHRcdFx0d2luZGluZ1N1bSA9IDA7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSBzZWdtZW50LmdldEN1cnZlKCkuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGNoYWluLnB1c2goeyBzZWdtZW50OiBzZWdtZW50LCBsZW5ndGg6IGxlbmd0aCB9KTtcblx0XHRcdFx0dG90YWxMZW5ndGggKz0gbGVuZ3RoO1xuXHRcdFx0XHRzZWdtZW50ID0gc2VnbWVudC5nZXROZXh0KCk7XG5cdFx0XHR9IHdoaWxlIChzZWdtZW50ICYmICFzZWdtZW50Ll9pbnRlcnNlY3Rpb24gJiYgc2VnbWVudCAhPT0gc3RhcnRTZWcpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogKGogKyAxKSAvIDQ7XG5cdFx0XHRcdGZvciAoayA9IDAsIG0gPSBjaGFpbi5sZW5ndGg7IGsgPCBtOyBrKyspIHtcblx0XHRcdFx0XHR2YXIgbm9kZSA9IGNoYWluW2tdLFxuXHRcdFx0XHRcdFx0Y3VydmVMZW5ndGggPSBub2RlLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAobGVuZ3RoIDw9IHRvbGVyYW5jZVxuXHRcdFx0XHRcdFx0XHRcdHx8IGN1cnZlTGVuZ3RoIC0gbGVuZ3RoIDw9IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gY3VydmVMZW5ndGggLyAyO1xuXHRcdFx0XHRcdFx0dmFyIGN1cnZlID0gbm9kZS5zZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRcdFx0XHRcdHB0ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdFx0XHRob3IgPSBjdXJ2ZS5pc0xpbmVhcigpICYmIE1hdGguYWJzKGN1cnZlXG5cdFx0XHRcdFx0XHRcdFx0XHQuZ2V0VGFuZ2VudEF0KDAuNSwgdHJ1ZSkueSkgPD0gdG9sZXJhbmNlLFxuXHRcdFx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0XHRcdFx0XHRpZiAocGF0aC5fcGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKVxuXHRcdFx0XHRcdFx0XHRwYXRoID0gcGF0aC5fcGFyZW50O1xuXHRcdFx0XHRcdFx0d2luZGluZ1N1bSArPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcgJiYgX3BhdGgyXG5cdFx0XHRcdFx0XHRcdCYmIChwYXRoID09PSBfcGF0aDEgJiYgX3BhdGgyLl9nZXRXaW5kaW5nKHB0LCBob3IpXG5cdFx0XHRcdFx0XHRcdHx8IHBhdGggPT09IF9wYXRoMiAmJiAhX3BhdGgxLl9nZXRXaW5kaW5nKHB0LCBob3IpKVxuXHRcdFx0XHRcdFx0XHQ/IDBcblx0XHRcdFx0XHRcdFx0OiBnZXRXaW5kaW5nKHB0LCBtb25vQ3VydmVzLCBob3IpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlbmd0aCAtPSBjdXJ2ZUxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIHdpbmRpbmcgPSBNYXRoLnJvdW5kKHdpbmRpbmdTdW0gLyAzKTtcblx0XHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdFx0Y2hhaW5bal0uc2VnbWVudC5fd2luZGluZyA9IHdpbmRpbmc7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29tcG91bmRQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyZXN1bHQuaW5zZXJ0QWJvdmUocGF0aDEpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbih0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvciksIHRydWUpO1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZWR1Y2UoKTtcblx0XHRyZXN1bHQuc2V0U3R5bGUocGF0aDEuX3N0eWxlKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0ZnVuY3Rpb24gc3BsaXRQYXRoKGludGVyc2VjdGlvbnMpIHtcblx0XHR2YXIgdE1pbiA9IDAuMDAwMDAxLFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0bGluZWFySGFuZGxlcztcblxuXHRcdGZ1bmN0aW9uIHJlc2V0TGluZWFyKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lYXJIYW5kbGVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0bGluZWFySGFuZGxlc1tpXS5zZXQoMCwgMCk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IGludGVyc2VjdGlvbnMubGVuZ3RoIC0gMSwgY3VydmUsIHByZXY7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbG9jID0gaW50ZXJzZWN0aW9uc1tpXSxcblx0XHRcdFx0dCA9IGxvYy5fcGFyYW1ldGVyO1xuXHRcdFx0aWYgKHByZXYgJiYgcHJldi5fY3VydmUgPT09IGxvYy5fY3VydmUgJiYgcHJldi5fcGFyYW1ldGVyID4gMCkge1xuXHRcdFx0XHR0IC89IHByZXYuX3BhcmFtZXRlcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cnZlID0gbG9jLl9jdXJ2ZTtcblx0XHRcdFx0aWYgKGxpbmVhckhhbmRsZXMpXG5cdFx0XHRcdFx0cmVzZXRMaW5lYXIoKTtcblx0XHRcdFx0bGluZWFySGFuZGxlcyA9IGN1cnZlLmlzTGluZWFyKCkgPyBbXG5cdFx0XHRcdFx0XHRjdXJ2ZS5fc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRcdGN1cnZlLl9zZWdtZW50Mi5faGFuZGxlSW5cblx0XHRcdFx0XHRdIDogbnVsbDtcblx0XHRcdH1cblx0XHRcdHZhciBuZXdDdXJ2ZSxcblx0XHRcdFx0c2VnbWVudDtcblx0XHRcdGlmIChuZXdDdXJ2ZSA9IGN1cnZlLmRpdmlkZSh0LCB0cnVlLCB0cnVlKSkge1xuXHRcdFx0XHRzZWdtZW50ID0gbmV3Q3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0XHRjdXJ2ZSA9IG5ld0N1cnZlLmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdGlmIChsaW5lYXJIYW5kbGVzKVxuXHRcdFx0XHRcdGxpbmVhckhhbmRsZXMucHVzaChzZWdtZW50Ll9oYW5kbGVPdXQsIHNlZ21lbnQuX2hhbmRsZUluKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQgPSB0IDwgdE1pblxuXHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0OiB0ID4gdE1heFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDJcblx0XHRcdFx0XHRcdDogY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0KSA8IGN1cnZlLmdldFBhcnRMZW5ndGgodCwgMSlcblx0XHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHRzZWdtZW50Ll9pbnRlcnNlY3Rpb24gPSBsb2MuZ2V0SW50ZXJzZWN0aW9uKCk7XG5cdFx0XHRsb2MuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdFx0cHJldiA9IGxvYztcblx0XHR9XG5cdFx0aWYgKGxpbmVhckhhbmRsZXMpXG5cdFx0XHRyZXNldExpbmVhcigpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0V2luZGluZyhwb2ludCwgY3VydmVzLCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMDEsXG5cdFx0XHR0TWluID0gdG9sZXJhbmNlLFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0cHggPSBwb2ludC54LFxuXHRcdFx0cHkgPSBwb2ludC55LFxuXHRcdFx0d2luZExlZnQgPSAwLFxuXHRcdFx0d2luZFJpZ2h0ID0gMCxcblx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRhYnMgPSBNYXRoLmFicztcblx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0dmFyIHlUb3AgPSAtSW5maW5pdHksXG5cdFx0XHRcdHlCb3R0b20gPSBJbmZpbml0eSxcblx0XHRcdFx0eUJlZm9yZSA9IHB5IC0gdG9sZXJhbmNlLFxuXHRcdFx0XHR5QWZ0ZXIgPSBweSArIHRvbGVyYW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAwLCBweCwgcm9vdHMsIDAsIDEpID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSByb290cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdFx0dmFyIHkgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS55O1xuXHRcdFx0XHRcdFx0aWYgKHkgPCB5QmVmb3JlICYmIHkgPiB5VG9wKSB7XG5cdFx0XHRcdFx0XHRcdHlUb3AgPSB5O1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh5ID4geUFmdGVyICYmIHkgPCB5Qm90dG9tKSB7XG5cdFx0XHRcdFx0XHRcdHlCb3R0b20gPSB5O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0eVRvcCA9ICh5VG9wICsgcHkpIC8gMjtcblx0XHRcdHlCb3R0b20gPSAoeUJvdHRvbSArIHB5KSAvIDI7XG5cdFx0XHRpZiAoeVRvcCA+IC1JbmZpbml0eSlcblx0XHRcdFx0d2luZExlZnQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludChweCwgeVRvcCksIGN1cnZlcyk7XG5cdFx0XHRpZiAoeUJvdHRvbSA8IEluZmluaXR5KVxuXHRcdFx0XHR3aW5kUmlnaHQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludChweCwgeUJvdHRvbSksIGN1cnZlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB4QmVmb3JlID0gcHggLSB0b2xlcmFuY2UsXG5cdFx0XHRcdHhBZnRlciA9IHB4ICsgdG9sZXJhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcblx0XHRcdFx0XHR2YWx1ZXMgPSBjdXJ2ZS52YWx1ZXMsXG5cdFx0XHRcdFx0d2luZGluZyA9IGN1cnZlLndpbmRpbmcsXG5cdFx0XHRcdFx0bmV4dCA9IGN1cnZlLm5leHQsXG5cdFx0XHRcdFx0cHJldlQsXG5cdFx0XHRcdFx0cHJldlg7XG5cdFx0XHRcdGlmICh3aW5kaW5nICYmICh3aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiBweSA+PSB2YWx1ZXNbMV0gJiYgcHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCBweSA+PSB2YWx1ZXNbN10gJiYgcHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCBweSwgcm9vdHMsIDAsIDEpID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSByb290c1swXSxcblx0XHRcdFx0XHRcdHggPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDApLngsXG5cdFx0XHRcdFx0XHRzbG9wZSA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMSkueTtcblx0XHRcdFx0XHRpZiAoISh0ID4gdE1heFxuXHRcdFx0XHRcdFx0XHQmJiAoaSA9PT0gbCAtIDEgfHwgY3VydmUubmV4dCAhPT0gY3VydmVzW2kgKyAxXSlcblx0XHRcdFx0XHRcdFx0JiYgYWJzKEN1cnZlLmV2YWx1YXRlKGN1cnZlLm5leHQudmFsdWVzLCAwLCAwKS54IC14KVxuXHRcdFx0XHRcdFx0XHRcdDw9IHRvbGVyYW5jZVxuXHRcdFx0XHRcdFx0fHwgaSA+IDAgJiYgY3VydmUucHJldmlvdXMgPT09IGN1cnZlc1tpIC0gMV1cblx0XHRcdFx0XHRcdFx0JiYgYWJzKHByZXZYIC0geCkgPCB0b2xlcmFuY2Vcblx0XHRcdFx0XHRcdFx0JiYgcHJldlQgPiB0TWF4ICYmIHQgPCB0TWluKSkge1xuXHRcdFx0XHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2xvcGUpICYmICFDdXJ2ZS5pc0xpbmVhcih2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdFx0fHwgdCA8IHRNaW4gJiYgc2xvcGUgKiBDdXJ2ZS5ldmFsdWF0ZShcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnZlLnByZXZpb3VzLnZhbHVlcywgMSwgMSkueSA8IDBcblx0XHRcdFx0XHRcdFx0XHR8fCB0ID4gdE1heCAmJiBzbG9wZSAqIEN1cnZlLmV2YWx1YXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VydmUubmV4dC52YWx1ZXMsIDAsIDEpLnkgPCAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0ZXN0Q29udGFpbnMgJiYgeCA+PSB4QmVmb3JlICYmIHggPD0geEFmdGVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Kyt3aW5kTGVmdDtcblx0XHRcdFx0XHRcdFx0XHQrK3dpbmRSaWdodDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4IDw9IHhCZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0d2luZExlZnQgKz0gd2luZGluZztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0d2luZFJpZ2h0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByZXZUID0gdDtcblx0XHRcdFx0XHRwcmV2WCA9IHg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFicyh3aW5kTGVmdCksIGFicyh3aW5kUmlnaHQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yLCBzZWxmT3ApIHtcblx0XHR2YXIgcGF0aHMgPSBbXSxcblx0XHRcdHRNaW4gPSAwLjAwMDAwMSxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRmb3IgKHZhciBpID0gMCwgc2VnLCBzdGFydFNlZywgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnID0gc3RhcnRTZWcgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWcuX3Zpc2l0ZWQgfHwgIW9wZXJhdG9yKHNlZy5fd2luZGluZykpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCksXG5cdFx0XHRcdGludGVyID0gc2VnLl9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdHN0YXJ0SW50ZXJTZWcgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudCxcblx0XHRcdFx0YWRkZWQgPSBmYWxzZSxcblx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGhhbmRsZUluID0gZGlyID4gMCA/IHNlZy5faGFuZGxlSW4gOiBzZWcuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuXHRcdFx0XHRcdGludGVyU2VnO1xuXHRcdFx0XHRpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcblx0XHRcdFx0XHRcdCYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdFx0JiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG5cdFx0XHRcdFx0XHQmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcblx0XHRcdFx0XHRpZiAoc2VsZk9wKSB7XG5cdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGMxID0gc2VnLmdldEN1cnZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlyID4gMClcblx0XHRcdFx0XHRcdFx0YzEgPSBjMS5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdFx0dmFyIHQxID0gYzEuZ2V0VGFuZ2VudEF0KGRpciA8IDEgPyB0TWluIDogdE1heCwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdGM0ID0gaW50ZXJTZWcuZ2V0Q3VydmUoKSxcblx0XHRcdFx0XHRcdFx0YzMgPSBjNC5nZXRQcmV2aW91cygpLFxuXHRcdFx0XHRcdFx0XHR0MyA9IGMzLmdldFRhbmdlbnRBdCh0TWF4LCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0dDQgPSBjNC5nZXRUYW5nZW50QXQodE1pbiwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdHczID0gdDEuY3Jvc3ModDMpLFxuXHRcdFx0XHRcdFx0XHR3NCA9IHQxLmNyb3NzKHQ0KTtcblx0XHRcdFx0XHRcdGlmICh3MyAqIHc0ICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJ2ZSA9IHczIDwgdzQgPyBjMyA6IGM0LFxuXHRcdFx0XHRcdFx0XHRcdG5leHRDdXJ2ZSA9IG9wZXJhdG9yKGN1cnZlLl9zZWdtZW50MS5fd2luZGluZylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VydmVcblx0XHRcdFx0XHRcdFx0XHRcdDogdzMgPCB3NCA/IGM0IDogYzMsXG5cdFx0XHRcdFx0XHRcdFx0bmV4dFNlZyA9IG5leHRDdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHRcdFx0XHRcdGRpciA9IG5leHRDdXJ2ZSA9PT0gYzMgPyAtMSA6IDE7XG5cdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkICYmIHNlZy5fcGF0aCAhPT0gbmV4dFNlZy5fcGF0aFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR8fCAhb3BlcmF0b3IobmV4dFNlZy5fd2luZGluZykpIHtcblx0XHRcdFx0XHRcdFx0XHRkaXIgPSAxO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNlZy5fdmlzaXRlZCA9IGludGVyU2VnLl92aXNpdGVkO1xuXHRcdFx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChuZXh0U2VnLl92aXNpdGVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aGFuZGxlT3V0ID0gZGlyID4gMCA/IHNlZy5faGFuZGxlT3V0IDogc2VnLl9oYW5kbGVJbjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBhZGRlZCAmJiBoYW5kbGVJbiwgaGFuZGxlT3V0KSk7XG5cdFx0XHRcdGFkZGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnID0gZGlyID4gMCA/IHNlZy5nZXROZXh0KCkgOiBzZWcuIGdldFByZXZpb3VzKCk7XG5cdFx0XHR9IHdoaWxlIChzZWcgJiYgIXNlZy5fdmlzaXRlZFxuXHRcdFx0XHRcdCYmIHNlZyAhPT0gc3RhcnRTZWcgJiYgc2VnICE9PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0JiYgKHNlZy5faW50ZXJzZWN0aW9uIHx8IG9wZXJhdG9yKHNlZy5fd2luZGluZykpKTtcblx0XHRcdGlmIChzZWcgJiYgKHNlZyA9PT0gc3RhcnRTZWcgfHwgc2VnID09PSBzdGFydEludGVyU2VnKSkge1xuXHRcdFx0XHRwYXRoLmZpcnN0U2VnbWVudC5zZXRIYW5kbGVJbigoc2VnID09PSBzdGFydEludGVyU2VnXG5cdFx0XHRcdFx0XHQ/IHN0YXJ0SW50ZXJTZWcgOiBzZWcpLl9oYW5kbGVJbik7XG5cdFx0XHRcdHBhdGguc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGF0aC5sYXN0U2VnbWVudC5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9zZWdtZW50cy5sZW5ndGggPlxuXHRcdFx0XHRcdChwYXRoLl9jbG9zZWQgPyBwYXRoLmlzUG9seWdvbigpID8gMiA6IDAgOiAxKSlcblx0XHRcdFx0cGF0aHMucHVzaChwYXRoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZ2V0V2luZGluZzogZnVuY3Rpb24ocG9pbnQsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdFx0cmV0dXJuIGdldFdpbmRpbmcocG9pbnQsIHRoaXMuX2dldE1vbm9DdXJ2ZXMoKSxcblx0XHRcdFx0XHRob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpO1xuXHRcdH0sXG5cblx0XHR1bml0ZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICd1bml0ZScpO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnaW50ZXJzZWN0Jyk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ3N1YnRyYWN0Jyk7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnZXhjbHVkZScpO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBuZXcgR3JvdXAoW3RoaXMuc3VidHJhY3QocGF0aCksIHRoaXMuaW50ZXJzZWN0KHBhdGgpXSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cblBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyxcblx0XHRcdHByZXZDdXJ2ZTtcblxuXHRcdGZ1bmN0aW9uIGluc2VydEN1cnZlKHYpIHtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdls3XSxcblx0XHRcdFx0Y3VydmUgPSB7XG5cdFx0XHRcdFx0dmFsdWVzOiB2LFxuXHRcdFx0XHRcdHdpbmRpbmc6IHkwID09PSB5MVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IHkwID4geTFcblx0XHRcdFx0XHRcdFx0PyAtMVxuXHRcdFx0XHRcdFx0XHQ6IDEsXG5cdFx0XHRcdFx0cHJldmlvdXM6IHByZXZDdXJ2ZSxcblx0XHRcdFx0XHRuZXh0OiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocHJldkN1cnZlKVxuXHRcdFx0XHRwcmV2Q3VydmUubmV4dCA9IGN1cnZlO1xuXHRcdFx0bW9ub0N1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcblx0XHRcdGlmIChDdXJ2ZS5nZXRMZW5ndGgodikgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdlszXSxcblx0XHRcdFx0eTIgPSB2WzVdLFxuXHRcdFx0XHR5MyA9IHZbN107XG5cdFx0XHRpZiAoQ3VydmUuaXNMaW5lYXIodikpIHtcblx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAoeTEgLSB5MikgLSB5MCArIHkzLFxuXHRcdFx0XHRcdGIgPSAyICogKHkwICsgeTIpIC0gNCAqIHkxLFxuXHRcdFx0XHRcdGMgPSB5MSAtIHkwLFxuXHRcdFx0XHRcdHRvbGVyYW5jZSA9IDAuMDAwMDAxLFxuXHRcdFx0XHRcdHJvb3RzID0gW107XG5cdFx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgdG9sZXJhbmNlLFxuXHRcdFx0XHRcdFx0MSAtIHRvbGVyYW5jZSk7XG5cdFx0XHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdGluc2VydEN1cnZlKHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvb3RzLnNvcnQoKTtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMF0pO1xuXHRcdFx0XHRcdGlmIChjb3VudCA+IDEpIHtcblx0XHRcdFx0XHRcdHQgPSAocm9vdHNbMV0gLSB0KSAvICgxIC0gdCk7XG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZShwYXJ0c1sxXSwgdCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghbW9ub0N1cnZlcykge1xuXHRcdFx0bW9ub0N1cnZlcyA9IHRoaXMuX21vbm9DdXJ2ZXMgPSBbXTtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRoYW5kbGVDdXJ2ZShjdXJ2ZXNbaV0uZ2V0VmFsdWVzKCkpO1xuXHRcdFx0aWYgKCF0aGlzLl9jbG9zZWQgJiYgc2VnbWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR2YXIgcDEgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDIgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0cDF4ID0gcDEuX3gsIHAxeSA9IHAxLl95LFxuXHRcdFx0XHRcdHAyeCA9IHAyLl94LCBwMnkgPSBwMi5feTtcblx0XHRcdFx0aGFuZGxlQ3VydmUoW3AxeCwgcDF5LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAyeCwgcDJ5XSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9ub0N1cnZlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHZhciBmaXJzdCA9IG1vbm9DdXJ2ZXNbMF0sXG5cdFx0XHRcdFx0bGFzdCA9IG1vbm9DdXJ2ZXNbbW9ub0N1cnZlcy5sZW5ndGggLSAxXTtcblx0XHRcdFx0Zmlyc3QucHJldmlvdXMgPSBsYXN0O1xuXHRcdFx0XHRsYXN0Lm5leHQgPSBmaXJzdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0SW50ZXJpb3JQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRwb2ludCA9IGJvdW5kcy5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0aWYgKCF0aGlzLmNvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuX2dldE1vbm9DdXJ2ZXMoKSxcblx0XHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdFx0eSA9IHBvaW50LnksXG5cdFx0XHRcdHhJbnRlcmNlcHRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG5cdFx0XHRcdGlmICgoY3VydmVzW2ldLndpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHkgPj0gdmFsdWVzWzFdICYmIHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCB5ID49IHZhbHVlc1s3XSAmJiB5IDw9IHZhbHVlc1sxXSlcblx0XHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCB5LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRcdFx0eEludGVyY2VwdHMucHVzaChDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHJvb3RzW2pdLCAwKS54KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoeEludGVyY2VwdHMubGVuZ3RoID4gMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHBvaW50LnggPSAoeEludGVyY2VwdHNbMF0gKyB4SW50ZXJjZXB0c1sxXSkgLyAyO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc2V0Q2xvY2t3aXNlKHRydWUpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxuQ29tcG91bmRQYXRoLmluamVjdCh7XG5cdF9nZXRNb25vQ3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBjaGlsZHJlbltpXS5fZ2V0TW9ub0N1cnZlcygpKTtcblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGIuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpIC0gYS5nZXRCb3VuZHMoKS5nZXRBcmVhKCk7XG5cdFx0fSk7XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdFx0dmFyIGNsb2Nrd2lzZSA9IGNoaWxkcmVuWzBdLmlzQ2xvY2t3aXNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBjaGlsZHJlbltpXS5nZXRJbnRlcmlvclBvaW50KCksXG5cdFx0XHRcdFx0Y291bnRlcnMgPSAwO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0aWYgKGNoaWxkcmVuW2pdLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRcdGNvdW50ZXJzKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0Q2xvY2t3aXNlKGNvdW50ZXJzICUgMiA9PT0gMCAmJiBjbG9ja3dpc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbnZhciBQYXRoSXRlcmF0b3IgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVyYXRvcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgbWF4UmVjdXJzaW9uLCB0b2xlcmFuY2UsIG1hdHJpeCkge1xuXHRcdHZhciBjdXJ2ZXMgPSBbXSxcblx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRsZW5ndGggPSAwLFxuXHRcdFx0bWluRGlmZmVyZW5jZSA9IDEgLyAobWF4UmVjdXJzaW9uIHx8IDMyKSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuXHRcdFx0c2VnbWVudDI7XG5cblx0XHRmdW5jdGlvbiBhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFZhbHVlcyhzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCk7XG5cdFx0XHRjdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRjb21wdXRlUGFydHMoY3VydmUsIHNlZ21lbnQxLl9pbmRleCwgMCwgMSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcHV0ZVBhcnRzKGN1cnZlLCBpbmRleCwgbWluVCwgbWF4VCkge1xuXHRcdFx0aWYgKChtYXhUIC0gbWluVCkgPiBtaW5EaWZmZXJlbmNlXG5cdFx0XHRcdFx0JiYgIUN1cnZlLmlzRmxhdEVub3VnaChjdXJ2ZSwgdG9sZXJhbmNlIHx8IDAuMjUpKSB7XG5cdFx0XHRcdHZhciBzcGxpdCA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSksXG5cdFx0XHRcdFx0aGFsZlQgPSAobWluVCArIG1heFQpIC8gMjtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKHNwbGl0WzBdLCBpbmRleCwgbWluVCwgaGFsZlQpO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMV0sIGluZGV4LCBoYWxmVCwgbWF4VCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG5cdFx0XHRcdFx0eSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGRpc3QgPiAwLjAwMDAwMSkge1xuXHRcdFx0XHRcdGxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0b2Zmc2V0OiBsZW5ndGgsXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF4VCxcblx0XHRcdFx0XHRcdGluZGV4OiBpbmRleFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50Mjtcblx0XHR9XG5cdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQyLCBzZWdtZW50c1swXSk7XG5cblx0XHR0aGlzLmN1cnZlcyA9IGN1cnZlcztcblx0XHR0aGlzLnBhcnRzID0gcGFydHM7XG5cdFx0dGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHZhciBpLCBqID0gdGhpcy5pbmRleDtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpID0gajtcblx0XHRcdGlmIChqID09IDAgfHwgdGhpcy5wYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGZvciAodmFyIGwgPSB0aGlzLnBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuXHRcdFx0aWYgKHBhcnQub2Zmc2V0ID49IG9mZnNldCkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gaTtcblx0XHRcdFx0dmFyIHByZXYgPSB0aGlzLnBhcnRzW2kgLSAxXTtcblx0XHRcdFx0dmFyIHByZXZWYWwgPSBwcmV2ICYmIHByZXYuaW5kZXggPT0gcGFydC5pbmRleCA/IHByZXYudmFsdWUgOiAwLFxuXHRcdFx0XHRcdHByZXZMZW4gPSBwcmV2ID8gcHJldi5vZmZzZXQgOiAwO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZhbHVlOiBwcmV2VmFsICsgKHBhcnQudmFsdWUgLSBwcmV2VmFsKVxuXHRcdFx0XHRcdFx0KiAob2Zmc2V0IC0gcHJldkxlbikgLyAocGFydC5vZmZzZXQgLSBwcmV2TGVuKSxcblx0XHRcdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IDEsXG5cdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdH07XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKG9mZnNldCwgdHlwZSkge1xuXHRcdHZhciBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gQ3VydmUuZXZhbHVhdGUodGhpcy5jdXJ2ZXNbcGFyYW0uaW5kZXhdLCBwYXJhbS52YWx1ZSwgdHlwZSk7XG5cdH0sXG5cblx0ZHJhd1BhcnQ6IGZ1bmN0aW9uKGN0eCwgZnJvbSwgdG8pIHtcblx0XHRmcm9tID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChmcm9tKTtcblx0XHR0byA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQodG8pO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tLmluZGV4OyBpIDw9IHRvLmluZGV4OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aSA9PSBmcm9tLmluZGV4ID8gZnJvbS52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0aSA9PSB0by5pbmRleCA/IHRvLnZhbHVlIDogMSk7XG5cdFx0XHRpZiAoaSA9PSBmcm9tLmluZGV4KVxuXHRcdFx0XHRjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldEN1cnZhdHVyZSddLFxuXHRmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ldmFsdWF0ZShvZmZzZXQsIGluZGV4KTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHByZXY7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50LmNsb25lKCk7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGF0aC5fY2xvc2VkKSB7XG5cdFx0XHR0aGlzLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXG5cdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0c2VnbWVudHMucG9wKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgVjEgPSB0aGlzLnBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0XSksXG5cdFx0XHRWMiA9IHRoaXMucG9pbnRzW3NwbGl0XS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdCArIDFdKSxcblx0XHRcdHRhbkNlbnRlciA9IFYxLmFkZChWMikuZGl2aWRlKDIpLm5vcm1hbGl6ZSgpO1xuXHRcdHRoaXMuZml0Q3ViaWMoZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuXHRcdHRoaXMuZml0Q3ViaWMoc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG5cdH0sXG5cblx0YWRkQ3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLnNlZ21lbnRzW3RoaXMuc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdFx0cHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcblx0XHR0aGlzLnNlZ21lbnRzLnB1c2goXG5cdFx0XHRcdG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcblx0fSxcblxuXHRnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuXHRcdFx0WCA9IFswLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHUgPSB1UHJpbWVbaV0sXG5cdFx0XHRcdHQgPSAxIC0gdSxcblx0XHRcdFx0YiA9IDMgKiB1ICogdCxcblx0XHRcdFx0YjAgPSB0ICogdCAqIHQsXG5cdFx0XHRcdGIxID0gYiAqIHQsXG5cdFx0XHRcdGIyID0gYiAqIHUsXG5cdFx0XHRcdGIzID0gdSAqIHUgKiB1LFxuXHRcdFx0XHRhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcblx0XHRcdFx0YTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG5cdFx0XHRcdHRtcCA9IHRoaXMucG9pbnRzW2ZpcnN0ICsgaV1cblx0XHRcdFx0XHQuc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuXHRcdFx0Q1swXVswXSArPSBhMS5kb3QoYTEpO1xuXHRcdFx0Q1swXVsxXSArPSBhMS5kb3QoYTIpO1xuXHRcdFx0Q1sxXVswXSA9IENbMF1bMV07XG5cdFx0XHRDWzFdWzFdICs9IGEyLmRvdChhMik7XG5cdFx0XHRYWzBdICs9IGExLmRvdCh0bXApO1xuXHRcdFx0WFsxXSArPSBhMi5kb3QodG1wKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG5cdFx0XHRhbHBoYTEsIGFscGhhMjtcblx0XHRpZiAoTWF0aC5hYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHR2YXIgZGV0QzBYXHQ9IENbMF1bMF0gKiBYWzFdXHQtIENbMV1bMF0gKiBYWzBdLFxuXHRcdFx0XHRkZXRYQzFcdD0gWFswXVx0ICAqIENbMV1bMV0gLSBYWzFdXHQgICogQ1swXVsxXTtcblx0XHRcdGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG5cdFx0XHRhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcblx0XHRcdFx0YzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcblx0XHRcdGlmIChNYXRoLmFicyhjMCkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMF0gLyBjMDtcblx0XHRcdH0gZWxzZSBpZiAoTWF0aC5hYnMoYzEpID4gZXBzaWxvbikge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBYWzFdIC8gYzE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKTtcblx0XHRlcHNpbG9uICo9IHNlZ0xlbmd0aDtcblx0XHRpZiAoYWxwaGExIDwgZXBzaWxvbiB8fCBhbHBoYTIgPCBlcHNpbG9uKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH1cblxuXHRcdHJldHVybiBbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGFscGhhMikpLCBwdDJdO1xuXHR9LFxuXG5cdHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcblx0XHR9XG5cdH0sXG5cblx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuXHRcdHZhciBjdXJ2ZTEgPSBbXSxcblx0XHRcdGN1cnZlMiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuXHRcdFx0Y3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuXHRcdFx0cHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuXHRcdFx0cHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuXHRcdFx0ZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcblx0XHRcdGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcblx0XHRpZiAoTWF0aC5hYnMoZGYpIDwgMC4wMDAwMDEpXG5cdFx0XHRyZXR1cm4gdTtcblx0XHRyZXR1cm4gdSAtIGRpZmYuZG90KHB0MSkgLyBkZjtcblx0fSxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24oZGVncmVlLCBjdXJ2ZSwgdCkge1xuXHRcdHZhciB0bXAgPSBjdXJ2ZS5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDw9IGRlZ3JlZTsgaSsrKSB7XG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8PSBkZWdyZWUgLSBpOyBqKyspIHtcblx0XHRcdFx0dG1wW2pdID0gdG1wW2pdLm11bHRpcGx5KDEgLSB0KS5hZGQodG1wW2ogKyAxXS5tdWx0aXBseSh0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0bXBbMF07XG5cdH0sXG5cblx0Y2hvcmRMZW5ndGhQYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0KSB7XG5cdFx0dmFyIHUgPSBbMF07XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHVbaSAtIGZpcnN0IC0gMV1cblx0XHRcdFx0XHQrIHRoaXMucG9pbnRzW2ldLmdldERpc3RhbmNlKHRoaXMucG9pbnRzW2kgLSAxXSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxLCBtID0gbGFzdCAtIGZpcnN0OyBpIDw9IG07IGkrKykge1xuXHRcdFx0dVtpXSAvPSB1W21dO1xuXHRcdH1cblx0XHRyZXR1cm4gdTtcblx0fSxcblxuXHRmaW5kTWF4RXJyb3I6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdSkge1xuXHRcdHZhciBpbmRleCA9IE1hdGguZmxvb3IoKGxhc3QgLSBmaXJzdCArIDEpIC8gMiksXG5cdFx0XHRtYXhEaXN0ID0gMDtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG5cdFx0XHR2YXIgUCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHVbaSAtIGZpcnN0XSk7XG5cdFx0XHR2YXIgdiA9IFAuc3VidHJhY3QodGhpcy5wb2ludHNbaV0pO1xuXHRcdFx0dmFyIGRpc3QgPSB2LnggKiB2LnggKyB2LnkgKiB2Lnk7XG5cdFx0XHRpZiAoZGlzdCA+PSBtYXhEaXN0KSB7XG5cdFx0XHRcdG1heERpc3QgPSBkaXN0O1xuXHRcdFx0XHRpbmRleCA9IGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRlcnJvcjogbWF4RGlzdCxcblx0XHRcdGluZGV4OiBpbmRleFxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgVGV4dEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1RleHRJdGVtJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y29udGVudDogbnVsbFxuXHR9LFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUZXh0SXRlbShhcmcpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJyc7XG5cdFx0dGhpcy5fbGluZXMgPSBbXTtcblx0XHR2YXIgaGFzUHJvcHMgPSBhcmcgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0JiYgYXJnLnggPT09IHVuZGVmaW5lZCAmJiBhcmcueSA9PT0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2luaXRpYWxpemUoaGFzUHJvcHMgJiYgYXJnLCAhaGFzUHJvcHMgJiYgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQgPT09IGl0ZW0uX2NvbnRlbnQ7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbiBfY2xvbmUoY29weSwgaW5zZXJ0KSB7XG5cdFx0Y29weS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXHRcdHJldHVybiBfY2xvbmUuYmFzZS5jYWxsKHRoaXMsIGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0c2V0Q29udGVudDogZnVuY3Rpb24oY29udGVudCkge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJyArIGNvbnRlbnQ7XG5cdFx0dGhpcy5fbGluZXMgPSB0aGlzLl9jb250ZW50LnNwbGl0KC9cXHJcXG58XFxufFxcci9tZyk7XG5cdFx0dGhpcy5fY2hhbmdlZCgyNjUpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRnZXRDaGFyYWN0ZXJTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldENoYXJhY3RlclN0eWxlOiAnI3NldFN0eWxlJyxcblxuXHRnZXRQYXJhZ3JhcGhTdHlsZTogJyNnZXRTdHlsZScsXG5cdHNldFBhcmFncmFwaFN0eWxlOiAnI3NldFN0eWxlJ1xufSk7XG5cbnZhciBQb2ludFRleHQgPSBUZXh0SXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludFRleHQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50VGV4dCgpIHtcblx0XHRUZXh0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IFBvaW50VGV4dChJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdHJldHVybiBuZXcgTGlua2VkUG9pbnQocG9pbnQueCwgcG9pbnQueSwgdGhpcywgJ3NldFBvaW50Jyk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnRyYW5zbGF0ZShwb2ludC5zdWJ0cmFjdCh0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKSkpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpXG5cdFx0XHRyZXR1cm47XG5cdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gY3R4LnNoYWRvd0NvbG9yO1xuXHRcdGN0eC5mb250ID0gc3R5bGUuZ2V0Rm9udFN0eWxlKCk7XG5cdFx0Y3R4LnRleHRBbGlnbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3I7XG5cdFx0XHR2YXIgbGluZSA9IGxpbmVzW2ldO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbFRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZVRleHQobGluZSwgMCwgMCk7XG5cdFx0XHRjdHgudHJhbnNsYXRlKDAsIGxlYWRpbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdG51bUxpbmVzID0gbGluZXMubGVuZ3RoLFxuXHRcdFx0anVzdGlmaWNhdGlvbiA9IHN0eWxlLmdldEp1c3RpZmljYXRpb24oKSxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHR3aWR0aCA9IHRoaXMuZ2V0VmlldygpLmdldFRleHRXaWR0aChzdHlsZS5nZXRGb250U3R5bGUoKSwgbGluZXMpLFxuXHRcdFx0eCA9IDA7XG5cdFx0aWYgKGp1c3RpZmljYXRpb24gIT09ICdsZWZ0Jylcblx0XHRcdHggLT0gd2lkdGggLyAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicgPyAyOiAxKTtcblx0XHR2YXIgYm91bmRzID0gbmV3IFJlY3RhbmdsZSh4LFxuXHRcdFx0XHRcdG51bUxpbmVzID8gLSAwLjc1ICogbGVhZGluZyA6IDAsXG5cdFx0XHRcdFx0d2lkdGgsIG51bUxpbmVzICogbGVhZGluZyk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKGJvdW5kcywgYm91bmRzKSA6IGJvdW5kcztcblx0fVxufSk7XG5cbnZhciBDb2xvciA9IEJhc2UuZXh0ZW5kKG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0Y29sb3JDYWNoZSA9IHt9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb21wb25lbnRzID0gWzAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICtjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gaSA8IDMgPyB2YWx1ZSAvIDI1NSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddO1xuXHRcdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG5cdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMl0gLyAyNTVcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjYWNoZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sXG5cdFx0WzIsIDAsIDFdLFxuXHRcdFsxLCAwLCAzXSxcblx0XHRbMSwgMiwgMF0sXG5cdFx0WzMsIDEsIDBdLFxuXHRcdFswLCAxLCAyXVxuXHRdO1xuXG5cdHZhciBjb252ZXJ0ZXJzID0ge1xuXHRcdCdyZ2ItaHNiJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGggPSBkZWx0YSA9PT0gMCA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwO1xuXHRcdFx0cmV0dXJuIFtoLCBtYXggPT09IDAgPyAwIDogZGVsdGEgLyBtYXgsIG1heF07XG5cdFx0fSxcblxuXHRcdCdoc2ItcmdiJzogZnVuY3Rpb24oaCwgcywgYikge1xuXHRcdFx0aCA9ICgoKGggLyA2MCkgJSA2KSArIDYpICUgNjtcblx0XHRcdHZhciBpID0gTWF0aC5mbG9vcihoKSxcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogKDEgLSBmKSlcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0Olx0KCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDpcdFx0XHQgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCxcblx0XHRcdFx0bCA9IChtYXggKyBtaW4pIC8gMixcblx0XHRcdFx0cyA9IGFjaHJvbWF0aWMgPyAwIDogbCA8IDAuNVxuXHRcdFx0XHRcdFx0PyBkZWx0YSAvIChtYXggKyBtaW4pXG5cdFx0XHRcdFx0XHQ6IGRlbHRhIC8gKDIgLSBtYXggLSBtaW4pO1xuXHRcdFx0cmV0dXJuIFtoLCBzLCBsXTtcblx0XHR9LFxuXG5cdFx0J2hzbC1yZ2InOiBmdW5jdGlvbihoLCBzLCBsKSB7XG5cdFx0XHRoID0gKCgoaCAvIDM2MCkgJSAxKSArIDEpICUgMTtcblx0XHRcdGlmIChzID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gW2wsIGwsIGxdO1xuXHRcdFx0dmFyIHQzcyA9IFsgaCArIDEgLyAzLCBoLCBoIC0gMSAvIDMgXSxcblx0XHRcdFx0dDIgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzLFxuXHRcdFx0XHR0MSA9IDIgKiBsIC0gdDIsXG5cdFx0XHRcdGMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB0MyA9IHQzc1tpXTtcblx0XHRcdFx0aWYgKHQzIDwgMCkgdDMgKz0gMTtcblx0XHRcdFx0aWYgKHQzID4gMSkgdDMgLT0gMTtcblx0XHRcdFx0Y1tpXSA9IDYgKiB0MyA8IDFcblx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogNiAqIHQzXG5cdFx0XHRcdFx0OiAyICogdDMgPCAxXG5cdFx0XHRcdFx0XHQ/IHQyXG5cdFx0XHRcdFx0XHQ6IDMgKiB0MyA8IDJcblx0XHRcdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqICgoMiAvIDMpIC0gdDMpICogNlxuXHRcdFx0XHRcdFx0XHQ6IHQxO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JheSc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHJldHVybiBbciAqIDAuMjk4OSArIGcgKiAwLjU4NyArIGIgKiAwLjExNF07XG5cdFx0fSxcblxuXHRcdCdncmF5LXJnYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbZywgZywgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzYic6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmF5LWhzbCc6IGZ1bmN0aW9uKGcpIHtcblx0XHRcdHJldHVybiBbMCwgMCwgZ107XG5cdFx0fSxcblxuXHRcdCdncmFkaWVudC1yZ2InOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmFkaWVudCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2godHlwZXMsIGZ1bmN0aW9uKHByb3BlcnRpZXMsIHR5cGUpIHtcblx0XHRjb21wb25lbnRQYXJzZXJzW3R5cGVdID0gW107XG5cdFx0QmFzZS5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKG5hbWUsIGluZGV4KSB7XG5cdFx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdFx0aGFzT3ZlcmxhcCA9IC9eKGh1ZXxzYXR1cmF0aW9uKSQvLnRlc3QobmFtZSksXG5cdFx0XHRcdHBhcnNlciA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV1baW5kZXhdID0gbmFtZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdD8gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50ID0gdGhpcy5fY29tcG9uZW50c1swXTtcblx0XHRcdFx0XHRcdHZhbHVlID0gR3JhZGllbnQucmVhZChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0OiBhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQpXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5fcmVtb3ZlT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZS5fYWRkT3duZXIodGhpcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0PyBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFkTnVsbDogbmFtZSA9PT0gJ2hpZ2hsaWdodCcsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9uZTogdHJ1ZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgfHwgaXNOYU4odmFsdWUpID8gMCA6IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0fHwgaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50c1tpbmRleF1cblx0XHRcdFx0XHRcdDogdGhpcy5fY29udmVydCh0eXBlKVtpbmRleF07XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gdHlwZVxuXHRcdFx0XHRcdFx0JiYgIShoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKSkpIHtcblx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFsdWUgPSBwYXJzZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSwgdGhpcyk7XG5cdH0sIHtcblx0XHRfY2xhc3M6ICdDb2xvcicsXG5cdFx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbG9yKGFyZykge1xuXHRcdFx0dmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRyZWFkID0gMCxcblx0XHRcdFx0dHlwZSxcblx0XHRcdFx0Y29tcG9uZW50cyxcblx0XHRcdFx0YWxwaGEsXG5cdFx0XHRcdHZhbHVlcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0YXJncyA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1swXTtcblx0XHRcdH1cblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZztcblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyAmJiBhcmcgaW4gdHlwZXMpIHtcblx0XHRcdFx0dHlwZSA9IGFyZztcblx0XHRcdFx0YXJnID0gYXJnc1sxXTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmc7XG5cdFx0XHRcdFx0YWxwaGEgPSBhcmdzWzJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0XHRcdGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3MsIDEpO1xuXHRcdFx0XHRcdGFyZ1R5cGUgPSB0eXBlb2YgYXJnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dmFsdWVzID0gYXJnVHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gYXJnc1xuXHRcdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnb2JqZWN0JyAmJiBhcmcubGVuZ3RoICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdFx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRcdFx0aWYgKCF0eXBlKVxuXHRcdFx0XHRcdFx0dHlwZSA9IHZhbHVlcy5sZW5ndGggPj0gM1xuXHRcdFx0XHRcdFx0XHRcdD8gJ3JnYidcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5Jztcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gdHlwZXNbdHlwZV0ubGVuZ3RoO1xuXHRcdFx0XHRcdGFscGhhID0gdmFsdWVzW2xlbmd0aF07XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCArPSB2YWx1ZXMgPT09IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHQ/IGxlbmd0aCArIChhbHBoYSAhPSBudWxsID8gMSA6IDApXG5cdFx0XHRcdFx0XHRcdDogMTtcblx0XHRcdFx0XHRpZiAodmFsdWVzLmxlbmd0aCA+IGxlbmd0aClcblx0XHRcdFx0XHRcdHZhbHVlcyA9IHNsaWNlLmNhbGwodmFsdWVzLCAwLCBsZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0dHlwZSA9ICdyZ2InO1xuXHRcdFx0XHRcdGNvbXBvbmVudHMgPSBmcm9tQ1NTKGFyZyk7XG5cdFx0XHRcdFx0aWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzLmxlbmd0aC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGlmIChhcmcuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gYXJnLl90eXBlO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuX2FscGhhO1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBvaW50LmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gR3JhZGllbnQpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnZ3JhZGllbnQnO1xuXHRcdFx0XHRcdFx0dmFsdWVzID0gYXJncztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdodWUnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHQ/ICdsaWdodG5lc3MnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2hzbCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdoc2InXG5cdFx0XHRcdFx0XHRcdDogJ2dyYWRpZW50JyBpbiBhcmcgfHwgJ3N0b3BzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdHx8ICdyYWRpYWwnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdD8gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyAnZ3JheSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJ3JnYic7XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IGFyZ1twcm9wZXJ0aWVzW2ldXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID09IG51bGwgJiYgaSA9PT0gMCAmJiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0XHQmJiAnc3RvcHMnIGluIGFyZykge1xuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RvcHM6IGFyZy5zdG9wcyxcblx0XHRcdFx0XHRcdFx0XHRcdHJhZGlhbDogYXJnLnJhZGlhbFxuXHRcdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5hbHBoYTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkICYmIHR5cGUpXG5cdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZSB8fCAncmdiJztcblx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHR0aGlzLl9pZCA9IENvbG9yLl9pZCA9IChDb2xvci5faWQgfHwgMCkgKyAxO1xuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHRcdH0sXG5cblx0XHRfY29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvbnZlcnRlcjtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzLnNsaWNlKClcblx0XHRcdFx0XHQ6IChjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLScgKyB0eXBlXSlcblx0XHRcdFx0XHRcdD8gY29udmVydGVyLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0XHQ6IGNvbnZlcnRlcnNbJ3JnYi0nICsgdHlwZV0uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1t0aGlzLl90eXBlICsgJy1yZ2InXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMpKTtcblx0XHR9LFxuXG5cdFx0Y29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCB0aGlzLl9jb252ZXJ0KHR5cGUpLCB0aGlzLl9hbHBoYSk7XG5cdFx0fSxcblxuXHRcdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdFx0fSxcblxuXHRcdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcblx0XHRcdHJldHVybiBjb21wb25lbnRzO1xuXHRcdH0sXG5cblx0XHRnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbCA/IHRoaXMuX2FscGhhIDogMTtcblx0XHR9LFxuXG5cdFx0c2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhID09IG51bGwgPyBudWxsIDogTWF0aC5taW4oTWF0aC5tYXgoYWxwaGEsIDApLCAxKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR9LFxuXG5cdFx0aGFzQWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdHZhciBjb2wgPSBCYXNlLmlzUGxhaW5WYWx1ZShjb2xvciwgdHJ1ZSlcblx0XHRcdFx0XHQ/IENvbG9yLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHRcdDogY29sb3I7XG5cdFx0XHRyZXR1cm4gY29sID09PSB0aGlzIHx8IGNvbCAmJiB0aGlzLl9jbGFzcyA9PT0gY29sLl9jbGFzc1xuXHRcdFx0XHRcdCYmIHRoaXMuX3R5cGUgPT09IGNvbC5fdHlwZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2FscGhhID09PSBjb2wuX2FscGhhXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbiksXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcblx0XHRcdFx0XHRpZiAodmVjdG9yLmdldExlbmd0aCgpID4gcmFkaXVzKVxuXHRcdFx0XHRcdFx0aGlnaGxpZ2h0ID0gb3JpZ2luLmFkZCh2ZWN0b3Iubm9ybWFsaXplKHJhZGl1cyAtIDAuMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGFydCA9IGhpZ2hsaWdodCB8fCBvcmlnaW47XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksXG5cdFx0XHRcdFx0XHQwLCBvcmlnaW4ueCwgb3JpZ2luLnksIHJhZGl1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksXG5cdFx0XHRcdFx0XHRkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV07XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdGFkZDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKyBiO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLSBiO1xuXHRcdH0sXG5cblx0XHRtdWx0aXBseTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgKiBiO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC8gYjtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaChvcGVyYXRvcnMsIGZ1bmN0aW9uKG9wZXJhdG9yLCBuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHRjb2xvciA9IENvbG9yLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0Y29tcG9uZW50czEgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRjb21wb25lbnRzMiA9IGNvbG9yLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzMS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNvbXBvbmVudHMyW2ldID0gb3BlcmF0b3IoY29tcG9uZW50czFbaV0sIGNvbXBvbmVudHMyW2ldKTtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50czIsXG5cdFx0XHRcdFx0dGhpcy5fYWxwaGEgIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IG9wZXJhdG9yKHRoaXMuX2FscGhhLCBjb2xvci5nZXRBbHBoYSgpKVxuXHRcdFx0XHRcdFx0XHQ6IG51bGwpO1xuXHRcdH07XG5cdH0sIHtcblx0fSk7XG59KTtcblxuQmFzZS5lYWNoKENvbG9yLl90eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHR2YXIgY3RvciA9IHRoaXNbQmFzZS5jYXBpdGFsaXplKHR5cGUpICsgJ0NvbG9yJ10gPSBmdW5jdGlvbihhcmcpIHtcblx0XHRcdHZhciBhcmdUeXBlID0gYXJnICE9IG51bGwgJiYgdHlwZW9mIGFyZyxcblx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0OiBhcmdUeXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cztcblx0XHRcdHJldHVybiBjb21wb25lbnRzXG5cdFx0XHRcdFx0PyBuZXcgQ29sb3IodHlwZSwgY29tcG9uZW50cylcblx0XHRcdFx0XHQ6IG5ldyBDb2xvcihhcmcpO1xuXHRcdH07XG5cdGlmICh0eXBlLmxlbmd0aCA9PSAzKSB7XG5cdFx0dmFyIGFjcm9ueW0gPSB0eXBlLnRvVXBwZXJDYXNlKCk7XG5cdFx0Q29sb3JbYWNyb255bV0gPSB0aGlzW2Fjcm9ueW0gKyAnQ29sb3InXSA9IGN0b3I7XG5cdH1cbn0sIEJhc2UuZXhwb3J0cyk7XG5cbnZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcblx0XHR0aGlzLl9pZCA9IEdyYWRpZW50Ll9pZCA9IChHcmFkaWVudC5faWQgfHwgMCkgKyAxO1xuXHRcdGlmIChzdG9wcyAmJiB0aGlzLl9zZXQoc3RvcHMpKVxuXHRcdFx0c3RvcHMgPSByYWRpYWwgPSBudWxsO1xuXHRcdGlmICghdGhpcy5fc3RvcHMpXG5cdFx0XHR0aGlzLnNldFN0b3BzKHN0b3BzIHx8IFsnd2hpdGUnLCAnYmxhY2snXSk7XG5cdFx0aWYgKHRoaXMuX3JhZGlhbCA9PSBudWxsKVxuXHRcdFx0dGhpcy5zZXRSYWRpYWwodHlwZW9mIHJhZGlhbCA9PT0gJ3N0cmluZycgJiYgcmFkaWFsID09PSAncmFkaWFsJ1xuXHRcdFx0XHRcdHx8IHJhZGlhbCB8fCBmYWxzZSk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fc3RvcHMsIHRoaXMuX3JhZGlhbF0sXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fb3duZXJzICYmIHRoaXMuX293bmVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9vd25lcnNbaV0uX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfYWRkT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0aWYgKCF0aGlzLl9vd25lcnMpXG5cdFx0XHR0aGlzLl9vd25lcnMgPSBbXTtcblx0XHR0aGlzLl9vd25lcnMucHVzaChjb2xvcik7XG5cdH0sXG5cblx0X3JlbW92ZU93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuX293bmVycyA/IHRoaXMuX293bmVycy5pbmRleE9mKGNvbG9yKSA6IC0xO1xuXHRcdGlmIChpbmRleCAhPSAtMSkge1xuXHRcdFx0dGhpcy5fb3duZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpZiAodGhpcy5fb3duZXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0dGhpcy5fb3duZXJzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHN0b3BzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzdG9wc1tpXSA9IHRoaXMuX3N0b3BzW2ldLmNsb25lKCk7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudChzdG9wcyk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAodGhpcy5zdG9wcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKHN0b3BzLmxlbmd0aCA8IDIpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcblx0XHR0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkQWxsKHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW2ldO1xuXHRcdFx0c3RvcC5fb3duZXIgPSB0aGlzO1xuXHRcdFx0aWYgKHN0b3AuX2RlZmF1bHRSYW1wKVxuXHRcdFx0XHRzdG9wLnNldFJhbXBQb2ludChpIC8gKGwgLSAxKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdG9wcy5sZW5ndGggPT09IGdyYWRpZW50Ll9zdG9wcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RvcHNbaV0uZXF1YWxzKGdyYWRpZW50Ll9zdG9wc1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoYXJnMCkge1xuXHRcdFx0dmFyIGNvbG9yLCByYW1wUG9pbnQ7XG5cdFx0XHRpZiAoYXJnMSA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmNvbG9yKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMC5jb2xvcjtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMC5yYW1wUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2xvciA9IGFyZzA7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuc2V0UmFtcFBvaW50KHJhbXBQb2ludCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9yYW1wUG9pbnQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NvbG9yLCB0aGlzLl9yYW1wUG9pbnRdLCBvcHRpb25zLCB0cnVlLFxuXHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhbXBQb2ludDtcblx0fSxcblxuXHRzZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKHJhbXBQb2ludCkge1xuXHRcdHRoaXMuX2RlZmF1bHRSYW1wID0gcmFtcFBvaW50ID09IG51bGw7XG5cdFx0dGhpcy5fcmFtcFBvaW50ID0gcmFtcFBvaW50IHx8IDA7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3I7XG5cdH0sXG5cblx0c2V0Q29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dGhpcy5fY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2NvbG9yID09PSBjb2xvcilcblx0XHRcdHRoaXMuX2NvbG9yID0gY29sb3IuY2xvbmUoKTtcblx0XHR0aGlzLl9jb2xvci5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0b3ApIHtcblx0XHRyZXR1cm4gc3RvcCA9PT0gdGhpcyB8fCBzdG9wICYmIHRoaXMuX2NsYXNzID09PSBzdG9wLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpXG5cdFx0XHRcdCYmIHRoaXMuX3JhbXBQb2ludCA9PSBzdG9wLl9yYW1wUG9pbnRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRcdHN0cm9rZUpvaW46ICdtaXRlcicsXG5cdFx0c3Ryb2tlU2NhbGluZzogdHJ1ZSxcblx0XHRtaXRlckxpbWl0OiAxMCxcblx0XHRkYXNoT2Zmc2V0OiAwLFxuXHRcdGRhc2hBcnJheTogW10sXG5cdFx0d2luZGluZ1J1bGU6ICdub256ZXJvJyxcblx0XHRzaGFkb3dDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiB1bmRlZmluZWQsXG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRmb250OiAnc2Fucy1zZXJpZicsXG5cdFx0bGVhZGluZzogbnVsbCxcblx0XHRqdXN0aWZpY2F0aW9uOiAnbGVmdCdcblx0fTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0c3Ryb2tlV2lkdGg6IDk3LFxuXHRcdHN0cm9rZUNhcDogOTcsXG5cdFx0c3Ryb2tlSm9pbjogOTcsXG5cdFx0c3Ryb2tlU2NhbGluZzogMTA1LFxuXHRcdG1pdGVyTGltaXQ6IDk3LFxuXHRcdGZvbnRGYW1pbHk6IDksXG5cdFx0Zm9udFdlaWdodDogOSxcblx0XHRmb250U2l6ZTogOSxcblx0XHRmb250OiA5LFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9O1xuXG5cdHZhciBpdGVtID0geyBiZWFuczogdHJ1ZSB9LFxuXHRcdGZpZWxkcyA9IHtcblx0XHRcdF9kZWZhdWx0czogZGVmYXVsdHMsXG5cdFx0XHRfdGV4dERlZmF1bHRzOiBuZXcgQmFzZShkZWZhdWx0cywge1xuXHRcdFx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHR9KSxcblx0XHRcdGJlYW5zOiB0cnVlXG5cdFx0fTtcblxuXHRCYXNlLmVhY2goZGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKG9sZCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNDb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKG9sZClcblx0XHRcdFx0XHRcdFx0b2xkLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLl9vd25lcilcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZpZWxkc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IF9kb250TWVyZ2Vcblx0XHRcdFx0XHR8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2RlZmF1bHRzW2tleV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjdG9yID0gaXNDb2xvciA/IENvbG9yIDogaXNQb2ludCA/IFBvaW50IDogbnVsbDtcblx0XHRcdFx0XHRpZiAoY3RvciAmJiAhKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBjdG9yKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZSA9IGN0b3IucmVhZChbdmFsdWVdLCAwLFxuXHRcdFx0XHRcdFx0XHRcdHsgcmVhZE51bGw6IHRydWUsIGNsb25lOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIGlzQ29sb3IpXG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjaGlsZFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY2hpbGRWYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZVtnZXRdKF9kb250TWVyZ2UpO1xuXHRcdH07XG5cblx0XHRpdGVtW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0fTtcblx0fSk7XG5cblx0SXRlbS5pbmplY3QoaXRlbSk7XG5cdHJldHVybiBmaWVsZHM7XG59LCB7XG5cdF9jbGFzczogJ1N0eWxlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuXHRcdHRoaXMuX3ZhbHVlcyA9IHt9O1xuXHRcdHRoaXMuX293bmVyID0gX293bmVyO1xuXHRcdHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtKVxuXHRcdFx0dGhpcy5fZGVmYXVsdHMgPSB0aGlzLl90ZXh0RGVmYXVsdHM7XG5cdFx0aWYgKHN0eWxlKVxuXHRcdFx0dGhpcy5zZXQoc3R5bGUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR2YXIgaXNTdHlsZSA9IHN0eWxlIGluc3RhbmNlb2YgU3R5bGUsXG5cdFx0XHR2YWx1ZXMgPSBpc1N0eWxlID8gc3R5bGUuX3ZhbHVlcyA6IHN0eWxlO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlICYmIGlzU3R5bGUgJiYgdmFsdWUuY2xvbmVcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHJldHVybiBzdHlsZSA9PT0gdGhpcyB8fCBzdHlsZSAmJiB0aGlzLl9jbGFzcyA9PT0gc3R5bGUuX2NsYXNzXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3ZhbHVlcywgc3R5bGUuX3ZhbHVlcylcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRGaWxsQ29sb3IoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U3Ryb2tlQ29sb3IoKSAmJiB0aGlzLmdldFN0cm9rZVdpZHRoKCkgPiAwO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRTaGFkb3dDb2xvcigpICYmIHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMDtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblx0XHRcdGlmICghdmlld3BvcnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcblx0XHRcdFx0dmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuXHRcdH0sXG5cblx0XHRnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG5cdFx0fSxcblxuXHRcdGlzSW52aXNpYmxlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcblx0XHR9LFxuXG5cdFx0aXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG5cdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuXHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlc1xuXHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoXG5cdFx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzWzBdXG5cdFx0XHRcdFx0OiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuXHRcdFx0XHQ6IGV2ZW50O1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb3MucGFnZVggfHwgcG9zLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcblx0XHRcdHBvcy5wYWdlWSB8fCBwb3MuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Bcblx0XHQpO1xuXHR9LFxuXG5cdGdldFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UmVsYXRlZFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihldmVudCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldFBvaW50KGV2ZW50KS5zdWJ0cmFjdChEb21FbGVtZW50LmdldE9mZnNldChcblx0XHRcdFx0dGFyZ2V0IHx8IERvbUV2ZW50LmdldFRhcmdldChldmVudCkpKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG5hdGl2ZVJlcXVlc3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0RG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHRmb2N1c2VkID0gdHJ1ZSxcblx0XHR0aW1lcjtcblxuXHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICkge1xuXHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRcdGZvY3VzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9jdXNlZCA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Ymx1cjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvY3VzZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHRmb3IgKHZhciBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBjYWxsYmFja3NbaV0sXG5cdFx0XHRcdGZ1bmMgPSBlbnRyeVswXSxcblx0XHRcdFx0ZWwgPSBlbnRyeVsxXTtcblx0XHRcdGlmICghZWwgfHwgKFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsLCAna2VlcGFsaXZlJykgPT0gJ3RydWUnXG5cdFx0XHRcdFx0fHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcblx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goW2NhbGxiYWNrLCBlbGVtZW50XSk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKCAhbm9DYW52YXMgKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG5cdFx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXHRcdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRcdGlmICh0aGlzLl9pZCA9PSBudWxsKVxuXHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCA9ICd2aWV3LScgKyBWaWV3Ll9pZCsrKTtcblx0XHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHRcdHZhciBub25lID0gJ25vbmUnO1xuXHRcdFx0RG9tRWxlbWVudC5zZXRQcmVmaXhlZChlbGVtZW50LnN0eWxlLCB7XG5cdFx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHRcdHRvdWNoQWN0aW9uOiBub25lLFxuXHRcdFx0XHR0b3VjaENhbGxvdXQ6IG5vbmUsXG5cdFx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0XHR1c2VyRHJhZzogbm9uZSxcblx0XHRcdFx0dGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuXHRcdFx0fSk7XG5cblx0XHRcdGZ1bmN0aW9uIGdldFNpemUobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudFtuYW1lXSB8fCBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSwgMTApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRDYW52YXNTaXplKCkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpXG5cdFx0XHRcdFx0XHQ/IG5ldyBTaXplKGdldFNpemUoJ3dpZHRoJyksIGdldFNpemUoJ2hlaWdodCcpKVxuXHRcdFx0XHRcdFx0OiBzaXplO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzID0ge1xuXHRcdFx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHR0aGF0LnNldFZpZXdTaXplKGdldENhbnZhc1NpemUoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NldFZpZXdTaXplKHNpemUgPSBnZXRDYW52YXNTaXplKCkpO1xuXHRcdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdFx0JiYgdHlwZW9mIFN0YXRzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHR0aGlzLl9zdGF0cyA9IG5ldyBTdGF0cygpO1xuXHRcdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRcdHN0eWxlID0gc3RhdHMuc3R5bGUsXG5cdFx0XHRcdFx0b2Zmc2V0ID0gRG9tRWxlbWVudC5nZXRPZmZzZXQoZWxlbWVudCk7XG5cdFx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdFx0c3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4Jztcblx0XHRcdFx0c3R5bGUudG9wID0gb2Zmc2V0LnkgKyAncHgnO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG5cdFx0XHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdFx0dGhpcy5faWQgPSAndmlldy0nICsgVmlldy5faWQrKztcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShlbGVtZW50LndpZHRoLCBlbGVtZW50LmhlaWdodCk7XG5cdFx0fVxuXHRcdFZpZXcuX3ZpZXdzLnB1c2godGhpcyk7XG5cdFx0Vmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0dGhpcy5fdmlld1NpemUgPSBzaXplO1xuXHRcdCh0aGlzLl9tYXRyaXggPSBuZXcgTWF0cml4KCkpLl9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fem9vbSA9IDE7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRoaXM7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX2ZyYW1lSXRlbUNvdW50ID0gMDtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fcHJvamVjdClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAoVmlldy5fZm9jdXNlZCA9PT0gdGhpcylcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSBudWxsO1xuXHRcdFZpZXcuX3ZpZXdzLnNwbGljZShWaWV3Ll92aWV3cy5pbmRleE9mKHRoaXMpLCAxKTtcblx0XHRkZWxldGUgVmlldy5fdmlld3NCeUlkW3RoaXMuX2lkXTtcblx0XHRpZiAodGhpcy5fcHJvamVjdC5fdmlldyA9PT0gdGhpcylcblx0XHRcdHRoaXMuX3Byb2plY3QuX3ZpZXcgPSBudWxsO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHREb21FdmVudC5yZW1vdmUod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMpO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSB0aGlzLl9wcm9qZWN0ID0gbnVsbDtcblx0XHR0aGlzLm9mZignZnJhbWUnKTtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdFx0dGhpcy5fZnJhbWVJdGVtcyA9IHt9O1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9ldmVudHM6IHtcblx0XHRvbkZyYW1lOiB7XG5cdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHR9LFxuXG5cdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG9uUmVzaXplOiB7fVxuXHR9LFxuXG5cdF9hbmltYXRlOiBmYWxzZSxcblx0X3RpbWU6IDAsXG5cdF9jb3VudDogMCxcblxuXHRfcmVxdWVzdEZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0RG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fcmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoIXRoYXQuX2FuaW1hdGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoYXQuX3JlcXVlc3RGcmFtZSgpO1xuXHRcdFx0dGhhdC5faGFuZGxlRnJhbWUoKTtcblx0XHR9LCB0aGlzLl9lbGVtZW50KTtcblx0XHR0aGlzLl9yZXF1ZXN0ZWQgPSB0cnVlO1xuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDAsXG5cdFx0XHRkZWx0YSA9IHRoaXMuX2JlZm9yZSA/IG5vdyAtIHRoaXMuX2JlZm9yZSA6IDA7XG5cdFx0dGhpcy5fYmVmb3JlID0gbm93O1xuXHRcdHRoaXMuX2hhbmRsaW5nRnJhbWUgPSB0cnVlO1xuXHRcdHRoaXMuZW1pdCgnZnJhbWUnLCBuZXcgQmFzZSh7XG5cdFx0XHRkZWx0YTogZGVsdGEsXG5cdFx0XHR0aW1lOiB0aGlzLl90aW1lICs9IGRlbHRhLFxuXHRcdFx0Y291bnQ6IHRoaXMuX2NvdW50Kytcblx0XHR9KSk7XG5cdFx0aWYgKHRoaXMuX3N0YXRzKVxuXHRcdFx0dGhpcy5fc3RhdHMudXBkYXRlKCk7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihpdGVtLCBhbmltYXRlKSB7XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fZnJhbWVJdGVtcztcblx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0aXRlbXNbaXRlbS5faWRdID0ge1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHR0aW1lOiAwLFxuXHRcdFx0XHRjb3VudDogMFxuXHRcdFx0fTtcblx0XHRcdGlmICgrK3RoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAxKVxuXHRcdFx0XHR0aGlzLm9uKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgaXRlbXNbaXRlbS5faWRdO1xuXHRcdFx0aWYgKC0tdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDApIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZUl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcblx0XHRcdGVudHJ5Lml0ZW0uZW1pdCgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuXHRcdFx0XHR0aW1lOiBlbnRyeS50aW1lICs9IGV2ZW50LmRlbHRhLFxuXHRcdFx0XHRjb3VudDogZW50cnkuY291bnQrK1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0aWYgKHRoaXMuX2hhbmRsaW5nRnJhbWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDEpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH0sXG5cblx0X3RyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmNvbmNhdGVuYXRlKG1hdHJpeCk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWxlbWVudDtcblx0fSxcblxuXHRnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyAqIDcyO1xuXHR9LFxuXG5cdGdldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFZpZXdTaXplJyk7XG5cdH0sXG5cblx0c2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRkZWx0YSA9IHNpemUuc3VidHJhY3QodGhpcy5fdmlld1NpemUpO1xuXHRcdGlmIChkZWx0YS5pc1plcm8oKSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3NldFZpZXdTaXplKHNpemUpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cdFx0dGhpcy5lbWl0KCdyZXNpemUnLCB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0ZGVsdGE6IGRlbHRhXG5cdFx0fSk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHRcdGVsZW1lbnQud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG5cdFx0XHRcdFx0bmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNjcm9sbEJ5KGNlbnRlci5zdWJ0cmFjdCh0aGlzLmdldENlbnRlcigpKSk7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XG5cdH0sXG5cblx0c2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuX3pvb20sXG5cdFx0XHR0aGlzLmdldENlbnRlcigpKSk7XG5cdFx0dGhpcy5fem9vbSA9IHpvb207XG5cdH0sXG5cblx0aXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRG9tRWxlbWVudC5pc0luVmlldyh0aGlzLl9lbGVtZW50KTtcblx0fSxcblxuXHRzY3JvbGxCeTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKSk7XG5cdH0sXG5cblx0cGxheTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IHRydWU7XG5cdFx0aWYgKCF0aGlzLl9yZXF1ZXN0ZWQpXG5cdFx0XHR0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcblx0fSxcblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH1cblxufSwge1xuXHRzdGF0aWNzOiB7XG5cdFx0X3ZpZXdzOiBbXSxcblx0XHRfdmlld3NCeUlkOiB7fSxcblx0XHRfaWQ6IDAsXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHRcdGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcblx0XHRcdHJldHVybiBuZXcgQ2FudmFzVmlldyhwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0aWYgKCBub0NhbnZhcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgdG9vbCxcblx0XHRwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcblx0XHRyZXR1cm4gdmlldy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX3ZpZXdzW2ldO1xuXHRcdFx0XHRpZiAodmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KSB7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0dmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuXHRcdGlmICh0b29sKSB7XG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudChkcmFnZ2luZyAmJiB0b29sLnJlc3BvbmRzKCdtb3VzZWRyYWcnKVxuXHRcdFx0XHRcdD8gJ21vdXNlZHJhZycgOiAnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdFx0dmlldy51cGRhdGUoKTtcblx0XHRyZXR1cm4gdG9vbDtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHtcblx0XHQnc2VsZWN0c3RhcnQgZHJhZ3N0YXJ0JzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkcmFnZ2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY0V2ZW50cyA9IHtcblx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdH0sXG5cblx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcblx0XHRcdHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0XHRpZiAoZHJhZ2dpbmcgfHwgdmlldy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdHRvb2wgPSBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICFkcmFnZ2luZylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoICFub0NhbnZhcyApIHtcblx0XHRcdGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkge1xuXHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcblx0XHRcdFx0XHRcdFx0KyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuXHRcdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0fVxuXHRcdHRoaXMuX2V2ZW50Q291bnRlcnMgPSB7fTtcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHRpZiAoIW5vQ2FudmFzICYmICEvXm9mZnxmYWxzZSQvLnRlc3QoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoY2FudmFzLCAnaGlkcGknKSkpIHtcblx0XHRcdHZhciBkZXZpY2VSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdGJhY2tpbmdTdG9yZVJhdGlvID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRcdFx0J2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdFx0fVxuXHRcdFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvLFxuXHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRlbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpIHtcblx0XHRcdGlmICghUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdHNpemUgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiBzaXplO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKCFwcm9qZWN0IHx8ICFwcm9qZWN0Ll9uZWVkc1VwZGF0ZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBkb3duUG9pbnQsXG5cdFx0bGFzdFBvaW50LFxuXHRcdG92ZXJQb2ludCxcblx0XHRkb3duSXRlbSxcblx0XHRsYXN0SXRlbSxcblx0XHRvdmVySXRlbSxcblx0XHRkcmFnSXRlbSxcblx0XHRkYmxDbGljayxcblx0XHRjbGlja1RpbWU7XG5cblx0ZnVuY3Rpb24gY2FsbEV2ZW50KHZpZXcsIHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBsYXN0UG9pbnQpIHtcblx0XHR2YXIgaXRlbSA9IHRhcmdldCxcblx0XHRcdG1vdXNlRXZlbnQ7XG5cblx0XHRmdW5jdGlvbiBjYWxsKG9iaikge1xuXHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRpZiAoIW1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludCA/IHBvaW50LnN1YnRyYWN0KGxhc3RQb2ludCkgOiBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2JqLmVtaXQodHlwZSwgbW91c2VFdmVudCkgJiYgbW91c2VFdmVudC5pc1N0b3BwZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmIChjYWxsKGl0ZW0pKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGl0ZW0gPSBpdGVtLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRpZiAoY2FsbCh2aWV3KSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcblx0XHRcdGlmICghdGhpcy5fZXZlbnRDb3VudGVyc1t0eXBlXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRoaXQgPSBwcm9qZWN0LmhpdFRlc3QocG9pbnQsIHtcblx0XHRcdFx0XHR0b2xlcmFuY2U6IDAsXG5cdFx0XHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdFx0XHRzdHJva2U6IHRydWVcblx0XHRcdFx0fSksXG5cdFx0XHRcdGl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0sXG5cdFx0XHRcdHN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRkYmxDbGljayA9IGxhc3RJdGVtID09IGl0ZW0gJiYgKERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDApO1xuXHRcdFx0XHRkb3duSXRlbSA9IGxhc3RJdGVtID0gaXRlbTtcblx0XHRcdFx0ZG93blBvaW50ID0gbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGRyYWdJdGVtID0gIXN0b3BwZWQgJiYgaXRlbTtcblx0XHRcdFx0d2hpbGUgKGRyYWdJdGVtICYmICFkcmFnSXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdFx0ZHJhZ0l0ZW0gPSBkcmFnSXRlbS5fcGFyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSwgZG93blBvaW50KTtcblx0XHRcdFx0aWYgKGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RQb2ludCAmJiAhbGFzdFBvaW50LmVxdWFscyhwb2ludCkpXG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCwgZHJhZ0l0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50KTtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdG9wcGVkICYmIGl0ZW0gJiYgaXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCBkYmxDbGljayAmJiBkb3duSXRlbS5yZXNwb25kcygnZG91YmxlY2xpY2snKVxuXHRcdFx0XHRcdFx0XHQ/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgZG93blBvaW50LCBpdGVtKTtcblx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdGlmIChkcmFnSXRlbSlcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsXG5cdFx0XHRcdFx0XHRcdGRyYWdJdGVtLCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRpZiAoIXN0b3BwZWQpIHtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pXG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50LCBvdmVySXRlbSk7XG5cdFx0XHRcdFx0b3Zlckl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RvcHBlZDtcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEV2ZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gRXZlbnQoZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0aXNQcmV2ZW50ZWQ6IGZhbHNlLFxuXHRpc1N0b3BwZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzUHJldmVudGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdHRoaXMucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBLZXkubW9kaWZpZXJzO1xuXHR9XG59KTtcblxudmFyIEtleUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnS2V5RXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnO1xuXHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywga2V5OiAnXCIgKyB0aGlzLmtleVxuXHRcdFx0XHQrIFwiJywgY2hhcmFjdGVyOiAnXCIgKyB0aGlzLmNoYXJhY3RlclxuXHRcdFx0XHQrIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyBcIiB9XCI7XG5cdH1cbn0pO1xuXG52YXIgS2V5ID0gbmV3IGZ1bmN0aW9uKCkge1xuXHRpZiAoIG5vQ2FudmFzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBzcGVjaWFsS2V5cyA9IHtcblx0XHQ4OiAnYmFja3NwYWNlJyxcblx0XHQ5OiAndGFiJyxcblx0XHQxMzogJ2VudGVyJyxcblx0XHQxNjogJ3NoaWZ0Jyxcblx0XHQxNzogJ2NvbnRyb2wnLFxuXHRcdDE4OiAnb3B0aW9uJyxcblx0XHQxOTogJ3BhdXNlJyxcblx0XHQyMDogJ2NhcHMtbG9jaycsXG5cdFx0Mjc6ICdlc2NhcGUnLFxuXHRcdDMyOiAnc3BhY2UnLFxuXHRcdDM1OiAnZW5kJyxcblx0XHQzNjogJ2hvbWUnLFxuXHRcdDM3OiAnbGVmdCcsXG5cdFx0Mzg6ICd1cCcsXG5cdFx0Mzk6ICdyaWdodCcsXG5cdFx0NDA6ICdkb3duJyxcblx0XHQ0NjogJ2RlbGV0ZScsXG5cdFx0OTE6ICdjb21tYW5kJyxcblx0XHQ5MzogJ2NvbW1hbmQnLFxuXHRcdDIyNDogJ2NvbW1hbmQnXG5cdH0sXG5cblx0c3BlY2lhbENoYXJzID0ge1xuXHRcdDk6IHRydWUsXG5cdFx0MTM6IHRydWUsXG5cdFx0MzI6IHRydWVcblx0fSxcblxuXHRtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG5cdFx0c2hpZnQ6IGZhbHNlLFxuXHRcdGNvbnRyb2w6IGZhbHNlLFxuXHRcdG9wdGlvbjogZmFsc2UsXG5cdFx0Y29tbWFuZDogZmFsc2UsXG5cdFx0Y2Fwc0xvY2s6IGZhbHNlLFxuXHRcdHNwYWNlOiBmYWxzZVxuXHR9KSxcblxuXHRjaGFyQ29kZU1hcCA9IHt9LFxuXHRrZXlNYXAgPSB7fSxcblx0ZG93bkNvZGU7XG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleUNvZGUsIGNoYXJDb2RlLCBldmVudCkge1xuXHRcdHZhciBjaGFyYWN0ZXIgPSBjaGFyQ29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpIDogJycsXG5cdFx0XHRzcGVjaWFsS2V5ID0gc3BlY2lhbEtleXNba2V5Q29kZV0sXG5cdFx0XHRrZXkgPSBzcGVjaWFsS2V5IHx8IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0dHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuXHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRzY29wZSA9IHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSAmJiB2aWV3Ll9zY29wZSxcblx0XHRcdHRvb2wgPSBzY29wZSAmJiBzY29wZS50b29sLFxuXHRcdFx0bmFtZTtcblx0XHRrZXlNYXBba2V5XSA9IGRvd247XG5cdFx0aWYgKHNwZWNpYWxLZXkgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKHNwZWNpYWxLZXkpKSBpbiBtb2RpZmllcnMpXG5cdFx0XHRtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuXHRcdGlmIChkb3duKSB7XG5cdFx0XHRjaGFyQ29kZU1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgY2hhckNvZGVNYXBba2V5Q29kZV07XG5cdFx0fVxuXHRcdGlmICh0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR0b29sLmVtaXQodHlwZSwgbmV3IEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkpO1xuXHRcdFx0aWYgKHZpZXcpXG5cdFx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIHNwZWNpYWxLZXlzIHx8IG1vZGlmaWVycy5jb21tYW5kKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBjb2RlLFxuXHRcdFx0XHRcdFx0Y29kZSBpbiBzcGVjaWFsQ2hhcnMgfHwgbW9kaWZpZXJzLmNvbW1hbmQgPyBjb2RlIDogMCxcblx0XHRcdFx0XHRcdGV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvd25Db2RlID0gY29kZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZG93bkNvZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgZG93bkNvZGUsIGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGUsIGV2ZW50KTtcblx0XHRcdFx0ZG93bkNvZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Ymx1cjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGZvciAodmFyIGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0bW9kaWZpZXJzOiBtb2RpZmllcnMsXG5cblx0XHRpc0Rvd246IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuICEha2V5TWFwW2tleV07XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdNb3VzZUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnRcblx0XHRcdFx0KyAnLCB0YXJnZXQ6ICcgKyB0aGlzLnRhcmdldFxuXHRcdFx0XHQrICh0aGlzLmRlbHRhID8gJywgZGVsdGE6ICcgKyB0aGlzLmRlbHRhIDogJycpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbEV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbEV2ZW50Jyxcblx0X2l0ZW06IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSB7XG5cdFx0dGhpcy50b29sID0gdG9vbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRfY2hvb3NlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCB0b29sUG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX3BvaW50LCB0aGlzLnRvb2wuX3BvaW50KTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHR9LFxuXG5cdGdldExhc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuXHR9LFxuXG5cdHNldExhc3RQb2ludDogZnVuY3Rpb24obGFzdFBvaW50KSB7XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuXHR9LFxuXG5cdGdldERvd25Qb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2Rvd25Qb2ludCwgdGhpcy50b29sLl9kb3duUG9pbnQpO1xuXHR9LFxuXG5cdHNldERvd25Qb2ludDogZnVuY3Rpb24oZG93blBvaW50KSB7XG5cdFx0dGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuXHR9LFxuXG5cdGdldE1pZGRsZVBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX21pZGRsZVBvaW50ICYmIHRoaXMudG9vbC5fbGFzdFBvaW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b29sLl9wb2ludC5hZGQodGhpcy50b29sLl9sYXN0UG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21pZGRsZVBvaW50O1xuXHR9LFxuXG5cdHNldE1pZGRsZVBvaW50OiBmdW5jdGlvbihtaWRkbGVQb2ludCkge1xuXHRcdHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0Z2V0RGVsdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZGVsdGEgJiYgdGhpcy50b29sLl9sYXN0UG9pbnRcblx0XHRcdFx0PyB0aGlzLnRvb2wuX3BvaW50LnN1YnRyYWN0KHRoaXMudG9vbC5fbGFzdFBvaW50KVxuXHRcdFx0XHQ6IHRoaXMuX2RlbHRhO1xuXHR9LFxuXG5cdHNldERlbHRhOiBmdW5jdGlvbihkZWx0YSkge1xuXHRcdHRoaXMuX2RlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0Z2V0Q291bnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpXG5cdFx0XHRcdD8gdGhpcy50b29sLl9kb3duQ291bnRcblx0XHRcdFx0OiB0aGlzLnRvb2wuX2NvdW50O1xuXHR9LFxuXG5cdHNldENvdW50OiBmdW5jdGlvbihjb3VudCkge1xuXHRcdHRoaXMudG9vbFsvXm1vdXNlKGRvd258dXApJC8udGVzdCh0aGlzLnR5cGUpID8gJ2Rvd25Db3VudCcgOiAnY291bnQnXVxuXHRcdFx0PSBjb3VudDtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2l0ZW0pIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLnRvb2wuX3Njb3BlLnByb2plY3QuaGl0VGVzdCh0aGlzLmdldFBvaW50KCkpO1xuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHR2YXIgaXRlbSA9IHJlc3VsdC5pdGVtLFxuXHRcdFx0XHRcdHBhcmVudCA9IGl0ZW0uX3BhcmVudDtcblx0XHRcdFx0d2hpbGUgKC9eKEdyb3VwfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHBhcmVudDtcblx0XHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2l0ZW07XG5cdH0sXG5cblx0c2V0SXRlbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3sgdHlwZTogJyArIHRoaXMudHlwZVxuXHRcdFx0XHQrICcsIHBvaW50OiAnICsgdGhpcy5nZXRQb2ludCgpXG5cdFx0XHRcdCsgJywgY291bnQ6ICcgKyB0aGlzLmdldENvdW50KClcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbCcsXG5cdF9saXN0OiAndG9vbHMnLFxuXHRfcmVmZXJlbmNlOiAndG9vbCcsXG5cdF9ldmVudHM6IFsgJ29uQWN0aXZhdGUnLCAnb25EZWFjdGl2YXRlJywgJ29uRWRpdE9wdGlvbnMnLFxuXHRcdFx0J29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbk1vdXNlTW92ZScsXG5cdFx0XHQnb25LZXlEb3duJywgJ29uS2V5VXAnIF0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbChwcm9wcykge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcblx0XHR0aGlzLl9jb3VudCA9IDA7XG5cdFx0dGhpcy5fZG93bkNvdW50ID0gMDtcblx0XHR0aGlzLl9zZXQocHJvcHMpO1xuXHR9LFxuXG5cdGdldE1pbkRpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKG1pbkRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblx0XHRpZiAodGhpcy5fbWluRGlzdGFuY2UgIT0gbnVsbCAmJiB0aGlzLl9tYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIHRoaXMuX21pbkRpc3RhbmNlID4gdGhpcy5fbWF4RGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21heERpc3RhbmNlID0gdGhpcy5fbWluRGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1heERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4RGlzdGFuY2U7XG5cdH0sXG5cblx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHRpZiAodGhpcy5fbWluRGlzdGFuY2UgIT0gbnVsbCAmJiB0aGlzLl9tYXhEaXN0YW5jZSAhPSBudWxsXG5cdFx0XHRcdCYmIHRoaXMuX21heERpc3RhbmNlIDwgdGhpcy5fbWluRGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZSA9PSB0aGlzLl9tYXhEaXN0YW5jZVxuXHRcdFx0PyB0aGlzLl9taW5EaXN0YW5jZSA6IG51bGw7XG5cdH0sXG5cblx0c2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oZGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdH0sXG5cblx0X3VwZGF0ZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlLCBzdGFydCxcblx0XHRcdG5lZWRzQ2hhbmdlLCBtYXRjaE1heERpc3RhbmNlKSB7XG5cdFx0aWYgKCFzdGFydCkge1xuXHRcdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgfHwgbWF4RGlzdGFuY2UgIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgbWluRGlzdCA9IG1pbkRpc3RhbmNlICE9IG51bGwgPyBtaW5EaXN0YW5jZSA6IDAsXG5cdFx0XHRcdFx0dmVjdG9yID0gcG9pbnQuc3VidHJhY3QodGhpcy5fcG9pbnQpLFxuXHRcdFx0XHRcdGRpc3RhbmNlID0gdmVjdG9yLmdldExlbmd0aCgpO1xuXHRcdFx0XHRpZiAoZGlzdGFuY2UgPCBtaW5EaXN0KVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0dmFyIG1heERpc3QgPSBtYXhEaXN0YW5jZSAhPSBudWxsID8gbWF4RGlzdGFuY2UgOiAwO1xuXHRcdFx0XHRpZiAobWF4RGlzdCAhPSAwKSB7XG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlID4gbWF4RGlzdCkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSB0aGlzLl9wb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShtYXhEaXN0KSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtYXRjaE1heERpc3RhbmNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobmVlZHNDaGFuZ2UgJiYgcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLl9sYXN0UG9pbnQgPSBzdGFydCAmJiB0eXBlID09ICdtb3VzZW1vdmUnID8gcG9pbnQgOiB0aGlzLl9wb2ludDtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHR0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duUG9pbnQgPSB0aGlzLl9wb2ludDtcblx0XHRcdHRoaXMuX2Rvd25Db3VudCsrO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHR0aGlzLl9sYXN0UG9pbnQgPSB0aGlzLl9kb3duUG9pbnQ7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dGhpcy5fY291bnQgPSBzdGFydCA/IDAgOiB0aGlzLl9jb3VudCArIDE7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2ZpcmVFdmVudDogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcblx0XHR2YXIgc2V0cyA9IHBhcGVyLnByb2plY3QuX3JlbW92ZVNldHM7XG5cdFx0aWYgKHNldHMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnbW91c2V1cCcpXG5cdFx0XHRcdHNldHMubW91c2VkcmFnID0gbnVsbDtcblx0XHRcdHZhciBzZXQgPSBzZXRzW3R5cGVdO1xuXHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRmb3IgKHZhciBpZCBpbiBzZXQpIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHNldFtpZF07XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHNldHMpIHtcblx0XHRcdFx0XHRcdHZhciBvdGhlciA9IHNldHNba2V5XTtcblx0XHRcdFx0XHRcdGlmIChvdGhlciAmJiBvdGhlciAhPSBzZXQpXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBvdGhlcltpdGVtLl9pZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2V0c1t0eXBlXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnJlc3BvbmRzKHR5cGUpXG5cdFx0XHRcdCYmIHRoaXMuZW1pdCh0eXBlLCBuZXcgVG9vbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50KSk7XG5cdH0sXG5cblx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBjYWxsZWQgPSBmYWxzZTtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2VkcmFnJzpcblx0XHRcdHZhciBuZWVkc0NoYW5nZSA9IGZhbHNlLFxuXHRcdFx0XHRtYXRjaE1heERpc3RhbmNlID0gZmFsc2U7XG5cdFx0XHR3aGlsZSAodGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIG5lZWRzQ2hhbmdlLCBtYXRjaE1heERpc3RhbmNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0bmVlZHNDaGFuZ2UgPSB0cnVlO1xuXHRcdFx0XHRtYXRjaE1heERpc3RhbmNlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0aWYgKCFwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpXG5cdFx0XHRcdFx0JiYgdGhpcy5fdXBkYXRlRXZlbnQoJ21vdXNlZHJhZycsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQoJ21vdXNlZHJhZycsIGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCB0aGlzLm1heERpc3RhbmNlLCBmYWxzZSxcblx0XHRcdFx0XHRmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZW1vdmUnOlxuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIHRoaXMuX2ZpcnN0TW92ZSwgdHJ1ZSwgZmFsc2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0XHR0aGlzLl9maXJzdE1vdmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRpZiAoY2FsbGVkKVxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRyZXR1cm4gY2FsbGVkO1xuXHR9XG5cbn0pO1xuXG52YXIgSHR0cCA9IHtcblx0cmVxdWVzdDogZnVuY3Rpb24obWV0aG9kLCB1cmwsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHhociA9IG5ldyAod2luZG93LkFjdGl2ZVhPYmplY3QgfHwgWE1MSHR0cFJlcXVlc3QpKFxuXHRcdFx0XHRcdCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdHhoci5vcGVuKG1ldGhvZC50b1VwcGVyQ2FzZSgpLCB1cmwsIHRydWUpO1xuXHRcdGlmICgnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09IDAgfHwgc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgdXJsICsgJyAoRXJyb3IgJ1xuXHRcdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiB4aHIuc2VuZChudWxsKTtcblx0fVxufTtcblxudmFyIENhbnZhc1Byb3ZpZGVyID0ge1xuXHRjYW52YXNlczogW10sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKCBub0NhbnZhcyApIHtcblx0XHRcdHJldHVybiB7IGdldENvbnRleHQ6IGZ1bmN0aW9uKCkge30gfTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHR9XG59O1xuXG52YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHRpZiAoIG5vQ2FudmFzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBtaW4gPSBNYXRoLm1pbixcblx0XHRtYXggPSBNYXRoLm1heCxcblx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRzciwgc2csIHNiLCBzYSxcblx0XHRiciwgYmcsIGJiLCBiYSxcblx0XHRkciwgZGcsIGRiO1xuXG5cdGZ1bmN0aW9uIGdldEx1bShyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIDAuMjk4OSAqIHIgKyAwLjU4NyAqIGcgKyAwLjExNCAqIGI7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRMdW0ociwgZywgYiwgbCkge1xuXHRcdHZhciBkID0gbCAtIGdldEx1bShyLCBnLCBiKTtcblx0XHRkciA9IHIgKyBkO1xuXHRcdGRnID0gZyArIGQ7XG5cdFx0ZGIgPSBiICsgZDtcblx0XHR2YXIgbCA9IGdldEx1bShkciwgZGcsIGRiKSxcblx0XHRcdG1uID0gbWluKGRyLCBkZywgZGIpLFxuXHRcdFx0bXggPSBtYXgoZHIsIGRnLCBkYik7XG5cdFx0aWYgKG1uIDwgMCkge1xuXHRcdFx0dmFyIGxtbiA9IGwgLSBtbjtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbCAvIGxtbjtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbCAvIGxtbjtcblx0XHR9XG5cdFx0aWYgKG14ID4gMjU1KSB7XG5cdFx0XHR2YXIgbG4gPSAyNTUgLSBsLFxuXHRcdFx0XHRteGwgPSBteCAtIGw7XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRiID0gbCArIChkYiAtIGwpICogbG4gLyBteGw7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2F0KHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gbWF4KHIsIGcsIGIpIC0gbWluKHIsIGcsIGIpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0U2F0KHIsIGcsIGIsIHMpIHtcblx0XHR2YXIgY29sID0gW3IsIGcsIGJdLFxuXHRcdFx0bXggPSBtYXgociwgZywgYiksXG5cdFx0XHRtbiA9IG1pbihyLCBnLCBiKSxcblx0XHRcdG1kO1xuXHRcdG1uID0gbW4gPT09IHIgPyAwIDogbW4gPT09IGcgPyAxIDogMjtcblx0XHRteCA9IG14ID09PSByID8gMCA6IG14ID09PSBnID8gMSA6IDI7XG5cdFx0bWQgPSBtaW4obW4sIG14KSA9PT0gMCA/IG1heChtbiwgbXgpID09PSAxID8gMiA6IDEgOiAwO1xuXHRcdGlmIChjb2xbbXhdID4gY29sW21uXSkge1xuXHRcdFx0Y29sW21kXSA9IChjb2xbbWRdIC0gY29sW21uXSkgKiBzIC8gKGNvbFtteF0gLSBjb2xbbW5dKTtcblx0XHRcdGNvbFtteF0gPSBzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb2xbbWRdID0gY29sW214XSA9IDA7XG5cdFx0fVxuXHRcdGNvbFttbl0gPSAwO1xuXHRcdGRyID0gY29sWzBdO1xuXHRcdGRnID0gY29sWzFdO1xuXHRcdGRiID0gY29sWzJdO1xuXHR9XG5cblx0dmFyIG1vZGVzID0ge1xuXHRcdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKiBzciAvIDI1NTtcblx0XHRcdGRnID0gYmcgKiBzZyAvIDI1NTtcblx0XHRcdGRiID0gYmIgKiBzYiAvIDI1NTtcblx0XHR9LFxuXG5cdFx0c2NyZWVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAtIChiciAqIHNyIC8gMjU1KTtcblx0XHRcdGRnID0gYmcgKyBzZyAtIChiZyAqIHNnIC8gMjU1KTtcblx0XHRcdGRiID0gYmIgKyBzYiAtIChiYiAqIHNiIC8gMjU1KTtcblx0XHR9LFxuXG5cdFx0b3ZlcmxheTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgMTI4ID8gMiAqIGJyICogc3IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnIDwgMTI4ID8gMiAqIGJnICogc2cgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiIDwgMTI4ID8gMiAqIGJiICogc2IgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdzb2Z0LWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdCA9IHNyICogYnIgLyAyNTU7XG5cdFx0XHRkciA9IHQgKyBiciAqICgyNTUgLSAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNnICogYmcgLyAyNTU7XG5cdFx0XHRkZyA9IHQgKyBiZyAqICgyNTUgLSAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdFx0dCA9IHNiICogYmIgLyAyNTU7XG5cdFx0XHRkYiA9IHQgKyBiYiAqICgyNTUgLSAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NSAtIHQpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnaGFyZC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBzciA8IDEyOCA/IDIgKiBzciAqIGJyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzcikgKiAoMjU1IC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBzZyA8IDEyOCA/IDIgKiBzZyAqIGJnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzZykgKiAoMjU1IC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBzYiA8IDEyOCA/IDIgKiBzYiAqIGJiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBzYikgKiAoMjU1IC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnY29sb3ItZG9kZ2UnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDAgPyAwIDogc3IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJyIC8gKDI1NSAtIHNyKSk7XG5cdFx0XHRkZyA9IGJnID09PSAwID8gMCA6IHNnID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiZyAvICgyNTUgLSBzZykpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMCA/IDAgOiBzYiA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmIgLyAoMjU1IC0gc2IpKTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWJ1cm4nOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPT09IDI1NSA/IDI1NSA6IHNyID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYnIpICogMjU1IC8gc3IpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMjU1ID8gMjU1IDogc2cgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiZykgKiAyNTUgLyBzZyk7XG5cdFx0XHRkYiA9IGJiID09PSAyNTUgPyAyNTUgOiBzYiA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJiKSAqIDI1NSAvIHNiKTtcblx0XHR9LFxuXG5cdFx0ZGFya2VuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnIDwgc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA8IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0bGlnaHRlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID4gc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA+IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPiBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGRpZmZlcmVuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAtIHNyO1xuXHRcdFx0aWYgKGRyIDwgMClcblx0XHRcdFx0ZHIgPSAtZHI7XG5cdFx0XHRkZyA9IGJnIC0gc2c7XG5cdFx0XHRpZiAoZGcgPCAwKVxuXHRcdFx0XHRkZyA9IC1kZztcblx0XHRcdGRiID0gYmIgLSBzYjtcblx0XHRcdGlmIChkYiA8IDApXG5cdFx0XHRcdGRiID0gLWRiO1xuXHRcdH0sXG5cblx0XHRleGNsdXNpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyICogKDI1NSAtIGJyIC0gYnIpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyArIHNnICogKDI1NSAtIGJnIC0gYmcpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiArIHNiICogKDI1NSAtIGJiIC0gYmIpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRodWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KHNyLCBzZywgc2IsIGdldFNhdChiciwgYmcsIGJiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0c2F0dXJhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoYnIsIGJnLCBiYiwgZ2V0U2F0KHNyLCBzZywgc2IpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRsdW1pbm9zaXR5OiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShiciwgYmcsIGJiLCBnZXRMdW0oc3IsIHNnLCBzYikpO1xuXHRcdH0sXG5cblx0XHRjb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oc3IsIHNnLCBzYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWluKGJyICsgc3IsIDI1NSk7XG5cdFx0XHRkZyA9IG1pbihiZyArIHNnLCAyNTUpO1xuXHRcdFx0ZGIgPSBtaW4oYmIgKyBzYiwgMjU1KTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtYXgoYnIgLSBzciwgMCk7XG5cdFx0XHRkZyA9IG1heChiZyAtIHNnLCAwKTtcblx0XHRcdGRiID0gbWF4KGJiIC0gc2IsIDApO1xuXHRcdH0sXG5cblx0XHRhdmVyYWdlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gKGJyICsgc3IpIC8gMjtcblx0XHRcdGRnID0gKGJnICsgc2cpIC8gMjtcblx0XHRcdGRiID0gKGJiICsgc2IpIC8gMjtcblx0XHR9LFxuXG5cdFx0bmVnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAyNTUgLSBhYnMoMjU1IC0gc3IgLSBicik7XG5cdFx0XHRkZyA9IDI1NSAtIGFicygyNTUgLSBzZyAtIGJnKTtcblx0XHRcdGRiID0gMjU1IC0gYWJzKDI1NSAtIHNiIC0gYmIpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgbmF0aXZlTW9kZXMgPSB0aGlzLm5hdGl2ZU1vZGVzID0gQmFzZS5lYWNoKFtcblx0XHQnc291cmNlLW92ZXInLCAnc291cmNlLWluJywgJ3NvdXJjZS1vdXQnLCAnc291cmNlLWF0b3AnLFxuXHRcdCdkZXN0aW5hdGlvbi1vdmVyJywgJ2Rlc3RpbmF0aW9uLWluJywgJ2Rlc3RpbmF0aW9uLW91dCcsXG5cdFx0J2Rlc3RpbmF0aW9uLWF0b3AnLCAnbGlnaHRlcicsICdkYXJrZXInLCAnY29weScsICd4b3InXG5cdF0sIGZ1bmN0aW9uKG1vZGUpIHtcblx0XHR0aGlzW21vZGVdID0gdHJ1ZTtcblx0fSwge30pO1xuXG5cdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRCYXNlLmVhY2gobW9kZXMsIGZ1bmN0aW9uKGZ1bmMsIG1vZGUpIHtcblx0XHR2YXIgZGFya2VuID0gbW9kZSA9PT0gJ2RhcmtlbicsXG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dHJ5IHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnIzMwMCcgOiAnI2EwMCc7XG5cdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGlmIChjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID09PSBtb2RlKSB7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBkYXJrZW4gPyAnI2EwMCcgOiAnIzMwMCc7XG5cdFx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0b2sgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGFbMF0gIT09IGRhcmtlbiA/IDE3MCA6IDUxO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRuYXRpdmVNb2Rlc1ttb2RlXSA9IG9rO1xuXHR9KTtcblx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG1vZGUsIHNyY0NvbnRleHQsIGRzdENvbnRleHQsIGFscGhhLCBvZmZzZXQpIHtcblx0XHR2YXIgc3JjQ2FudmFzID0gc3JjQ29udGV4dC5jYW52YXMsXG5cdFx0XHRub3JtYWwgPSBtb2RlID09PSAnbm9ybWFsJztcblx0XHRpZiAobm9ybWFsIHx8IG5hdGl2ZU1vZGVzW21vZGVdKSB7XG5cdFx0XHRkc3RDb250ZXh0LnNhdmUoKTtcblx0XHRcdGRzdENvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKCFub3JtYWwpXG5cdFx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gbW9kZTtcblx0XHRcdGRzdENvbnRleHQuZHJhd0ltYWdlKHNyY0NhbnZhcywgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHRcdGRzdENvbnRleHQucmVzdG9yZSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHJvY2VzcyA9IG1vZGVzW21vZGVdO1xuXHRcdFx0aWYgKCFwcm9jZXNzKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgZHN0RGF0YSA9IGRzdENvbnRleHQuZ2V0SW1hZ2VEYXRhKG9mZnNldC54LCBvZmZzZXQueSxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLFxuXHRcdFx0XHRkc3QgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyA9IHNyY0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KS5kYXRhO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkc3QubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHRcdHNyID0gc3JjW2ldO1xuXHRcdFx0XHRiciA9IGRzdFtpXTtcblx0XHRcdFx0c2cgPSBzcmNbaSArIDFdO1xuXHRcdFx0XHRiZyA9IGRzdFtpICsgMV07XG5cdFx0XHRcdHNiID0gc3JjW2kgKyAyXTtcblx0XHRcdFx0YmIgPSBkc3RbaSArIDJdO1xuXHRcdFx0XHRzYSA9IHNyY1tpICsgM107XG5cdFx0XHRcdGJhID0gZHN0W2kgKyAzXTtcblx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHR2YXIgYTEgPSBzYSAqIGFscGhhIC8gMjU1LFxuXHRcdFx0XHRcdGEyID0gMSAtIGExO1xuXHRcdFx0XHRkc3RbaV0gPSBhMSAqIGRyICsgYTIgKiBicjtcblx0XHRcdFx0ZHN0W2kgKyAxXSA9IGExICogZGcgKyBhMiAqIGJnO1xuXHRcdFx0XHRkc3RbaSArIDJdID0gYTEgKiBkYiArIGEyICogYmI7XG5cdFx0XHRcdGRzdFtpICsgM10gPSBzYSAqIGFscGhhICsgYTIgKiBiYTtcblx0XHRcdH1cblx0XHRcdGRzdENvbnRleHQucHV0SW1hZ2VEYXRhKGRzdERhdGEsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFNWR1N0eWxlcyA9IEJhc2UuZWFjaCh7XG5cdGZpbGxDb2xvcjogWydmaWxsJywgJ2NvbG9yJ10sXG5cdHN0cm9rZUNvbG9yOiBbJ3N0cm9rZScsICdjb2xvciddLFxuXHRzdHJva2VXaWR0aDogWydzdHJva2Utd2lkdGgnLCAnbnVtYmVyJ10sXG5cdHN0cm9rZUNhcDogWydzdHJva2UtbGluZWNhcCcsICdzdHJpbmcnXSxcblx0c3Ryb2tlSm9pbjogWydzdHJva2UtbGluZWpvaW4nLCAnc3RyaW5nJ10sXG5cdHN0cm9rZVNjYWxpbmc6IFsndmVjdG9yLWVmZmVjdCcsICdsb29rdXAnLCB7XG5cdFx0dHJ1ZTogJ25vbmUnLFxuXHRcdGZhbHNlOiAnbm9uLXNjYWxpbmctc3Ryb2tlJ1xuXHR9LCBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0JiYgKGl0ZW0gaW5zdGFuY2VvZiBQYXRoSXRlbVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBTaGFwZVxuXHRcdFx0XHRcdHx8IGl0ZW0gaW5zdGFuY2VvZiBUZXh0SXRlbSk7XG5cdH1dLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0cmluZyddXG59LCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0bG9va3VwID0gZW50cnlbMl07XG5cdHRoaXNba2V5XSA9IHtcblx0XHR0eXBlOiBlbnRyeVsxXSxcblx0XHRwcm9wZXJ0eToga2V5LFxuXHRcdGF0dHJpYnV0ZTogZW50cnlbMF0sXG5cdFx0dG9TVkc6IGxvb2t1cCxcblx0XHRmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHRoaXNbdmFsdWVdID0gbmFtZTtcblx0XHR9LCB7fSksXG5cdFx0ZXhwb3J0RmlsdGVyOiBlbnRyeVszXSxcblx0XHRnZXQ6ICdnZXQnICsgcGFydCxcblx0XHRzZXQ6ICdzZXQnICsgcGFydFxuXHR9O1xufSwge30pO1xuXG52YXIgU1ZHTmFtZXNwYWNlcyA9IHtcblx0aHJlZjogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnXG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBmb3JtYXR0ZXI7XG5cblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycykge1xuXHRcdGZvciAodmFyIGtleSBpbiBhdHRycykge1xuXHRcdFx0dmFyIHZhbCA9IGF0dHJzW2tleV0sXG5cdFx0XHRcdG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNba2V5XTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcblx0XHRcdFx0dmFsID0gZm9ybWF0dGVyLm51bWJlcih2YWwpO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwga2V5LCB2YWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBhdHRycykge1xuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKFxuXHRcdFx0ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIHRhZyksIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRyYW5zZm9ybShtYXRyaXgsIGNvb3JkaW5hdGVzLCBjZW50ZXIpIHtcblx0XHR2YXIgYXR0cnMgPSBuZXcgQmFzZSgpLFxuXHRcdFx0dHJhbnMgPSBtYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRpZiAoY29vcmRpbmF0ZXMpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zaGlmdGxlc3MoKTtcblx0XHRcdHZhciBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG5cdFx0XHR0cmFucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCAmJiAhZGVjb21wb3NlZC5zaGVhcmluZykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdFx0XHRhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG5cdFx0XHRcdFx0c2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0XHRcdGlmICh0cmFucyAmJiAhdHJhbnMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcblx0XHRcdFx0aWYgKCFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnggLSAxKVxuXHRcdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueSAtIDEpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3NjYWxlKCcgKyBmb3JtYXR0ZXIucG9pbnQoc2NhbGUpICsnKScpO1xuXHRcdFx0XHRpZiAoYW5nbGUpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgncm90YXRlKCcgKyBmb3JtYXR0ZXIubnVtYmVyKGFuZ2xlKSArICcpJyk7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9ICdtYXRyaXgoJyArIG1hdHJpeC5nZXRWYWx1ZXMoKS5qb2luKCcsJykgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyb3VwKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KSxcblx0XHRcdGNoaWxkcmVuID0gaXRlbS5fY2hpbGRyZW47XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCdnJywgYXR0cnMpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBleHBvcnRTVkcoY2hpbGQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKGNoaWxkTm9kZSkge1xuXHRcdFx0XHRpZiAoY2hpbGQuaXNDbGlwTWFzaygpKSB7XG5cdFx0XHRcdFx0dmFyIGNsaXAgPSBjcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpO1xuXHRcdFx0XHRcdGNsaXAuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0XHRzZXREZWZpbml0aW9uKGNoaWxkLCBjbGlwLCAnY2xpcCcpO1xuXHRcdFx0XHRcdHNldEF0dHJpYnV0ZXMobm9kZSwge1xuXHRcdFx0XHRcdFx0J2NsaXAtcGF0aCc6ICd1cmwoIycgKyBjbGlwLmlkICsgJyknXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UmFzdGVyKGl0ZW0pIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHNpemUgPSBpdGVtLmdldFNpemUoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gaXRlbS50b0RhdGFVUkwoKTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5tYXRjaFNoYXBlcykge1xuXHRcdFx0dmFyIHNoYXBlID0gaXRlbS50b1NoYXBlKGZhbHNlKTtcblx0XHRcdGlmIChzaGFwZSlcblx0XHRcdFx0cmV0dXJuIGV4cG9ydFNoYXBlKHNoYXBlLCBvcHRpb25zKTtcblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gaXRlbS5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKGl0ZW0uaXNQb2x5Z29uKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcblx0XHRcdFx0YXR0cnMucG9pbnRzID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9ICdsaW5lJztcblx0XHRcdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF0uX3BvaW50LFxuXHRcdFx0XHRcdGxhc3QgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5fcG9pbnQ7XG5cdFx0XHRcdGF0dHJzLnNldCh7XG5cdFx0XHRcdFx0eDE6IGZpcnN0LngsXG5cdFx0XHRcdFx0eTE6IGZpcnN0LnksXG5cdFx0XHRcdFx0eDI6IGxhc3QueCxcblx0XHRcdFx0XHR5MjogbGFzdC55XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0eXBlID0gJ3BhdGgnO1xuXHRcdFx0YXR0cnMuZCA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG5cdFx0dmFyIHR5cGUgPSBpdGVtLl90eXBlLFxuXHRcdFx0cmFkaXVzID0gaXRlbS5fcmFkaXVzLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlLCB0eXBlICE9PSAncmVjdGFuZ2xlJyk7XG5cdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHR0eXBlID0gJ3JlY3QnO1xuXHRcdFx0dmFyIHNpemUgPSBpdGVtLl9zaXplLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0YXR0cnMueCAtPSB3aWR0aCAvIDI7XG5cdFx0XHRhdHRycy55IC09IGhlaWdodCAvIDI7XG5cdFx0XHRhdHRycy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0YXR0cnMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdFx0aWYgKHJhZGl1cy5pc1plcm8oKSlcblx0XHRcdFx0cmFkaXVzID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKHJhZGl1cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRcdGF0dHJzLnIgPSByYWRpdXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy5yeCA9IHJhZGl1cy53aWR0aDtcblx0XHRcdFx0YXR0cnMucnkgPSByYWRpdXMuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRDb21wb3VuZFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0aWYgKGRhdGEpXG5cdFx0XHRhdHRycy5kID0gZGF0YTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgncGF0aCcsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBsYWNlZFN5bWJvbChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzeW1ib2wgPSBpdGVtLmdldFN5bWJvbCgpLFxuXHRcdFx0c3ltYm9sTm9kZSA9IGdldERlZmluaXRpb24oc3ltYm9sLCAnc3ltYm9sJyksXG5cdFx0XHRkZWZpbml0aW9uID0gc3ltYm9sLmdldERlZmluaXRpb24oKSxcblx0XHRcdGJvdW5kcyA9IGRlZmluaXRpb24uZ2V0Qm91bmRzKCk7XG5cdFx0aWYgKCFzeW1ib2xOb2RlKSB7XG5cdFx0XHRzeW1ib2xOb2RlID0gY3JlYXRlRWxlbWVudCgnc3ltYm9sJywge1xuXHRcdFx0XHR2aWV3Qm94OiBmb3JtYXR0ZXIucmVjdGFuZ2xlKGJvdW5kcylcblx0XHRcdH0pO1xuXHRcdFx0c3ltYm9sTm9kZS5hcHBlbmRDaGlsZChleHBvcnRTVkcoZGVmaW5pdGlvbiwgb3B0aW9ucykpO1xuXHRcdFx0c2V0RGVmaW5pdGlvbihzeW1ib2wsIHN5bWJvbE5vZGUsICdzeW1ib2wnKTtcblx0XHR9XG5cdFx0YXR0cnMuaHJlZiA9ICcjJyArIHN5bWJvbE5vZGUuaWQ7XG5cdFx0YXR0cnMueCArPSBib3VuZHMueDtcblx0XHRhdHRycy55ICs9IGJvdW5kcy55O1xuXHRcdGF0dHJzLndpZHRoID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMud2lkdGgpO1xuXHRcdGF0dHJzLmhlaWdodCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLmhlaWdodCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3VzZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyYWRpZW50KGNvbG9yKSB7XG5cdFx0dmFyIGdyYWRpZW50Tm9kZSA9IGdldERlZmluaXRpb24oY29sb3IsICdjb2xvcicpO1xuXHRcdGlmICghZ3JhZGllbnROb2RlKSB7XG5cdFx0XHR2YXIgZ3JhZGllbnQgPSBjb2xvci5nZXRHcmFkaWVudCgpLFxuXHRcdFx0XHRyYWRpYWwgPSBncmFkaWVudC5fcmFkaWFsLFxuXHRcdFx0XHRvcmlnaW4gPSBjb2xvci5nZXRPcmlnaW4oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb2xvci5nZXREZXN0aW5hdGlvbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRhdHRycztcblx0XHRcdGlmIChyYWRpYWwpIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0Y3g6IG9yaWdpbi54LFxuXHRcdFx0XHRcdGN5OiBvcmlnaW4ueSxcblx0XHRcdFx0XHRyOiBvcmlnaW4uZ2V0RGlzdGFuY2UoZGVzdGluYXRpb24pXG5cdFx0XHRcdH07XG5cdFx0XHRcdHZhciBoaWdobGlnaHQgPSBjb2xvci5nZXRIaWdobGlnaHQoKTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGhpZ2hsaWdodC50cmFuc2Zvcm0oKTtcblx0XHRcdFx0XHRhdHRycy5meCA9IGhpZ2hsaWdodC54O1xuXHRcdFx0XHRcdGF0dHJzLmZ5ID0gaGlnaGxpZ2h0Lnk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdHgxOiBvcmlnaW4ueCxcblx0XHRcdFx0XHR5MTogb3JpZ2luLnksXG5cdFx0XHRcdFx0eDI6IGRlc3RpbmF0aW9uLngsXG5cdFx0XHRcdFx0eTI6IGRlc3RpbmF0aW9uLnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGF0dHJzLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuXHRcdFx0Z3JhZGllbnROb2RlID0gY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHQocmFkaWFsID8gJ3JhZGlhbCcgOiAnbGluZWFyJykgKyAnR3JhZGllbnQnLCBhdHRycyk7XG5cdFx0XHR2YXIgc3RvcHMgPSBncmFkaWVudC5fc3RvcHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldLFxuXHRcdFx0XHRcdHN0b3BDb2xvciA9IHN0b3AuX2NvbG9yLFxuXHRcdFx0XHRcdGFscGhhID0gc3RvcENvbG9yLmdldEFscGhhKCk7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdG9mZnNldDogc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdCdzdG9wLWNvbG9yJzogc3RvcENvbG9yLnRvQ1NTKHRydWUpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0YXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdGdyYWRpZW50Tm9kZS5hcHBlbmRDaGlsZChjcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpKTtcblx0XHRcdH1cblx0XHRcdHNldERlZmluaXRpb24oY29sb3IsIGdyYWRpZW50Tm9kZSwgJ2NvbG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiAndXJsKCMnICsgZ3JhZGllbnROb2RlLmlkICsgJyknO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0VGV4dChpdGVtKSB7XG5cdFx0dmFyIG5vZGUgPSBjcmVhdGVFbGVtZW50KCd0ZXh0JywgZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSkpO1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSBpdGVtLl9jb250ZW50O1xuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0dmFyIGV4cG9ydGVycyA9IHtcblx0XHRHcm91cDogZXhwb3J0R3JvdXAsXG5cdFx0TGF5ZXI6IGV4cG9ydEdyb3VwLFxuXHRcdFJhc3RlcjogZXhwb3J0UmFzdGVyLFxuXHRcdFBhdGg6IGV4cG9ydFBhdGgsXG5cdFx0U2hhcGU6IGV4cG9ydFNoYXBlLFxuXHRcdENvbXBvdW5kUGF0aDogZXhwb3J0Q29tcG91bmRQYXRoLFxuXHRcdFBsYWNlZFN5bWJvbDogZXhwb3J0UGxhY2VkU3ltYm9sLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIGF0dHJzID0ge30sXG5cdFx0XHRwYXJlbnQgPSAhaXNSb290ICYmIGl0ZW0uZ2V0UGFyZW50KCk7XG5cblx0XHRpZiAoaXRlbS5fbmFtZSAhPSBudWxsKVxuXHRcdFx0YXR0cnMuaWQgPSBpdGVtLl9uYW1lO1xuXG5cdFx0QmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHRcdHZhciBnZXQgPSBlbnRyeS5nZXQsXG5cdFx0XHRcdHR5cGUgPSBlbnRyeS50eXBlLFxuXHRcdFx0XHR2YWx1ZSA9IGl0ZW1bZ2V0XSgpO1xuXHRcdFx0aWYgKGVudHJ5LmV4cG9ydEZpbHRlclxuXHRcdFx0XHRcdD8gZW50cnkuZXhwb3J0RmlsdGVyKGl0ZW0sIHZhbHVlKVxuXHRcdFx0XHRcdDogIXBhcmVudCB8fCAhQmFzZS5lcXVhbHMocGFyZW50W2dldF0oKSwgdmFsdWUpKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgYWxwaGEgPSB2YWx1ZS5nZXRBbHBoYSgpO1xuXHRcdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGUgKyAnLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdFx0PyAnbm9uZSdcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGZvcm1hdHRlci5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmpvaW4oJywnKVxuXHRcdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHRcdD8gZW50cnkudG9TVkdbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG5cdFx0XHRkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuXHRcdGlmICghaXRlbS5fdmlzaWJsZSlcblx0XHRcdGF0dHJzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuXHRcdHJldHVybiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucztcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbihpdGVtLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGRlZmluaXRpb25zID0geyBpZHM6IHt9LCBzdmdzOiB7fSB9O1xuXHRcdHJldHVybiBpdGVtICYmIGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldERlZmluaXRpb24oaXRlbSwgbm9kZSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRnZXREZWZpbml0aW9uKCk7XG5cdFx0dmFyIGlkID0gZGVmaW5pdGlvbnMuaWRzW3R5cGVdID0gKGRlZmluaXRpb25zLmlkc1t0eXBlXSB8fCAwKSArIDE7XG5cdFx0bm9kZS5pZCA9IHR5cGUgKyAnLScgKyBpZDtcblx0XHRkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF0gPSBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucykge1xuXHRcdHZhciBzdmcgPSBub2RlLFxuXHRcdFx0ZGVmcyA9IG51bGw7XG5cdFx0aWYgKGRlZmluaXRpb25zKSB7XG5cdFx0XHRzdmcgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdmcnICYmIG5vZGU7XG5cdFx0XHRmb3IgKHZhciBpIGluIGRlZmluaXRpb25zLnN2Z3MpIHtcblx0XHRcdFx0aWYgKCFkZWZzKSB7XG5cdFx0XHRcdFx0aWYgKCFzdmcpIHtcblx0XHRcdFx0XHRcdHN2ZyA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuXHRcdFx0XHRcdFx0c3ZnLmFwcGVuZENoaWxkKG5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZWZzID0gc3ZnLmluc2VydEJlZm9yZShjcmVhdGVFbGVtZW50KCdkZWZzJyksXG5cdFx0XHRcdFx0XHRcdHN2Zy5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZzLmFwcGVuZENoaWxkKGRlZmluaXRpb25zLnN2Z3NbaV0pO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9ucy5hc1N0cmluZ1xuXHRcdFx0XHQ/IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKVxuXHRcdFx0XHQ6IHN2Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNWRyhpdGVtLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgZXhwb3J0ZXIgPSBleHBvcnRlcnNbaXRlbS5fY2xhc3NdLFxuXHRcdFx0bm9kZSA9IGV4cG9ydGVyICYmIGV4cG9ydGVyKGl0ZW0sIG9wdGlvbnMpO1xuXHRcdGlmIChub2RlKSB7XG5cdFx0XHR2YXIgb25FeHBvcnQgPSBvcHRpb25zLm9uRXhwb3J0O1xuXHRcdFx0aWYgKG9uRXhwb3J0KVxuXHRcdFx0XHRub2RlID0gb25FeHBvcnQoaXRlbSwgbm9kZSwgb3B0aW9ucykgfHwgbm9kZTtcblx0XHRcdHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5fZGF0YSk7XG5cdFx0XHRpZiAoZGF0YSAmJiBkYXRhICAhPT0gJ3t9Jylcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScsIGRhdGEpO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZSAmJiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhleHBvcnRTVkcodGhpcywgb3B0aW9ucywgdHJ1ZSksIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsXG5cdFx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdFx0c2l6ZSA9IHZpZXcuZ2V0Vmlld1NpemUoKSxcblx0XHRcdFx0bm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N2ZycsIHtcblx0XHRcdFx0XHR4OiAwLFxuXHRcdFx0XHRcdHk6IDAsXG5cdFx0XHRcdFx0d2lkdGg6IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBzaXplLmhlaWdodCxcblx0XHRcdFx0XHR2ZXJzaW9uOiAnMS4xJyxcblx0XHRcdFx0XHR4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0XHQneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcblx0XHRcdFx0fSksXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUsXG5cdFx0XHRcdG1hdHJpeCA9IHZpZXcuX21hdHJpeDtcblx0XHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdFx0cGFyZW50ID0gbm9kZS5hcHBlbmRDaGlsZChcblx0XHRcdFx0XHRcdGNyZWF0ZUVsZW1lbnQoJ2cnLCBnZXRUcmFuc2Zvcm0obWF0cml4KSkpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGxheWVyc1tpXSwgb3B0aW9ucywgdHJ1ZSkpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUobm9kZSwgbmFtZSwgaXNTdHJpbmcsIGFsbG93TnVsbCkge1xuXHRcdHZhciBuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBuYW1lc3BhY2Vcblx0XHRcdFx0PyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSlcblx0XHRcdFx0OiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblx0XHRpZiAodmFsdWUgPT09ICdudWxsJylcblx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHQ/IGFsbG93TnVsbFxuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHRcdD8gJydcblx0XHRcdFx0XHRcdDogMFxuXHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0PyB2YWx1ZVxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRQb2ludChub2RlLCB4LCB5LCBhbGxvd051bGwpIHtcblx0XHR4ID0gZ2V0VmFsdWUobm9kZSwgeCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0eSA9IGdldFZhbHVlKG5vZGUsIHksIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHggPT0gbnVsbCB8fCB5ID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNpemUobm9kZSwgdywgaCwgYWxsb3dOdWxsKSB7XG5cdFx0dyA9IGdldFZhbHVlKG5vZGUsIHcsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdGggPSBnZXRWYWx1ZShub2RlLCBoLCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh3ID09IG51bGwgfHwgaCA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgU2l6ZSh3LCBoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSwgdHlwZSwgbG9va3VwKSB7XG5cdFx0cmV0dXJuIHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHQ/IHBhcnNlRmxvYXQodmFsdWUpXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHQ/IHZhbHVlID8gdmFsdWUuc3BsaXQoL1tcXHMsXSsvZykubWFwKHBhcnNlRmxvYXQpIDogW11cblx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IGdldERlZmluaXRpb24odmFsdWUpIHx8IHZhbHVlXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHQ/IGxvb2t1cFt2YWx1ZV1cblx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JvdXAobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0aXNDbGlwID0gdHlwZSA9PT0gJ2NsaXBwYXRoJyxcblx0XHRcdGl0ZW0gPSBuZXcgR3JvdXAoKSxcblx0XHRcdHByb2plY3QgPSBpdGVtLl9wcm9qZWN0LFxuXHRcdFx0Y3VycmVudFN0eWxlID0gcHJvamVjdC5fY3VycmVudFN0eWxlLFxuXHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRpZiAoIWlzQ2xpcCkge1xuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gaXRlbS5fc3R5bGUuY2xvbmUoKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2Rlc1tpXSxcblx0XHRcdFx0Y2hpbGQ7XG5cdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxXG5cdFx0XHRcdFx0JiYgKGNoaWxkID0gaW1wb3J0U1ZHKGNoaWxkTm9kZSwgb3B0aW9ucywgZmFsc2UpKVxuXHRcdFx0XHRcdCYmICEoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2wpKVxuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHR9XG5cdFx0aXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0aWYgKGlzQ2xpcClcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbS5yZWR1Y2UoKSwgbm9kZSwgaXNSb290KTtcblx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGU7XG5cdFx0aWYgKGlzQ2xpcCB8fCB0eXBlID09PSAnZGVmcycpIHtcblx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgY29vcmRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLm1hdGNoKFxuXHRcdFx0XHRcdC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaSArIDFdKSkpO1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcblx0XHRpZiAodHlwZSA9PT0gJ3BvbHlnb24nKVxuXHRcdFx0cGF0aC5jbG9zZVBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuXHRcdHZhciBkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSxcblx0XHRcdHBhcmFtID0geyBwYXRoRGF0YTogZGF0YSB9O1xuXHRcdHJldHVybiAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDEgfHwgL3pcXFMrL2kudGVzdChkYXRhKVxuXHRcdFx0XHQ/IG5ldyBDb21wb3VuZFBhdGgocGFyYW0pXG5cdFx0XHRcdDogbmV3IFBhdGgocGFyYW0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuXHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRpc1JhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG5cdFx0XHRncmFkaWVudDtcblx0XHRpZiAoaWQpIHtcblx0XHRcdGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3RvcHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0c3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdFx0Z3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIGlzUmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodDtcblx0XHRpZiAoaXNSYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKGdldFZhbHVlKG5vZGUsICdyJyksIDApO1xuXHRcdFx0aGlnaGxpZ2h0ID0gZ2V0UG9pbnQobm9kZSwgJ2Z4JywgJ2Z5JywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInKTtcblx0XHR9XG5cdFx0YXBwbHlBdHRyaWJ1dGVzKFxuXHRcdFx0bmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpbXBvcnRlcnMgPSB7XG5cdFx0JyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuXHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRub2RlLmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZzogaW1wb3J0R3JvdXAsXG5cdFx0c3ZnOiBpbXBvcnRHcm91cCxcblx0XHRjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG5cdFx0cG9seWdvbjogaW1wb3J0UG9seSxcblx0XHRwb2x5bGluZTogaW1wb3J0UG9seSxcblx0XHRwYXRoOiBpbXBvcnRQYXRoLFxuXHRcdGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblx0XHRyYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cblx0XHRpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuXHRcdFx0cmFzdGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneCcsICd5JykuYWRkKHNpemUuZGl2aWRlKDIpKSk7XG5cdFx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByYXN0ZXI7XG5cdFx0fSxcblxuXHRcdHN5bWJvbDogZnVuY3Rpb24obm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN5bWJvbChpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpO1xuXHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0XHQ/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xcblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpLFxuXHRcdFx0XHRyYWRpdXMgPSBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpO1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShwb2ludCwgc2l6ZSksIHJhZGl1cyk7XG5cdFx0fSxcblxuXHRcdGxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgUGF0aC5MaW5lKGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUsICd4JywgJ3knKVxuXHRcdFx0XHRcdC5hZGQoZ2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUpIHtcblx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHR2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0bWF0cml4LmNvbmNhdGVuYXRlKFxuXHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIgY29sb3IgPSBpdGVtW25hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcidcblx0XHRcdFx0OiAnZ2V0U3Ryb2tlQ29sb3InXSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0aWYgKGVudHJ5LnR5cGUgPT09ICdjb2xvcicgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRpZiAoY29sb3IpXG5cdFx0XHRcdFx0Y29sb3IudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdGl0ZW0uZ2V0UG9zaXRpb24odHJ1ZSkubmVnYXRlKCkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0ZGlzcGxheTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSAhPT0gbnVsbCk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLWNvbG9yJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLnNldENvbG9yKVxuXHRcdFx0XHRpdGVtLnNldENvbG9yKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J3N0b3Atb3BhY2l0eSc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5fY29sb3IpXG5cdFx0XHRcdGl0ZW0uX2NvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIHBlcmNlbnRhZ2UgPSB2YWx1ZS5tYXRjaCgvKC4qKSUkLyk7XG5cdFx0XHRpdGVtLnNldFJhbXBQb2ludChwZXJjZW50YWdlXG5cdFx0XHRcdFx0PyBwZXJjZW50YWdlWzFdIC8gMTAwXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdHZpZXdCb3g6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpIHtcblx0XHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZShjb252ZXJ0VmFsdWUodmFsdWUsICdhcnJheScpKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcsIHRydWUpO1xuXHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSBzaXplID8gcmVjdC5nZXRTaXplKCkuZGl2aWRlKHNpemUpIDogMSxcblx0XHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKHJlY3QuZ2V0UG9pbnQoKSkuc2NhbGUoc2NhbGUpO1xuXHRcdFx0XHRpdGVtLnRyYW5zZm9ybShtYXRyaXguaW52ZXJ0ZWQoKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcblx0XHRcdFx0aWYgKHNpemUpXG5cdFx0XHRcdFx0cmVjdC5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2xpcCA9IGdldEF0dHJpYnV0ZShub2RlLCAnb3ZlcmZsb3cnLCBzdHlsZXMpICE9ICd2aXNpYmxlJyxcblx0XHRcdFx0XHRncm91cCA9IGl0ZW0uX2RlZmluaXRpb247XG5cdFx0XHRcdGlmIChjbGlwICYmICFyZWN0LmNvbnRhaW5zKGdyb3VwLmdldEJvdW5kcygpKSkge1xuXHRcdFx0XHRcdGNsaXAgPSBuZXcgU2hhcGUuUmVjdGFuZ2xlKHJlY3QpLnRyYW5zZm9ybShncm91cC5fbWF0cml4KTtcblx0XHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRcdGdyb3VwLmFkZENoaWxkKGNsaXApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKSB7XG5cdFx0dmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IGF0dHIgJiYgYXR0ci52YWx1ZTtcblx0XHRpZiAoIXZhbHVlKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBCYXNlLmNhbWVsaXplKG5hbWUpO1xuXHRcdFx0dmFsdWUgPSBub2RlLnN0eWxlW3N0eWxlXTtcblx0XHRcdGlmICghdmFsdWUgJiYgc3R5bGVzLm5vZGVbc3R5bGVdICE9PSBzdHlsZXMucGFyZW50W3N0eWxlXSlcblx0XHRcdFx0dmFsdWUgPSBzdHlsZXMubm9kZVtzdHlsZV07XG5cdFx0fVxuXHRcdHJldHVybiAhdmFsdWVcblx0XHRcdFx0PyB1bmRlZmluZWRcblx0XHRcdFx0OiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgc3R5bGVzID0ge1xuXHRcdFx0bm9kZTogRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZSkgfHwge30sXG5cdFx0XHRwYXJlbnQ6ICFpc1Jvb3QgJiYgRG9tRWxlbWVudC5nZXRTdHlsZXMobm9kZS5wYXJlbnROb2RlKSB8fCB7fVxuXHRcdH07XG5cdFx0QmFzZS5lYWNoKGF0dHJpYnV0ZXMsIGZ1bmN0aW9uKGFwcGx5LCBuYW1lKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBnZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgc3R5bGVzKTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtID0gQmFzZS5waWNrKGFwcGx5KGl0ZW0sIHZhbHVlLCBuYW1lLCBub2RlLCBzdHlsZXMpLCBpdGVtKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdHZhciBkZWZpbml0aW9ucyA9IHt9O1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKHZhbHVlKSB7XG5cdFx0dmFyIG1hdGNoID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL1xcKCg/OiN8KShbXiknXSspLyk7XG5cdFx0cmV0dXJuIG1hdGNoICYmIGRlZmluaXRpb25zW21hdGNoWzFdXTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFNWRyhzb3VyY2UsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdGlmICghc291cmNlKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0b3B0aW9ucyA9IHsgb25Mb2FkOiBvcHRpb25zIH07XG5cdFx0fVxuXG5cdFx0dmFyIG5vZGUgPSBzb3VyY2UsXG5cdFx0XHRzY29wZSA9IHBhcGVyO1xuXG5cdFx0ZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2soc3ZnKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoc3ZnLCBvcHRpb25zLCBpc1Jvb3QpLFxuXHRcdFx0XHRvbkxvYWQgPSBvcHRpb25zLm9uTG9hZCxcblx0XHRcdFx0dmlldyA9IHNjb3BlLnByb2plY3QgJiYgc2NvcGUuZ2V0VmlldygpO1xuXHRcdFx0aWYgKG9uTG9hZClcblx0XHRcdFx0b25Mb2FkLmNhbGwodGhpcywgaXRlbSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAhL14uKjwvLnRlc3Qoc291cmNlKSkge1xuXHRcdFx0XHRub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc291cmNlKTtcblx0XHRcdFx0aWYgKG5vZGUpIHtcblx0XHRcdFx0XHRzb3VyY2UgPSBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBIdHRwLnJlcXVlc3QoJ2dldCcsIHNvdXJjZSwgb25Mb2FkQ2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyAmJiBzb3VyY2UgaW5zdGFuY2VvZiBGaWxlKSB7XG5cdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0b25Mb2FkQ2FsbGJhY2socmVhZGVyLnJlc3VsdCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiByZWFkZXIucmVhZEFzVGV4dChzb3VyY2UpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJylcblx0XHRcdG5vZGUgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHNvdXJjZSwgJ2ltYWdlL3N2Zyt4bWwnKTtcblx0XHRpZiAoIW5vZGUubm9kZU5hbWUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFNWRyBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuXHRcdHZhciB0eXBlID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0aW1wb3J0ZXIgPSBpbXBvcnRlcnNbdHlwZV0sXG5cdFx0XHRpdGVtLFxuXHRcdFx0ZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnKSxcblx0XHRcdHNldHRpbmdzID0gc2NvcGUuc2V0dGluZ3MsXG5cdFx0XHRhcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0aXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkgfHwgbnVsbDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4O1xuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRpZiAodHlwZSAhPT0gJyNkb2N1bWVudCcgJiYgIShpdGVtIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHR2YXIgb25JbXBvcnQgPSBvcHRpb25zLm9uSW1wb3J0O1xuXHRcdFx0aWYgKG9uSW1wb3J0KVxuXHRcdFx0XHRpdGVtID0gb25JbXBvcnQobm9kZSwgaXRlbSwgb3B0aW9ucykgfHwgaXRlbTtcblx0XHRcdGlmIChvcHRpb25zLmV4cGFuZFNoYXBlcyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0aXRlbSA9IGl0ZW0udG9QYXRoKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YSlcblx0XHRcdFx0aXRlbS5fZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdGRlZmluaXRpb25zID0ge307XG5cdFx0XHRpZiAoYXBwbHlNYXRyaXggJiYgaXRlbSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWwsXG5cdEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcbn1cblxucmV0dXJuIHBhcGVyO1xufTtcblxufSx7fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgcGFwZXIgPSBfZGVyZXFfKCcuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzJyk7XG5cbmZ1bmN0aW9uIENvbGxlY3Rpb24oIGFyZ3MgKSB7XG5cdC8vIGFscmVhZHkgYSBDb2xsZWN0aW9uPyBKb2IncyBkb25lXG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmdzIGluc3RhbmNlb2YgQ29sbGVjdGlvbiApIHtcblx0XHRyZXR1cm4gYXJncztcblxuXHR9IGVsc2UgaWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSB8fCAhQXJyYXkuaXNBcnJheSggYXJncyApICkge1xuXHRcdGFyZ3MgPSBbXS5zbGljZS5jYWxsKCBhcmd1bWVudHMsIDAgKTtcblx0fVxuXG5cdHRoaXMubGVuZ3RoID0gMDtcblxuXHRhcmdzLmZvckVhY2goZnVuY3Rpb24oIGFyZyApIHtcblx0XHQvLyB1bndyYXAgYW55IGNvbGxlY3Rpb25cblx0XHRpZiAoIGFyZyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IC0xOyArK2kgPCBhcmcubGVuZ3RoOyApIHtcblx0XHRcdFx0dGhpc1t0aGlzLmxlbmd0aCsrXSA9IGFyZ1tpXTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW3RoaXMubGVuZ3RoKytdID0gYXJnO1xuXHRcdH1cblxuXHR9LCB0aGlzKTtcblxuXHRyZXR1cm4gdGhpcztcbn1cblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNiLCBzY29wZSkge1xuXHRmb3IgKCB2YXIgaSA9IC0xOyArK2kgPCB0aGlzLmxlbmd0aDsgKSB7XG5cdFx0Y2IuY2FsbChzY29wZSB8fCB0aGlzW2ldLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuQ29sbGVjdGlvbi5wcm90b3R5cGUucHJvcCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuXHR2YXIgaTtcblxuXHQvLyBvYmplY3Qgc2V0dGVyXG5cdGlmICggdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnICkge1xuXHRcdGZvciAoIGkgPSAtMTsgKytpIDwgdGhpcy5sZW5ndGg7ICkge1xuXHRcdFx0dGhpc1tpXS5zZXQoIG5hbWUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8vIGdldHRlclxuXHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzWzBdW25hbWVdO1xuXHR9XG5cblx0Ly8gc2ltcGxlIHNldHRlclxuXHRmb3IgKCBpID0gLTE7ICsraSA8IHRoaXMubGVuZ3RoOyApIHtcblx0XHR0aGlzW2ldW25hbWVdID0gdmFsO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoIGNvbnN0cnVjdG9yLCBwcm90b3R5cGUsIHVzZUNvbnN0cnVjdGVkICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gd3JhcHBlcigpIHtcblx0XHR2YXIgYyxcblx0XHRcdHRtcCxcblx0XHRcdGFyciA9IFtdO1xuXG5cdFx0Ly8gY29uc3RydWN0b3IgdXNlZCB3aXRoIG5ld1xuXHRcdGlmICggdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgKSB7XG5cdFx0XHQvLyBwcm94eSB0byBwYXBlciBuYXRpdmUgY29uc3RydWN0b3Jcblx0XHRcdGMgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cdFx0XHR0bXAgPSBjb25zdHJ1Y3Rvci5hcHBseShjLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIHVzZUNvbnN0cnVjdGVkID9cblx0XHRcdFx0dG1wOlxuXHRcdFx0XHRjO1xuXG5cdFx0Ly8gd2l0aG91dCBuZXcsIGJ1aWxkIGEgY29sbGVjdGlvblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGFyZ3VtZW50c1swXSApICkge1xuXHRcdFx0XHRhcmd1bWVudHNbMF0uZm9yRWFjaChmdW5jdGlvbihwYXJhbXMsIGkpIHtcblx0XHRcdFx0XHRhcnIucHVzaCggT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpICk7XG5cdFx0XHRcdFx0YyA9IGNvbnN0cnVjdG9yLmNhbGwoIGFycltpXSwgcGFyYW1zICk7XG5cdFx0XHRcdFx0aWYgKCB1c2VDb25zdHJ1Y3RlZCApIHtcblx0XHRcdFx0XHRcdGFycltpXSA9IGM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyLnB1c2goIE9iamVjdC5jcmVhdGUocHJvdG90eXBlKSApO1xuXHRcdFx0XHRjID0gY29uc3RydWN0b3IuYXBwbHkoIGFyclswXSwgYXJndW1lbnRzICk7XG5cdFx0XHRcdGlmICggdXNlQ29uc3RydWN0ZWQgKSB7XG5cdFx0XHRcdFx0YXJyWzBdID0gYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IENvbGxlY3Rpb24oIGFyciApO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJjb25zdHJ1Y3RvciA9IC8oXnxcXC4pW0EtWl1bQS16XSskLztcbmZ1bmN0aW9uIGNvbnN0cnVjdG9yRmlsdGVyKCBuYW1lICkge1xuXHRyZXR1cm4gdHlwZW9mIHRoaXNbbmFtZV0gPT09ICdmdW5jdGlvbicgJiYgcmNvbnN0cnVjdG9yLnRlc3QobmFtZSk7XG59XG5cbi8vIHVud3JhcCBhIGNvbGxlY3Rpb24gb3IgYXJyYXkgb2YgY29sbGVjdGlvblxuZnVuY3Rpb24gdW53cmFwQXJnKCBhcnIsIGlkLCBpc1BsdXJhbCApIHtcblx0Ly8gdW53cmFwIGEgc2luZ2xlIGNvbGxlY3Rpb25cblx0aWYgKCBhcnIgJiYgYXJyW2lkXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24gKSB7XG5cdFx0YXJyW2lkXSA9IGlzUGx1cmFsID9cblx0XHRcdFtdLnNsaWNlLmNhbGwoIGFycltpZF0sIDAgKTpcblx0XHRcdGFycltpZF1bMF07XG5cblx0Ly8gdW53cmFwIGFuIGFycmF5IG9mIGNvbGxlY3Rpb25cblx0fSBlbHNlIGlmICggYXJyICYmIGFycltpZF0ubGVuZ3RoICYmIGFycltpZF1bMF0gaW5zdGFuY2VvZiBDb2xsZWN0aW9uICkge1xuXHRcdGZvciAoIGkgPSAtMTsgKytpIDwgYXJyW2lkXS5sZW5ndGg7ICkge1xuXHRcdFx0YXJyW2lkXVtpXSA9IGFycltpZF1baV1bMF07XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHVud3JhcEFyZ3MoKSB7XG5cdHZhciBpc1BsdXJhbCA9IHRoaXMuaXNQbHVyYWwsXG5cdFx0YXJncyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApLFxuXHRcdGFycixcblx0XHRpZCxcblx0XHRpO1xuXG5cdC8vIGZpcnN0IGFyZyBpcyBhbiBvYmplY3QgYW5kIG1pZ2h0IGhhdmUgYSBjb2xsZWN0aW9uIG9yIGFycmF5IG9mIGNvbGxlY3Rpb25cblx0Ly8gVG9kbzogb2JqZWN0cyBzaG91bGQgYmUgdW53cmFwcGVkIHJlY3Vyc2l2ZWx5XG5cdGlmICggYXJnc1swXSAmJiBhcmdzWzBdLmNvbnN0cnVjdG9yID09PSBPYmplY3QgKSB7XG5cdFx0aWYgKCAnY2hpbGRyZW4nIGluIGFyZ3NbMF0gKSB7XG5cdFx0XHRpZCA9ICdjaGlsZHJlbic7XG5cblx0XHR9IGVsc2UgaWYgKCAnc2VnbWVudHMnIGluIGFyZ3NbMF0gKSB7XG5cdFx0XHRpZCA9ICdzZWdtZW50cyc7XG5cblx0XHR9IGVsc2UgaWYgKCAnbm9kZXMnIGluIGFyZ3NbMF0gKSB7XG5cdFx0XHRpZCA9ICdub2Rlcyc7XG5cdFx0fVxuXG5cdFx0dW53cmFwQXJnKCBhcmdzWzBdLCBpZCwgdHJ1ZSApO1xuXG5cdC8vIG90aGVyd2lzZSB1bndyYXAgZWFjaCBhcmdcblx0fSBlbHNlIHtcblx0XHRmb3IgKCBpID0gLTE7ICsraSA8IGFyZ3MubGVuZ3RoOyApIHtcblx0XHRcdC8vIGlmIHRoZSBtZXRob2QgaXMgcGx1cmFsIChhZGRDaGlsZHJlbikgYW5kIHdlJ3JlIHVud3JhcHBpbmdcblx0XHRcdC8vIHRoZSBsYXN0IGFyZ3VtZW50LCB3ZSB3YW50IHRvIGtlZXAgaXQgaW4gYW4gYXJyYXlcblx0XHRcdHVud3JhcEFyZyggYXJncywgaSwgaSA9PT0gYXJncy5sZW5ndGggLTEgJiYgaXNQbHVyYWwgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYXJncztcbn1cblxuQ29sbGVjdGlvbi5wcm94eSA9IGZ1bmN0aW9uKCBwYXBlciApIHtcblx0dmFyIHBsdW1pbiA9IHRoaXM7XG5cblx0cGx1bWluLnBhcGVyID0gcGFwZXI7XG5cblx0dmFyIG1ldGhvZE5hbWVzID0ge307XG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCBwYXBlci5QYXBlclNjb3BlLnByb3RvdHlwZSApXG5cdFx0LmZpbHRlciggY29uc3RydWN0b3JGaWx0ZXIsIHBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlIClcblx0XHQuZm9yRWFjaChmdW5jdGlvbihuYW1lLCBpKSB7XG5cdFx0XHRwbHVtaW5bbmFtZV0gPSB3cmFwQ29uc3RydWN0b3IoIHRoaXNbbmFtZV0sIHRoaXNbbmFtZV0ucHJvdG90eXBlICk7XG5cblx0XHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gcHJveHkgbWV0aG9kcyBvZiBDb2xsZWN0aW9uXG5cdFx0XHRpZiAoIG5hbWUgPT09ICdDb2xsZWN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyggdGhpc1tuYW1lXS5wcm90b3R5cGUgKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUsIGkpIHtcblx0XHRcdFx0Ly8gY29sbGVjdCB1bmlxdWUgbWV0aG9kIG5hbWVzIChmaXJzdCB0ZXN0IGF2b2lkcyBnZXR0ZXJzKVxuXHRcdFx0XHRpZiAoICFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIG5hbWUpLmdldCAmJlxuXHRcdFx0XHRcdFx0dHlwZW9mIHRoaXNbbmFtZV0gPT09ICdmdW5jdGlvbicgKSB7XG5cblx0XHRcdFx0XHRtZXRob2ROYW1lc1tuYW1lXSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0fSwgdGhpc1tuYW1lXS5wcm90b3R5cGUpO1xuXG5cdFx0fSwgcGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUpO1xuXG5cdE9iamVjdC5rZXlzKCBwYXBlci5QYXBlclNjb3BlLnByb3RvdHlwZS5QYXRoIClcblx0XHQuZmlsdGVyKCBjb25zdHJ1Y3RvckZpbHRlciwgcGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuUGF0aCApXG5cdFx0LmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0cGx1bWluLlBhdGhbbmFtZV0gPSB3cmFwQ29uc3RydWN0b3IoIHRoaXNbbmFtZV0sIHRoaXMucHJvdG90eXBlLCB0cnVlICk7XG5cblx0XHR9LCBwYXBlci5QYXBlclNjb3BlLnByb3RvdHlwZS5QYXRoICk7XG5cblx0T2JqZWN0LmtleXMoIHBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlLlNoYXBlIClcblx0XHQuZmlsdGVyKCBjb25zdHJ1Y3RvckZpbHRlciwgcGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuU2hhcGUgKVxuXHRcdC5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHBsdW1pbi5TaGFwZVtuYW1lXSA9IHdyYXBDb25zdHJ1Y3RvciggdGhpc1tuYW1lXSwgdGhpcy5wcm90b3R5cGUsIHRydWUgKTtcblxuXHRcdH0sIHBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlLlNoYXBlICk7XG5cblx0Ly8gcHJveHkgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2Qgb2YgcGFwZXJcblx0Ly8gZG8gaXQgb25seSBhZnRlciBwcm94eWluZyBjb25zdHJ1Y3RvcnMgb3RoZXJ3aXNlIGl0J3Mgb3ZlcndyaXR0ZW5cblx0cGx1bWluLnNldHVwID0gcGFwZXIuc2V0dXAuYmluZChwYXBlcik7XG5cblx0Ly8gcHJveHkgYWxsIG1ldGhvZHMgZnJvbSBldmVyeSBjb25zdHJ1Y3RvclxuXHQvLyBieSBkZWZhdWx0IG1ldGhvZHMgYXJlbid0IGNoYWluYWJsZVxuXHRPYmplY3Qua2V5cyggbWV0aG9kTmFtZXMgKS5zb3J0KCkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0Ly8gcGxlYXNlIG9oIHBsZWFzZSwgZG9uJ3Qgb3ZlcndyaXRlIG15IGNvbnN0cnVjdG9yLCBJIG5lZWQgaXQuXG5cdFx0aWYgKCBuYW1lID09PSAnY29uc3RydWN0b3InICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYXJncyA9IHVud3JhcEFyZ3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKSxcblx0XHRcdFx0aSxcblx0XHRcdFx0cmVzdWx0O1xuXG5cdFx0XHRmb3IgKCBpID0gLTE7ICsraSA8IHRoaXMubGVuZ3RoOyApIHtcblx0XHRcdFx0cmVzdWx0ID0gdGhpc1tpXVtuYW1lXS5hcHBseSh0aGlzW2ldLCBhcmdzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYnkgZGVmYXVsdCBtZXRob2RzIGFyZW4ndCBjaGFpbmFibGVcblx0XHRcdC8vIHJldHVybiB0aGUgbGFzdCByZXN1bHRcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSk7XG5cblx0XHQvLyBhZGRDaGlsZCggaXRlbSApIGFuZCBvdGhlciBtZXRob2RzIHdpdGggc2ltaWxhciBzaWduYXR1cmVzXG5cdFx0Ly8gdGhhdCB3ZSB3YW50IHRvIG1ha2UgY2hhaW5hYmxlXG5cdHZhciBjaGFpbiA9IFtcblx0XHRcdCdzZXQnLFxuXHRcdFx0J3NldFgnLFxuXHRcdFx0J3NldFknLFxuXHRcdFx0J2luc2VydEFib3ZlJyxcblx0XHRcdCdpbnNlcnRCZWxvdycsXG5cdFx0XHQnc2VuZFRvQmFjaycsXG5cdFx0XHQnYnJpbmdUb0Zyb250Jyxcblx0XHRcdCdyZW1vdmUnLFxuXHRcdFx0J3JlbW92ZUNoaWxkcmVuJyxcblx0XHRcdCdyZXZlcnNlQ2hpbGRyZW4nLFxuXG5cdFx0XHQndHJhbnNsYXRlJyxcblx0XHRcdCdyb3RhdGUnLFxuXHRcdFx0J3NjYWxlJyxcblx0XHRcdCdzaGVhcicsXG5cdFx0XHQnc2tldycsXG5cdFx0XHQndHJhbnNmb3JtJyxcblx0XHRcdCdmaXRCb3VuZHMnLFxuXHRcdFx0J2VtaXQnLFxuXG5cdFx0XHQnYWN0aXZhdGUnLFxuXG5cdFx0XHQnc2V0UGl4ZWwnLFxuXG5cdFx0XHQnc21vb3RoJyxcblx0XHRcdCdtb3ZlVG8nLFxuXHRcdFx0J2xpbmVUbycsXG5cdFx0XHQnY3ViaWNDdXJ2ZVRvJyxcblx0XHRcdCdxdWFkcmF0aWNDdXJ2ZVRvJyxcblx0XHRcdCdjdXJ2ZVRvJyxcblx0XHRcdCdhcmNUbycsXG5cdFx0XHQnY2xvc2VQYXRoJyxcblx0XHRcdCdtb3ZlQnknLFxuXHRcdFx0J2xpbmVCeScsXG5cdFx0XHQnY3ViaWNDdXJ2ZUJ5Jyxcblx0XHRcdCdxdWFkcmF0aWNDdXJ2ZUJ5Jyxcblx0XHRcdCdjdXJ2ZUJ5Jyxcblx0XHRcdCdhcmNCeScsXG5cblx0XHRcdCdyZW1vdmVTZWdtZW50cycsXG5cdFx0XHQnc2ltcGxpZnknLFxuXHRcdFx0J3JldmVyc2UnLFxuXG5cdFx0XHQvLyBSZWN0YW5nbGVcblx0XHRcdCdpbmNsdWRlJyxcblx0XHRcdCdleHBhbmQnLFxuXHRcdFx0J3NjYWxlJyxcblx0XHQvLyBdLFxuXHRcdC8vIGNyZWF0ZUFuZENoYWluID0gW1xuXHRcdFx0J2FkZENoaWxkJyxcblx0XHRcdCdpbnNlcnRDaGlsZCcsXG5cdFx0XHQnYWRkQ2hpbGRyZW4nLFxuXHRcdFx0J2luc2VydENoaWxkcmVuJyxcblx0XHRcdCdyZXBsYWNlV2l0aCcsXG5cblx0XHRcdCdhcHBlbmRUb3AnLFxuXHRcdFx0J2FwcGVuZEJvdHRvbScsXG5cblx0XHRcdCdhZGQnLFxuXHRcdFx0J2luc2VydCcsXG5cdFx0XHQnYWRkU2VnbWVudHMnLFxuXHRcdFx0J2luc2VydFNlZ21lbnRzJyxcblx0XHRcdCdhZGROb2RlJyxcblx0XHRcdCdhZGROb2RlcycsXG5cdFx0XHQnaW5zZXJ0Tm9kZXMnLFxuXG5cdFx0XHQnYWRkR2x5cGgnLFxuXHRcdFx0J2FkZEdseXBocycsXG5cblx0XHRcdCdhZGRDb250b3VyJyxcblx0XHRcdCdpbnNlcnRDb250b3VyJyxcblx0XHRcdCdhZGRDb250b3VycycsXG5cdFx0XHQnaW5zZXJ0Q29udG91cnMnLFxuXHRcdFx0J2FkZEFuY2hvcicsXG5cdFx0XHQnYWRkQW5jaG9ycycsXG5cdFx0XHQnYWRkQ29tcG9uZW50Jyxcblx0XHRcdCdhZGRDb21wb25lbnRzJyxcblxuXHRcdFx0J2FkZFVuaWNvZGUnLFxuXHRcdFx0J3ByZXBhcmVPdCcsXG5cdFx0XHQnYWRkVG9Gb250cycsXG5cdFx0XHQnZG93bmxvYWQnXG5cdFx0XSxcblx0XHRwbHVyYWwgPSBbXG5cdFx0XHQnYWRkQ2hpbGRyZW4nLFxuXHRcdFx0J2luc2VydENoaWxkcmVuJyxcblx0XHRcdCdhZGRTZWdtZW50cycsXG5cdFx0XHQnaW5zZXJ0U2VnbWVudHMnLFxuXHRcdFx0J2FkZE5vZGVzJyxcblx0XHRcdCdpbnNlcnROb2RlcycsXG5cdFx0XHQnYWRkR2x5cGhzJyxcblx0XHRcdCdhZGRBbmNob3JzJyxcblx0XHRcdCdhZGRDb250b3VycycsXG5cdFx0XHQnaW5zZXJ0Q29udG91cnMnLFxuXHRcdFx0J2FkZENvbXBvbmVudHMnXG5cdFx0XSxcblx0XHRtYXRoUG9pbkZuID0gW1xuXHRcdFx0J3JvdW5kJyxcblx0XHRcdCdjZWlsJyxcblx0XHRcdCdmbG9vcicsXG5cdFx0XHQnYWJzJ1xuXHRcdF0sXG5cdFx0Ym9vbGVhblBhdGhPcCA9IFtcblx0XHRcdCd1bml0ZScsXG5cdFx0XHQnaW50ZXJzZWN0Jyxcblx0XHRcdCdzdWJ0cmFjdCcsXG5cdFx0XHQnZXhjbHVkZScsXG5cdFx0XHQnZGl2aWRlJ1xuXHRcdF07XG5cblx0Y2hhaW4uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0Q29sbGVjdGlvbi5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gdW53cmFwQXJncy5hcHBseShcblx0XHRcdFx0XHR7IGlzUGx1cmFsOiBwbHVyYWwuaW5kZXhPZihuYW1lKSAhPT0gLTEgfSxcblx0XHRcdFx0XHRhcmd1bWVudHNcblx0XHRcdFx0KSxcblx0XHRcdFx0aTtcblxuXHRcdFx0Zm9yICggaSA9IC0xOyArK2kgPCB0aGlzLmxlbmd0aDsgKSB7XG5cdFx0XHRcdHRoaXNbaV1bbmFtZV0uYXBwbHkodGhpc1tpXSwgYXJncyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIG1ha2UgbWV0aG9kIGNoYWluYWJsZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSk7XG5cblx0Ly8gc2luZ3VsYXIgY2hhaW5hYmxlIG1ldGhvZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0aW9uO1xufSx7XCIuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzXCI6Mn1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIG9wZW50eXBlID0gX2RlcmVxXygnLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL2Rpc3Qvb3BlbnR5cGUuanMnKSxcblx0R2x5cGggPSBfZGVyZXFfKCcuL0dseXBoLmpzJyk7XG5cbmZ1bmN0aW9uIEZvbnQoIGFyZ3MgKSB7XG5cdGlmICggIWFyZ3MgKSB7XG5cdFx0YXJncyA9IHt9O1xuXHR9XG5cblx0aWYgKCAhYXJncy5zdHlsZU5hbWUgKSB7XG5cdFx0YXJncy5zdHlsZU5hbWUgPSAnUmVndWxhcic7XG5cdH1cblxuXHRpZiAoICFhcmdzLnVuaXRzUGVyRW0gKSB7XG5cdFx0YXJncy51bml0c1BlckVtID0gMTAyNDtcblx0fVxuXG5cdHRoaXMub3QgPSBuZXcgb3BlbnR5cGUuRm9udCggYXJncyApO1xuXG5cdHRoaXMuZ2x5cGhzID0gW107XG5cdHRoaXMuZ2x5cGhNYXAgPSB7fTtcblx0dGhpcy5jaGFyTWFwID0ge307XG5cdHRoaXMuYWx0TWFwID0ge307XG5cdHRoaXMuX3N1YnNldCA9IGZhbHNlO1xuXG5cdHRoaXMuYWRkR2x5cGgobmV3IEdseXBoKHtcblx0XHRuYW1lOiAnLm5vdGRlZicsXG5cdFx0dW5pY29kZTogMFxuXHR9KSk7XG5cblx0aWYgKCBhcmdzICYmIGFyZ3MuZ2x5cGhzICkge1xuXHRcdHRoaXMuYWRkR2x5cGhzKCBhcmdzLmdseXBocyApO1xuXHR9XG5cblx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuZG9jdW1lbnQgKSB7XG5cdFx0Ly8gd29yayBhcm91bmQgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEwMDAwNVxuXHRcdC8vIGJ5IHVzaW5nIGZvbnRzLmRlbGV0ZSBpbiBiYXRjaCwgZXZlcnkgMSBzZWNvbmRcblx0XHRpZiAoIGRvY3VtZW50LmZvbnRzICkge1xuXHRcdFx0dGhpcy5hZGRlZEZvbnRzID0gW107XG5cblx0XHRcdHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR3aGlsZSAoIHRoaXMuYWRkZWRGb250cy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdGRvY3VtZW50LmZvbnRzLmRlbGV0ZSggdGhpcy5hZGRlZEZvbnRzLnNoaWZ0KCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fS5iaW5kKHRoaXMpLCAxMDAwKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKFxuXHRcdFx0XHR0aGlzLnN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcblx0XHRcdCk7XG5cdFx0XHQvLyBsZXQncyBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIENTU1N0eWxlU2hlZXRcblx0XHRcdC8vICh3b3VsZCBiZSBtdWNoIGVhc2llciB3aXRoIEFycmF5I2ZpbmQpXG5cdFx0XHR0aGlzLnN0eWxlU2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0c1tcblx0XHRcdFx0W10ubWFwLmNhbGwoZG9jdW1lbnQuc3R5bGVTaGVldHMsIGZ1bmN0aW9uKHNzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHNzLm93bmVyTm9kZTtcblx0XHRcdFx0fSkuaW5kZXhPZih0aGlzLnN0eWxlRWxlbWVudClcblx0XHRcdF07XG5cdFx0fVxuXHR9XG59XG5cbkZvbnQucHJvdG90eXBlLmFkZEdseXBoID0gZnVuY3Rpb24oIGdseXBoICkge1xuXHR0aGlzLmdseXBocy5wdXNoKCBnbHlwaCApO1xuXHR0aGlzLmdseXBoTWFwW2dseXBoLm5hbWVdID0gZ2x5cGg7XG5cblx0aWYgKCBnbHlwaC5vdC51bmljb2RlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIGdseXBoO1xuXHR9XG5cblx0Ly8gYnVpbGQgdGhlIGRlZmF1bHQgY21hcFxuXHQvLyBpZiBtdWx0aXBsZSBnbHlwaHMgc2hhcmUgdGhlIHNhbWUgdW5pY29kZSwgdXNlIHRoZSBnbHlwaCB3aGVyZSB1bmljb2RlIGFuZCBuYW1lIGFyZSBlcXVhbFxuXHRpZiAoICF0aGlzLmNoYXJNYXBbZ2x5cGgub3QudW5pY29kZV0gfHxcblx0XHRcdCggZ2x5cGgubmFtZS5sZW5ndGggPT09IDEgJiYgZ2x5cGgubmFtZS5jaGFyQ29kZUF0KDApID09PSBnbHlwaC5vdC51bmljb2RlICkgKSB7XG5cblx0XHR0aGlzLmNoYXJNYXBbZ2x5cGgub3QudW5pY29kZV0gPSBnbHlwaDtcblx0fVxuXG5cdC8vIGJ1aWxkIHRoZSBhbHRlcm5hdGVzIG1hcFxuXHRpZiAoICF0aGlzLmFsdE1hcFtnbHlwaC5vdC51bmljb2RlXSApIHtcblx0XHR0aGlzLmFsdE1hcFtnbHlwaC5vdC51bmljb2RlXSA9IFtdO1xuXHR9XG5cdHRoaXMuYWx0TWFwW2dseXBoLm90LnVuaWNvZGVdLnB1c2goIGdseXBoICk7XG5cblx0cmV0dXJuIGdseXBoO1xufTtcblxuRm9udC5wcm90b3R5cGUuYWRkR2x5cGhzID0gZnVuY3Rpb24oIGdseXBocyApIHtcblx0cmV0dXJuIGdseXBocy5mb3JFYWNoKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHR0aGlzLmFkZEdseXBoKGdseXBoKTtcblxuXHR9LCB0aGlzKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggRm9udC5wcm90b3R5cGUsICdzdWJzZXQnLCB7XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YnNldDtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggc2V0ICkge1xuXHRcdGlmICggc2V0ID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiAoIHRoaXMuX3N1YnNldCA9IGZhbHNlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICggdGhpcy5fc3Vic2V0ID0gKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnID8gc2V0LnNwbGl0KCcnKSA6IHNldClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oZSwgaSwgYXJyKSB7XG5cdFx0XHRcdHJldHVybiBhcnIubGFzdEluZGV4T2YoZSkgPT09IGk7XG5cdFx0XHR9KVxuXHRcdFx0Lm1hcChmdW5jdGlvbihlKSB7XG5cdFx0XHRcdHJldHVybiBlLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHR9KVxuXHRcdFx0LnNvcnQoKVxuXHRcdCk7XG5cdH1cbn0pO1xuXG5Gb250LnByb3RvdHlwZS5nZXRHbHlwaFN1YnNldCA9IGZ1bmN0aW9uKCBzZXQgKSB7XG5cdGlmICggc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0dGhpcy5zdWJzZXQgPSBzZXQ7XG5cdH1cblxuXHQvLyByZXVzZSBsYXN0IHN1YnNldCBpZiBwb3NzaWJsZVxuXHRpZiAoIHRoaXMuX2xhc3RTdWJzZXQgJiYgdGhpcy5fbGFzdFN1YnNldFswXSA9PT0gKCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RTdWJzZXRbMV07XG5cdH1cblxuXHQvLyBtZW1vaXplIGxhc3Qgc3Vic2V0XG5cdHRoaXMuX2xhc3RTdWJzZXQgPSBbXG5cdFx0KCB0aGlzLl9zdWJzZXQgfHwgW10gKS5qb2luKCksXG5cdFx0dGhpcy5nbHlwaHMuZmlsdGVyKGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0XHRcdGlmICggdGhpcy5fc3Vic2V0ID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdCggZ2x5cGgub3QudW5pY29kZSAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdFx0KCBnbHlwaC5vdC51bmljb2RlcyAmJiBnbHlwaC5vdC51bmljb2Rlcy5sZW5ndGggKSApICkge1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHRoaXMuX3N1YnNldCAmJiB0aGlzLl9zdWJzZXQuaW5kZXhPZiggZ2x5cGgub3QudW5pY29kZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRPRE86IGhhbmRsZSBtdWx0aXBsZSB1bmljb2Rlc1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSwgdGhpcylcblx0XTtcblxuXHRyZXR1cm4gdGhpcy5fbGFzdFN1YnNldFsxXTtcbn07XG5cbkZvbnQucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oIGZvbnQwLCBmb250MSwgY29lZiwgc2V0ICkge1xuXHR0aGlzLmdldEdseXBoU3Vic2V0KCBzZXQgKS5tYXAoZnVuY3Rpb24oIGdseXBoICkge1xuXHRcdGdseXBoLmludGVycG9sYXRlKFxuXHRcdFx0Zm9udDAuZ2x5cGhNYXBbZ2x5cGgubmFtZV0sXG5cdFx0XHRmb250MS5nbHlwaE1hcFtnbHlwaC5uYW1lXSxcblx0XHRcdGNvZWZcblx0XHQpO1xuXHR9KTtcblxuXHQvLyBUT0RPOiBldmFsdWF0ZSBpZiB0YWtpbmcgc3Vic2V0dGluZyBpbnRvIGFjY291bnQgbWFrZXMga2VybmluZ1xuXHQvLyBpbnRlcnBvbGF0aW9uIGZhc3RlciBvciBzbG93ZXIuXG5cdGlmICggdGhpcy5vdC5rZXJuaW5nUGFpcnMgKSB7XG5cdFx0Zm9yICggdmFyIGkgaW4gdGhpcy5vdC5rZXJuaW5nUGFpcnMgKSB7XG5cdFx0XHR0aGlzLm90Lmtlcm5pbmdQYWlyc1tpXSA9XG5cdFx0XHRcdGZvbnQwLm90Lmtlcm5pbmdQYWlyc1tpXSArXG5cdFx0XHRcdCggZm9udDEub3Qua2VybmluZ1BhaXJzW2ldIC0gZm9udDAub3Qua2VybmluZ1BhaXJzW2ldICkgKiBjb2VmO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMub3QuYXNjZW5kZXIgPVxuXHRcdGZvbnQwLm90LmFzY2VuZGVyICsgKCBmb250MS5vdC5hc2NlbmRlciAtIGZvbnQwLm90LmFzY2VuZGVyICkgKiBjb2VmO1xuXHR0aGlzLm90LmRlc2NlbmRlciA9XG5cdFx0Zm9udDAub3QuZGVzY2VuZGVyICsgKCBmb250MS5vdC5kZXNjZW5kZXIgLSBmb250MC5vdC5kZXNjZW5kZXIgKSAqIGNvZWY7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5Gb250LnByb3RvdHlwZS51cGRhdGVPVENvbW1hbmRzID0gZnVuY3Rpb24oIHNldCApIHtcblx0dGhpcy5vdC5nbHlwaHMgPSB0aGlzLmdldEdseXBoU3Vic2V0KCBzZXQgKS5tYXAoZnVuY3Rpb24oIGdseXBoICkge1xuXHRcdHJldHVybiBnbHlwaC51cGRhdGVPVENvbW1hbmRzKCk7XG5cdH0pO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxuRm9udC5wcm90b3R5cGUuaW1wb3J0T1QgPSBmdW5jdGlvbiggb3RGb250ICkge1xuXHR0aGlzLm90ID0gb3RGb250O1xuXG5cdG90Rm9udC5nbHlwaHMuZm9yRWFjaChmdW5jdGlvbiggb3RHbHlwaCApIHtcblx0XHR2YXIgZ2x5cGggPSBuZXcgR2x5cGgoe1xuXHRcdFx0XHRuYW1lOiBvdEdseXBoLm5hbWUsXG5cdFx0XHRcdHVuaWNvZGU6IG90R2x5cGgudW5pY29kZVxuXHRcdFx0fSk7XG5cblx0XHR0aGlzLmFkZEdseXBoKCBnbHlwaCApO1xuXHRcdGdseXBoLmltcG9ydE9UKCBvdEdseXBoICk7XG5cblx0fSwgdGhpcyk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5pZiAoIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5kb2N1bWVudCApIHtcblxuXHR2YXIgX1VSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcblx0Rm9udC5wcm90b3R5cGUuYWRkVG9Gb250cyA9IGRvY3VtZW50LmZvbnRzID9cblx0XHQvLyBDU1MgZm9udCBsb2FkaW5nLCBsaWdodG5pbmcgZmFzdFxuXHRcdGZ1bmN0aW9uKCBidWZmZXIgKSB7XG5cdFx0XHR2YXIgZm9udGZhY2UgPSBuZXcgRm9udEZhY2UoXG5cdFx0XHRcdHRoaXMub3QuZmFtaWx5TmFtZSxcblx0XHRcdFx0YnVmZmVyIHx8IHRoaXMub3QudG9CdWZmZXIoKVxuXHRcdFx0KTtcblxuXHRcdFx0ZG9jdW1lbnQuZm9udHMuYWRkKCBmb250ZmFjZSApO1xuXHRcdFx0dGhpcy5hZGRlZEZvbnRzLnB1c2goIGZvbnRmYWNlICk7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH06XG5cdFx0ZnVuY3Rpb24oIGJ1ZmZlciApIHtcblx0XHRcdHZhciB1cmwgPSBfVVJMLmNyZWF0ZU9iamVjdFVSTChcblx0XHRcdFx0XHRuZXcgQmxvYihcblx0XHRcdFx0XHRcdFsgbmV3IERhdGFWaWV3KCBidWZmZXIgfHzCoHRoaXMub3QudG9CdWZmZXIoKSApIF0sXG5cdFx0XHRcdFx0XHR7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfVxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdFx0aWYgKCB0aGlzLmZvbnRPYmplY3RVUkwgKSB7XG5cdFx0XHRcdF9VUkwucmV2b2tlT2JqZWN0VVJMKCB0aGlzLmZvbnRPYmplY3RVUkwgKTtcblx0XHRcdFx0dGhpcy5zdHlsZVNoZWV0LmRlbGV0ZVJ1bGUoMCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc3R5bGVTaGVldC5pbnNlcnRSdWxlKFxuXHRcdFx0XHQnQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIicgKyB0aGlzLm90LmZhbWlseU5hbWUgKyAnXCI7IHNyYzogdXJsKCcgKyB1cmwgKyAnKTsgfScsXG5cdFx0XHRcdDBcblx0XHRcdCk7XG5cdFx0XHR0aGlzLmZvbnRPYmplY3RVUkwgPSB1cmw7XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cblx0Rm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbiggYnVmZmVyICkge1xuXHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG5cdFx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmxvY2F0aW9uID0gcmVhZGVyLnJlc3VsdDtcblx0XHR9O1xuXG5cdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwobmV3IEJsb2IoXG5cdFx0XHRbIG5ldyBEYXRhVmlldyggYnVmZmVyIHx8IHRoaXMub3QudG9CdWZmZXIoKSApIF0sXG5cdFx0XHR7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfVxuXHRcdCkpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb250O1xufSx7XCIuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qc1wiOjEsXCIuL0dseXBoLmpzXCI6NX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIG9wZW50eXBlID0gX2RlcmVxXygnLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL2Rpc3Qvb3BlbnR5cGUuanMnKSxcblx0cGFwZXIgPSBfZGVyZXFfKCcuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzJyk7XG5cbmZ1bmN0aW9uIEdseXBoKCBhcmdzICkge1xuXHRwYXBlci5Db21wb3VuZFBhdGgucHJvdG90eXBlLmNvbnN0cnVjdG9yLmFwcGx5KCB0aGlzICk7XG5cblx0aWYgKCBhcmdzICYmIHR5cGVvZiBhcmdzLnVuaWNvZGUgPT09ICdzdHJpbmcnICkge1xuXHRcdGFyZ3MudW5pY29kZSA9IGFyZ3MudW5pY29kZS5jaGFyQ29kZUF0KDApO1xuXHR9XG5cblx0dGhpcy5vdCA9IG5ldyBvcGVudHlwZS5HbHlwaCggYXJncyApO1xuXHR0aGlzLm90LnBhdGggPSBuZXcgb3BlbnR5cGUuUGF0aCgpO1xuXG5cdHRoaXMubmFtZSA9IGFyZ3MubmFtZTtcblx0Ly8gd29ya2Fyb3VuZCBvcGVudHlwZSAndW5pY29kZSA9PT0gMCcgYnVnXG5cdHRoaXMub3QudW5pY29kZSA9IGFyZ3MudW5pY29kZTtcblxuXHQvL3RoaXMuY29udG91cnMgPSAoIGFyZ3MgJiYgYXJncy5jb250b3VycyApIHx8IFtdO1xuXHR0aGlzLmFuY2hvcnMgPSAoIGFyZ3MgJiYgYXJncy5hbmNob3JzICkgfHwgW107XG5cdHRoaXMuY29tcG9uZW50cyA9ICggYXJncyAmJiBhcmdzLmNvbXBvbmVudHMgKSB8fCBbXTtcblx0dGhpcy5wYXJlbnRBbmNob3JzID0gKCBhcmdzICYmIGFyZ3MucGFyZW50QW5jaG9ycyApIHx8IFtdO1xuXG5cdC8vIGRlZmF1bHQgZmlsbCBjb2xvciBuZWVkZWQgdG8gZGlzcGxheSB0aGUgZ2x5cGggaW4gYSBjYW52YXNcblx0dGhpcy5maWxsQ29sb3IgPSBuZXcgcGFwZXIuQ29sb3IoMCwwLDApO1xuXHQvLyBidXQgZWFjaCBpbmRpdmlkdWFsIGdseXBoIG11c3QgYmUgZXhwbGljaXRlbHkgbWFkZSB2aXNpYmxlXG5cdHRoaXMudmlzaWJsZSA9IGZhbHNlO1xufVxuXG5HbHlwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcGVyLkNvbXBvdW5kUGF0aC5wcm90b3R5cGUpO1xuR2x5cGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2x5cGg7XG5cbi8vIFRvZG86IGhhbmRsZSB1bmljb2RlIHVwZGF0ZXNcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHbHlwaC5wcm90b3R5cGUsICd1bmljb2RlJywge1xuXHRzZXQ6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdHRoaXMub3QudW5pY29kZSA9IHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyA/XG5cdFx0XHRjb2RlLmNoYXJDb2RlQXQoMCk6XG5cdFx0XHRjb2RlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm90LnVuaWNvZGU7XG5cdH1cbn0pO1xuXG4vLyBwcm94eSAqQ2hpbGQvKkNoaWxkcmVuIG1ldGhvZHMgdG8gKkNvbnRvdXIvKkNvbnRvdXJzXG4vLyBUaGlzIGhhcyB0aGUgYWRkZWQgYmVuZWZpdCBvZiBwcmV2ZW50aW5nIENvbXBvdW5kUGF0aCNpbnNlcnRDaGlsZHJlblxuLy8gZnJvbSBhcmJpdHJhcmlseSBjaGFuZ2luZyB0aGUgZGlyZWN0aW9uIG9mIHBhdGhzXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyggcGFwZXIuSXRlbS5wcm90b3R5cGUgKVxuXHQuZm9yRWFjaChmdW5jdGlvbihuYW1lLCBpKSB7XG5cdFx0Ly8gZXhjbHVkZSBnZXR0ZXJzIGFuZCBub24tbWV0aG9kc1xuXHRcdGlmICggT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBuYW1lKS5nZXQgfHxcblx0XHRcdFx0dHlwZW9mIHRoaXNbbmFtZV0gIT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuYW1lLmluZGV4T2YoJ0NoaWxkcmVuJykgIT09IC0xICkge1xuXHRcdFx0dGhpc1tuYW1lLnJlcGxhY2UoJ0NoaWxkcmVuJywgJ0NvbnRvdXJzJyldID0gdGhpc1tuYW1lXTtcblxuXHRcdH0gZWxzZSBpZiAoIG5hbWUuaW5kZXhPZignQ2hpbGQnKSAhPT0gLTEgKSB7XG5cdFx0XHR0aGlzW25hbWUucmVwbGFjZSgnQ2hpbGQnLCAnQ29udG91cicpXSA9IHRoaXNbbmFtZV07XG5cdFx0fVxuXG5cdH0sIHBhcGVyLkl0ZW0ucHJvdG90eXBlKTtcblxuLy8gRml4IHR3byBwcm9ibGVtcyB3aXRoIENvbXBvdW5kUGF0aCNpbnNlcnRDaGlsZHJlbjpcbi8vIC0gaXQgYXJiaXRyYXJpbHkgY2hhbmdlcyB0aGUgZGlyZWN0aW9uIG9mIHBhdGhzXG4vLyAtIGl0IHNlZW1zIHRoYXQgaXQgZG9lc24ndCBoYW5kbGUgQ29tcG91bmRQYXRoIGFyZ3VtZW50c1xuR2x5cGgucHJvdG90eXBlLmluc2VydENoaWxkcmVuID0gZnVuY3Rpb24oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCBpdGVtcyApICkge1xuXHRcdC8vIGZsYXR0ZW4gaXRlbXMgdG8gaGFuZGxlIENvbXBvdW5kUGF0aCBjaGlsZHJlblxuXHRcdGl0ZW1zID0gW10uY29uY2F0LmFwcGx5KFtdLCBpdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBwYXBlci5QYXRoID8gaXRlbSA6IGl0ZW0uY2hpbGRyZW47XG5cdFx0fSkpO1xuXHR9XG5cblx0cmV0dXJuIHBhcGVyLkl0ZW0ucHJvdG90eXBlLmluc2VydENoaWxkcmVuLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIHBhcGVyLlBhdGgpO1xufTtcblxuLy8gcHJveHkgLmNoaWxkcmVuIHRvIC5jb250b3Vyc1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFxuXHRHbHlwaC5wcm90b3R5cGUsXG5cdCdjb250b3VycycsXG5cdE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHBhcGVyLkl0ZW0ucHJvdG90eXBlLCAnY2hpbGRyZW4nIClcbik7XG5cbkdseXBoLnByb3RvdHlwZS5hZGRDb21wb25lbnQgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0dGhpcy5hZGRDaGlsZCggaXRlbSApO1xuXHR0aGlzLmNvbXBvbmVudHMucHVzaCggaXRlbSApO1xuXHRyZXR1cm4gaXRlbTtcbn07XG5cbkdseXBoLnByb3RvdHlwZS5hZGRDb21wb25lbnRzID0gZnVuY3Rpb24oIGNvbXBvbmVudHMgKSB7XG5cdHJldHVybiBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50KSB7XG5cdFx0dGhpcy5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcblx0fSwgdGhpcyk7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUuYWRkQW5jaG9yID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdHRoaXMuYW5jaG9ycy5wdXNoKCBpdGVtICk7XG5cdHJldHVybiBpdGVtO1xufTtcblxuR2x5cGgucHJvdG90eXBlLmFkZEFuY2hvcnMgPSBmdW5jdGlvbiggYW5jaG9ycyApIHtcblx0cmV0dXJuIGFuY2hvcnMuZm9yRWFjaChmdW5jdGlvbihhbmNob3IpIHtcblx0XHR0aGlzLmFkZEFuY2hvcihhbmNob3IpO1xuXHR9LCB0aGlzKTtcbn07XG5cbkdseXBoLnByb3RvdHlwZS5hZGRQYXJlbnRBbmNob3IgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0dGhpcy5wYXJlbnRBbmNob3JzLnB1c2goIGl0ZW0gKTtcblx0cmV0dXJuIGl0ZW07XG59O1xuXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKCBjb2RlICkge1xuXHR0aGlzLm90LmFkZFVuaWNvZGUoIGNvZGUgKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkdseXBoLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKCBnbHlwaDAsIGdseXBoMSwgY29lZiApIHtcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmNvbnRvdXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdC8vIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gc2hvdWxkIGJlIHRoZSBzYW1lIGV2ZXJ5d2hlcmUsXG5cdFx0Ly8gYnV0IHdlJ3JlIGdvaW5nIHRvIHRyeSBvdXIgYmVzdCBhbnl3YXlcblx0XHRpZiAoICFnbHlwaDAuY29udG91cnNbaV0gfHwgIWdseXBoMS5jb250b3Vyc1tpXSApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHRoaXMuY29udG91cnNbaV0uaW50ZXJwb2xhdGUoXG5cdFx0XHRnbHlwaDAuY29udG91cnNbaV0sXG5cdFx0XHRnbHlwaDEuY29udG91cnNbaV0sXG5cdFx0XHRjb2VmXG5cdFx0KTtcblxuXHRcdHRoaXMub3QuYWR2YW5jZVdpZHRoID1cblx0XHRcdGdseXBoMC5vdC5hZHZhbmNlV2lkdGggK1xuXHRcdFx0KCBnbHlwaDEub3QuYWR2YW5jZVdpZHRoIC0gZ2x5cGgwLm90LmFkdmFuY2VXaWR0aCApICogY29lZjtcblx0XHR0aGlzLm90LmxlZnRTaWRlQmVhcmluZyA9XG5cdFx0XHRnbHlwaDAub3QubGVmdFNpZGVCZWFyaW5nICtcblx0XHRcdCggZ2x5cGgxLm90LmxlZnRTaWRlQmVhcmluZyAtIGdseXBoMC5vdC5sZWZ0U2lkZUJlYXJpbmcgKSAqIGNvZWY7XG5cdFx0dGhpcy5vdC54TWF4ID1cblx0XHRcdGdseXBoMC5vdC54TWF4ICsgKCBnbHlwaDEub3QueE1heCAtIGdseXBoMC5vdC54TWF4ICkgKiBjb2VmO1xuXHRcdHRoaXMub3QueE1pbiA9XG5cdFx0XHRnbHlwaDAub3QueE1pbiArICggZ2x5cGgxLm90LnhNaW4gLSBnbHlwaDAub3QueE1pbiApICogY29lZjtcblx0XHR0aGlzLm90LnlNYXggPVxuXHRcdFx0Z2x5cGgwLm90LnlNYXggKyAoIGdseXBoMS5vdC55TWF4IC0gZ2x5cGgwLm90LnlNYXggKSAqIGNvZWY7XG5cdFx0dGhpcy5vdC55TWluID1cblx0XHRcdGdseXBoMC5vdC55TWluICsgKCBnbHlwaDEub3QueU1pbiAtIGdseXBoMC5vdC55TWluICkgKiBjb2VmO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUudXBkYXRlT1RDb21tYW5kcyA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRpZiAoICFwYXRoICkge1xuXHRcdHRoaXMub3QucGF0aC5jb21tYW5kcyA9IFtdO1xuXHRcdHBhdGggPSB0aGlzLm90LnBhdGg7XG5cdH1cblxuXHR0aGlzLmNvbnRvdXJzLmZvckVhY2goZnVuY3Rpb24oIGNvbnRvdXIgKSB7XG5cdFx0Y29udG91ci51cGRhdGVPVENvbW1hbmRzKCB0aGlzLm90LnBhdGggKTtcblx0fSwgdGhpcyk7XG5cblx0cmV0dXJuIHRoaXMub3Q7XG59O1xuXG5HbHlwaC5wcm90b3R5cGUuaW1wb3J0T1QgPSBmdW5jdGlvbiggb3RHbHlwaCApIHtcblx0dmFyIGN1cnJlbnQ7XG5cdHRoaXMub3QgPSBvdEdseXBoO1xuXG5cdGlmICggIW90R2x5cGgucGF0aCB8fCAhb3RHbHlwaC5wYXRoLmNvbW1hbmRzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHRoaXMub3QucGF0aC5jb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGNvbW1hbmQpIHtcblx0XHRzd2l0Y2ggKCBjb21tYW5kLnR5cGUgKSB7XG5cdFx0XHRjYXNlICdNJzpcblx0XHRcdFx0Y3VycmVudCA9IG5ldyBwYXBlci5QYXRoKCk7XG5cdFx0XHRcdHRoaXMuYWRkQ29udG91ciggY3VycmVudCApO1xuXG5cdFx0XHRcdGN1cnJlbnQubW92ZVRvKCBjb21tYW5kICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnTCc6XG5cdFx0XHRcdGN1cnJlbnQubGluZVRvKCBjb21tYW5kICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQyc6XG5cdFx0XHRcdGN1cnJlbnQuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFtjb21tYW5kLngxLCBjb21tYW5kLnkxXSxcblx0XHRcdFx0XHRbY29tbWFuZC54MiwgY29tbWFuZC55Ml0sXG5cdFx0XHRcdFx0Y29tbWFuZFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1EnOlxuXHRcdFx0XHRjdXJyZW50LnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0W2NvbW1hbmQueDEsIGNvbW1hbmQueTFdLFxuXHRcdFx0XHRcdGNvbW1hbmRcblx0XHRcdFx0KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0Ly8gV2hlbiB0aGUgZ2x5cGggaGFzIG5vIGNvbnRvdXIsXG5cdFx0XHRcdC8vIHRoZXkgY29udGFpbiBhIHNpbmdsZSBaIGNvbW1hbmQgaW5cblx0XHRcdFx0Ly8gb3BlbnR5cGUuanMuXG5cdFx0XHRcdC8vIFRPRE86IHNlZSBob3cgd2Ugc2hvdWxkIGhhbmRsZSB0aGF0XG5cdFx0XHRcdGlmICggY3VycmVudCApIHtcblx0XHRcdFx0XHRjdXJyZW50LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fSwgdGhpcyk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdseXBoO1xufSx7XCIuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qc1wiOjEsXCIuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzXCI6Mn1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIHBhcGVyID0gX2RlcmVxXygnLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItY29yZS5qcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoIHBhcGVyLlNlZ21lbnQucHJvdG90eXBlLCAneCcsIHtcblx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludC54O1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR0aGlzLnBvaW50LnggPSB2YWx1ZTtcblx0fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSggcGFwZXIuU2VnbWVudC5wcm90b3R5cGUsICd5Jywge1xuXHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnBvaW50Lnk7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHRoaXMucG9pbnQueSA9IHZhbHVlO1xuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXBlci5TZWdtZW50O1xufSx7XCIuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzXCI6Mn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLyogRXh0ZW5kIHRoZSBQYXRoIHByb3RvdHlwZSB0byBhZGQgT3BlblR5cGUgY29udmVyc2lvblxuICogYW5kIGFsaWFzICpzZWdtZW50cyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRvICpub2Rlc1xuICovXG52YXIgcGFwZXIgPSBfZGVyZXFfKCcuLi9ub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1jb3JlLmpzJyksXG5cdHByb3RvID0gcGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuUGF0aC5wcm90b3R5cGU7XG5cbi8vIGFsaWFzICpTZWdtZW50cyBtZXRob2RzIHRvICpOb2RlcyBlcXVpdmFsZW50c1xuWydhZGQnLCAnaW5zZXJ0JywgJ3JlbW92ZSddLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuXHRwcm90b1tuYW1lICsgJ05vZGVzJ10gPVxuXHRcdHByb3RvW25hbWUgKyAnU2VnbWVudHMnXTtcbn0pO1xuXG4vLyBhbGlhcyAuc2VnbWVudHMgdG8gLm5vZGVzXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywge1xuXHRub2RlczogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggcHJvdG8sICdzZWdtZW50cycgKSxcblx0Zmlyc3ROb2RlOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBwcm90bywgJ2ZpcnN0U2VnbWVudCcgKSxcblx0bGFzdE5vZGU6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHByb3RvLCAnbGFzdFNlZ21lbnQnIClcbn0pO1xuXG5wcm90by51cGRhdGVPVENvbW1hbmRzID0gZnVuY3Rpb24oIHBhdGggKSB7XG5cdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0dHlwZTogJ00nLFxuXHRcdHg6IE1hdGgucm91bmQoIHRoaXMuX3NlZ21lbnRzWzBdLnBvaW50LnggKSB8fCAwLFxuXHRcdHk6IE1hdGgucm91bmQoIHRoaXMuX3NlZ21lbnRzWzBdLnBvaW50LnkgKSB8fCAwXG5cdH0pO1xuXG5cdHRoaXMuY3VydmVzLmZvckVhY2goZnVuY3Rpb24oIGN1cnZlICkge1xuXHRcdGlmICggY3VydmUuaXNMaW5lYXIoKSApIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdMJyxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhdGguY29tbWFuZHMucHVzaCh7XG5cdFx0XHRcdHR5cGU6ICdDJyxcblx0XHRcdFx0eDE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS54ICsgY3VydmUuaGFuZGxlMS54ICkgfHwgMCxcblx0XHRcdFx0eTE6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50MS55ICsgY3VydmUuaGFuZGxlMS55ICkgfHwgMCxcblx0XHRcdFx0eDI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi54ICsgY3VydmUuaGFuZGxlMi54ICkgfHwgMCxcblx0XHRcdFx0eTI6IE1hdGgucm91bmQoIGN1cnZlLnBvaW50Mi55ICsgY3VydmUuaGFuZGxlMi55ICkgfHwgMCxcblx0XHRcdFx0eDogTWF0aC5yb3VuZCggY3VydmUucG9pbnQyLnggKSB8fCAwLFxuXHRcdFx0XHR5OiBNYXRoLnJvdW5kKCBjdXJ2ZS5wb2ludDIueSApIHx8IDBcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcGVyLlBhdGg7XG59LHtcIi4uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanNcIjoyfV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgb3BlbnR5cGUgPSBfZGVyZXFfKCcuLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcycpLFxuXHRwYXBlciA9IF9kZXJlcV8oJy4uL25vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWNvcmUuanMnKSxcblx0Rm9udCA9IF9kZXJlcV8oJy4vRm9udC5qcycpLFxuXHRHbHlwaCA9IF9kZXJlcV8oJy4vR2x5cGguanMnKSxcblx0UGF0aCA9IF9kZXJlcV8oJy4vUGF0aC5qcycpLFxuXHROb2RlID0gX2RlcmVxXygnLi9Ob2RlLmpzJyksXG5cdENvbGxlY3Rpb24gPSBfZGVyZXFfKCcuL0NvbGxlY3Rpb24uanMnKTtcblxucGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuRm9udCA9IEZvbnQ7XG5wYXBlci5QYXBlclNjb3BlLnByb3RvdHlwZS5HbHlwaCA9IEdseXBoO1xucGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuUGF0aCA9IFBhdGg7XG5wYXBlci5QYXBlclNjb3BlLnByb3RvdHlwZS5Ob2RlID0gTm9kZTtcbnBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlLkNvbGxlY3Rpb24gPSBDb2xsZWN0aW9uO1xuXG5mdW5jdGlvbiBwbHVtaW4oIGFyZyApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZyBpbnN0YW5jZW9mIENvbGxlY3Rpb24gKSB7XG5cdFx0cmV0dXJuIGFyZztcblx0fVxuXG5cdHZhciBjID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbi5wcm90b3R5cGUgKTtcblx0Q29sbGVjdGlvbi5hcHBseSggYywgYXJndW1lbnRzICk7XG5cdHJldHVybiBjO1xufVxuXG5wbHVtaW4ub3BlbnR5cGUgPSBvcGVudHlwZTtcblxucGx1bWluLnByb3h5ID0gQ29sbGVjdGlvbi5wcm94eS5iaW5kKHBsdW1pbik7XG5wbHVtaW4ucHJveHkocGFwZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdW1pbjtcbn0se1wiLi4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL2Rpc3Qvb3BlbnR5cGUuanNcIjoxLFwiLi4vbm9kZV9tb2R1bGVzL3BhcGVyL2Rpc3QvcGFwZXItY29yZS5qc1wiOjIsXCIuL0NvbGxlY3Rpb24uanNcIjozLFwiLi9Gb250LmpzXCI6NCxcIi4vR2x5cGguanNcIjo1LFwiLi9Ob2RlLmpzXCI6NixcIi4vUGF0aC5qc1wiOjd9XX0se30sWzhdKSg4KVxufSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbHVtaW4uanMubWFwXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbnZhciBwbHVtaW4gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvcGx1bWluLmpzL2Rpc3QvcGx1bWluLmpzJyksXG5cdHBhcGVyID0gcGx1bWluLnBhcGVyLFxuXHREZXBUcmVlID0gcmVxdWlyZSgnLi4vbm9kZV9tb2R1bGVzL2RlcHRyZWUvaW5kZXguanMnKTtcblxudmFyIFV0aWxzID0ge307XG5cbi8vIGNyZWF0ZSBHbHlwaCBpbnN0YW5jZSBhbmQgYWxsIGl0cyBjaGlsZCBpdGVtczogYW5jaG9ycywgY29udG91cnMgYW5kIGNvbXBvbmVudHNcblV0aWxzLmdseXBoRnJvbVNyYyA9IGZ1bmN0aW9uKCBnbHlwaFNyYyApIHtcblx0dmFyIGdseXBoID0gbmV3IHBhcGVyLkdseXBoKHtcblx0XHRuYW1lOiBnbHlwaFNyYy5uYW1lLFxuXHRcdHVuaWNvZGU6IGdseXBoU3JjLnVuaWNvZGVcblx0fSk7XG5cdGdseXBoLnNyYyA9IGdseXBoU3JjO1xuXHRVdGlscy5tZXJnZVN0YXRpYyggZ2x5cGgsIGdseXBoU3JjICk7XG5cblx0aWYgKCBnbHlwaFNyYy5hbmNob3JzICkge1xuXHRcdGdseXBoU3JjLmFuY2hvcnMuZm9yRWFjaChmdW5jdGlvbihhbmNob3JTcmMpIHtcblx0XHRcdHZhciBhbmNob3IgPSBuZXcgcGFwZXIuTm9kZSgpO1xuXHRcdFx0YW5jaG9yLnNyYyA9IGFuY2hvclNyYztcblx0XHRcdFV0aWxzLm1lcmdlU3RhdGljKCBhbmNob3IsIGFuY2hvclNyYyApO1xuXG5cdFx0XHRnbHlwaC5hZGRBbmNob3IoIGFuY2hvciApO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCBnbHlwaFNyYy5jb250b3VycyApIHtcblx0XHRnbHlwaFNyYy5jb250b3Vycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRvdXJTcmMpIHtcblx0XHRcdHZhciBjb250b3VyID0gbmV3IHBhcGVyLlBhdGgoKTtcblx0XHRcdGNvbnRvdXIuc3JjID0gY29udG91clNyYztcblx0XHRcdFV0aWxzLm1lcmdlU3RhdGljKCBjb250b3VyLCBjb250b3VyU3JjICk7XG5cblx0XHRcdGdseXBoLmFkZENvbnRvdXIoIGNvbnRvdXIgKTtcblxuXHRcdFx0Ly8gVE9ETzogaGFuZGxlIG9uY3VydmUvb2ZmY3VydmUgcG9pbnRzXG5cdFx0XHRjb250b3VyU3JjLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZVNyYykge1xuXHRcdFx0XHR2YXIgbm9kZSA9IG5ldyBwYXBlci5Ob2RlKCk7XG5cdFx0XHRcdG5vZGUuc3JjID0gbm9kZVNyYztcblx0XHRcdFx0VXRpbHMubWVyZ2VTdGF0aWMoIG5vZGUsIG5vZGVTcmMgKTtcblxuXHRcdFx0XHRjb250b3VyLmFkZCggbm9kZSApO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH1cblxuXHRyZXR1cm4gZ2x5cGg7XG59O1xuXG5VdGlscy5wcm9wRnJvbVBhdGggPSBmdW5jdGlvbiggcGF0aCwgbGVuZ3RoLCBjb250ZXh0ICkge1xuXHRmb3IgKCB2YXIgaSA9IC0xOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdGNvbnRleHQgPSBjb250ZXh0WyBwYXRoW2ldIF07XG5cdH1cblxuXHRyZXR1cm4gY29udGV4dDtcbn07XG5cblV0aWxzLm1lcmdlU3RhdGljID0gZnVuY3Rpb24oIG9iaiwgc3JjICkge1xuXHRmb3IgKCB2YXIgaSBpbiBzcmMgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3JjW2ldICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdG9ialtpXSA9IHNyY1tpXTtcblx0XHR9XG5cdH1cbn07XG5cblV0aWxzLmNyZWF0ZVVwZGF0ZXJzID0gZnVuY3Rpb24oIGxlYWYgKSB7XG5cdGlmICggbGVhZi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmXG5cdFx0XHQoIHR5cGVvZiBsZWFmLl9vcGVyYXRpb24gPT09ICdzdHJpbmcnIHx8wqB0eXBlb2YgbGVhZi5fb3BlcmF0aW9uID09PSAnZnVuY3Rpb24nICkgKSB7XG5cblx0XHR2YXIgYXJncyA9IFsncHJvcE5hbWUnLCAnY29udG91cnMnLCAnYW5jaG9ycycsICdwYXJlbnRBbmNob3JzJywgJ1V0aWxzJ11cblx0XHRcdFx0LmNvbmNhdCggbGVhZi5fcGFyYW1ldGVycyB8fCBbXSApXG5cdFx0XHRcdC5jb25jYXQoIHR5cGVvZiBsZWFmLl9vcGVyYXRpb24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHQncmV0dXJuICcgKyBsZWFmLl9vcGVyYXRpb246XG5cdFx0XHRcdFx0bGVhZi5fb3BlcmF0aW9uLnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdC5yZXBsYWNlKC9mdW5jdGlvblxccyooKVxccypcXHsoLio/KVxcfSQvLCAnJDEnKS50cmltKClcblx0XHRcdFx0KTtcblxuXHRcdHJldHVybiAoIGxlYWYuX3VwZGF0ZXIgPSBGdW5jdGlvbi5hcHBseSggbnVsbCwgYXJncyApICk7XG5cdH1cblxuXHRpZiAoIGxlYWYuY29uc3RydWN0b3IgPT09IE9iamVjdCApIHtcblx0XHRmb3IgKCB2YXIgaSBpbiBsZWFmICkge1xuXHRcdFx0VXRpbHMuY3JlYXRlVXBkYXRlcnMoIGxlYWZbaV0gKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIGxlYWYuY29uc3RydWN0b3IgPT09IEFycmF5ICkge1xuXHRcdGxlYWYuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuXHRcdFx0VXRpbHMuY3JlYXRlVXBkYXRlcnMoIGNoaWxkICk7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8vIGNvbnZlcnQgdGhlIGdseXBoIHNvdXJjZSBmcm9tIHRoZSB1Zm8gb2JqZWN0IG1vZGVsIHRvIHRoZSBwYXBlciBvYmplY3QgbW9kZWxcbi8vIHRoaXMgaXMgdGhlIGludmVyc2Ugb3BlcmF0aW9uIGRvbmUgYnkganN1Zm9uaWZ5XG5VdGlscy51Zm9Ub1BhcGVyID0gZnVuY3Rpb24oIHNyYyApIHtcblx0aWYgKCBzcmMuYW5jaG9yICkge1xuXHRcdHNyYy5hbmNob3JzID0gc3JjLmFuY2hvcjtcblx0XHRkZWxldGUgc3JjLmFuY2hvcjtcblx0fVxuXG5cdGlmICggc3JjLm91dGxpbmUgJiYgc3JjLm91dGxpbmUuY29udG91ciApIHtcblx0XHRzcmMuY29udG91cnMgPSBzcmMub3V0bGluZS5jb250b3VyO1xuXHRcdGRlbGV0ZSBzcmMub3V0bGluZS5jb250b3VyO1xuXHR9XG5cblx0c3JjLmNvbnRvdXJzLmZvckVhY2goZnVuY3Rpb24oY29udG91cikge1xuXHRcdGlmICggY29udG91ci5wb2ludCApIHtcblx0XHRcdGNvbnRvdXIubm9kZXMgPSBjb250b3VyLnBvaW50O1xuXHRcdFx0ZGVsZXRlIGNvbnRvdXIucG9pbnQ7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAoIHNyYy5vdXRsaW5lICYmIHNyYy5vdXRsaW5lLmNvbXBvbmVudCApIHtcblx0XHRzcmMuY29tcG9uZW50cyA9IHNyYy5vdXRsaW5lLmNvbXBvbmVudDtcblx0XHRkZWxldGUgc3JjLm91dGxpbmUuY29udG91cjtcblx0fVxuXG5cdGlmICggc3JjLmxpYiAmJiBzcmMubGliLnRyYW5zZm9ybUxpc3QgKSB7XG5cdFx0c3JjLnRyYW5zZm9ybUxpc3QgPSBzcmMubGliLnRyYW5zZm9ybUxpc3Q7XG5cdFx0ZGVsZXRlIHNyYy5saWIudHJhbnNmb3JtTGlzdDtcblx0fVxufTtcblxuLy8gVXNlbGVzcyByaWdodCBub3csIHdlIGRvIGl0IGluIEdseXBoLnByb3RvdHlwZS51cGRhdGUgaW4gcHJvdG90eXBvLmpzXG5VdGlscy51cGRhdGVBdHRyID0gZnVuY3Rpb24oIGF0dHIsIHBhcmFtcywgZ2x5cGggKSB7XG5cdHZhciBhcmdzID0gWyBnbHlwaC5jb250b3VycywgZ2x5cGguYW5jaG9ycywgZ2x5cGgucGFyZW50QW5jaG9ycywgVXRpbHMgXTtcblx0KCBhdHRyLl9wYXJhbWV0ZXJzIHx8IFtdICkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG5cdFx0YXJncy5wdXNoKCBwYXJhbXNbbmFtZV0gKTtcblx0fSk7XG5cdHJldHVybiBhdHRyLl91cGRhdGVyLmFwcGx5KCB7fSwgYXJncyApO1xufTtcblxuVXRpbHMuc29sdmVEZXBlbmRlbmN5VHJlZSA9IGZ1bmN0aW9uKCBsZWFmU3JjLCBwYXRoLCBleGNsdWRlTGlzdCApIHtcblx0aWYgKCAhZXhjbHVkZUxpc3QgKSB7XG5cdFx0ZXhjbHVkZUxpc3QgPSBbXTtcblx0fVxuXG5cdHZhciBkZXBUcmVlID0gbmV3IERlcFRyZWUoKTtcblxuXHRVdGlscy5leGNsdWRlTGlzdCggbGVhZlNyYywgbnVsbCwgZXhjbHVkZUxpc3QgKTtcblxuXHRVdGlscy5kZXBlbmRlbmN5VHJlZSggbGVhZlNyYywgbnVsbCwgZXhjbHVkZUxpc3QsIGRlcFRyZWUgKTtcblxuXHRyZXR1cm4gZGVwVHJlZS5yZXNvbHZlKCk7XG59O1xuXG5VdGlscy5leGNsdWRlTGlzdCA9IGZ1bmN0aW9uKCBsZWFmU3JjLCBwYXRoLCBleGNsdWRlTGlzdCApIHtcblx0Zm9yICggdmFyIGkgaW4gbGVhZlNyYyApIHtcblx0XHR2YXIgYXR0ciA9IGxlYWZTcmNbaV0sXG5cdFx0XHRjdXJyUGF0aCA9IHBhdGggPyBwYXRoICsgJy4nICsgaSA6IGk7XG5cblx0XHRpZiAoIHR5cGVvZiBhdHRyICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdC8vIHN0YXRpYyBwcm9wcyBhcmUgaW1tZWRpYXRseSBhdmFpbGFibGUsIGV4Y2x1ZGUgdGhlbSBmcm9tIHRoZSB0cmVlXG5cdFx0XHRleGNsdWRlTGlzdC5wdXNoKCBjdXJyUGF0aCApO1xuXG5cdFx0Ly8gcmVjdXJzZVxuXHRcdH0gZWxzZSBpZiAoICFhdHRyLl9kZXBlbmRlbmNpZXMgJiYgIWF0dHIuX29wZXJhdGlvbiApIHtcblx0XHRcdFV0aWxzLmV4Y2x1ZGVMaXN0KCBhdHRyLCBjdXJyUGF0aCwgZXhjbHVkZUxpc3QgKTtcblx0XHR9XG5cdH1cbn07XG5cblV0aWxzLmRlcGVuZGVuY3lUcmVlID0gZnVuY3Rpb24oIGxlYWZTcmMsIHBhdGgsIGV4Y2x1ZGVMaXN0LCBkZXBUcmVlICkge1xuXHRmb3IgKCB2YXIgaSBpbiBsZWFmU3JjICkge1xuXHRcdHZhciBhdHRyID0gbGVhZlNyY1tpXSxcblx0XHRcdGN1cnJQYXRoID0gcGF0aCA/IHBhdGggKyAnLicgKyBpIDogaTtcblxuXHRcdGlmICggdHlwZW9mIGF0dHIgPT09ICdvYmplY3QnICkge1xuXHRcdFx0Ly8gb2JqZWN0cyB3aXRoIHVwZGF0ZXIgZnVuY3Rpb25zIGhhdmUgZGVwZW5kZW5jaWVzXG5cdFx0XHRpZiAoIGF0dHIuX2RlcGVuZGVuY2llcyApIHtcblx0XHRcdFx0dmFyIGRlcHMgPSBhdHRyLl9kZXBlbmRlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uKGRlcCkge1xuXHRcdFx0XHRcdHJldHVybiBleGNsdWRlTGlzdC5pbmRleE9mKCBkZXAgKSA9PT0gLTE7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRkZXBzID0gVXRpbHMuZXhwYW5kRGVwZW5kZW5jaWVzKCBkZXBzLCBleGNsdWRlTGlzdCApO1xuXHRcdFx0XHRkZXBUcmVlLmFkZChjdXJyUGF0aCwgZGVwcyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggIWF0dHIuX2RlcGVuZGVuY2llcyAmJiAhYXR0ci5fb3BlcmF0aW9uICkge1xuXHRcdFx0XHRVdGlscy5kZXBlbmRlbmN5VHJlZSggYXR0ciwgY3VyclBhdGgsIGV4Y2x1ZGVMaXN0LCBkZXBUcmVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRlcFRyZWU7XG59O1xuXG52YXIgcnBvaW50ID0gL1xcLnBvaW50JC8sXG5cdHJub2RlID0gL1xcLm5vZGVzXFwuXFxkKyQvO1xuVXRpbHMuZXhwYW5kRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24oIGRlcHMsIGV4Y2x1ZGVMaXN0ICkge1xuXHRkZXBzID0gZGVwcy5tYXAoZnVuY3Rpb24oZGVwKSB7XG5cdFx0dmFyIGRlcHM7XG5cblx0XHRpZiAoIHJwb2ludC50ZXN0KGRlcCkgKSB7XG5cdFx0XHRkZXAgPSBkZXAucmVwbGFjZShycG9pbnQsICcnKTtcblxuXHRcdFx0ZGVwcyA9IFtcblx0XHRcdFx0ZGVwICsgJy54Jyxcblx0XHRcdFx0ZGVwICsgJy55J1xuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSBpZiAoIHJub2RlLnRlc3QoZGVwKSApIHtcblx0XHRcdGRlcHMgPSBbXG5cdFx0XHRcdGRlcCArICcueCcsXG5cdFx0XHRcdGRlcCArICcueScsXG5cdFx0XHRcdGRlcCArICcuZXhwYW5kJ1xuXHRcdFx0XTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZGVwO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZXBzLmZpbHRlcihmdW5jdGlvbihkZXApIHtcblx0XHRcdHJldHVybiBleGNsdWRlTGlzdC5pbmRleE9mKCBkZXAgKSA9PT0gLTE7XG5cdFx0fSk7XG5cdH0pO1xuXG5cdC8vIGZsYXR0ZW4gZGVwcyBhcnJheVxuXHRyZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBkZXBzKTtcbn07XG5cbi8vIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWxlc3MsIHRoYW5rcyB0byBwYXBlclxuVXRpbHMubGluZUxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiggcDEsIHAyLCBwMywgcDQgKSB7XG5cdHZhciB4MSA9IHAxLngsXG5cdFx0eTEgPSBwMS55LFxuXHRcdHgyID0gcDIueCxcblx0XHR5MiA9IHAyLnksXG5cdFx0eDMgPSBwMy54LFxuXHRcdHkzID0gcDMueSxcblx0XHR4NCA9IHA0LngsXG5cdFx0eTQgPSBwNC55LFxuXHRcdGQgPSAoeDEteDIpICogKHkzLXk0KSAtICh5MS15MikgKiAoeDMteDQpO1xuXG5cdGlmICggZCA9PT0gMCApIHtcblx0XHQvLyBmYWlsIHNpbGVudGx5XG5cdFx0cmV0dXJuIFswLCAwXTtcblx0fVxuXG5cdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFtcblx0XHQoICh4MSp5MiAtIHkxKngyKSAqICh4My14NCkgLSAoeDEteDIpICogKHgzKnk0IC0geTMqeDQpICkgLyBkLFxuXHRcdCggKHgxKnkyIC0geTEqeDIpICogKHkzLXk0KSAtICh5MS15MikgKiAoeDMqeTQgLSB5Myp4NCkgKSAvIGRcblx0XSk7XG59O1xuXG4vLyBPYmplY3QubWl4aW4gcG9seWZpbGwgZm9yIElFOStcbmlmICggIWdsb2JhbC5PYmplY3QubWl4aW4gKSB7XG5cdGdsb2JhbC5PYmplY3QubWl4aW4gPSBmdW5jdGlvbiggdGFyZ2V0LCBzb3VyY2UgKSB7XG5cdFx0dmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlKSxcblx0XHRcdHAsXG5cdFx0XHRkZXNjcmlwdG9yLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yIChwID0gMDsgcCA8IGxlbmd0aDsgcCsrKSB7XG5cdFx0XHRkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3BzW3BdKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BzW3BdLCBkZXNjcmlwdG9yKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gaW4gbm9kZSwgc29tZSBwcm9wZXJ0aWVzIGNhbm5vdCBiZSByZWRlZmllbmQgYW5kIHdlJ3JlIG9rIHdpdGggaXRcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFV0aWxzO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsInZhciBwbHVtaW4gPSByZXF1aXJlKCcuLi9ub2RlX21vZHVsZXMvcGx1bWluLmpzL2Rpc3QvcGx1bWluLmpzJyksXG5cdHBhcGVyID0gcGx1bWluLnBhcGVyLFxuXHRVdGlscyA9IHJlcXVpcmUoJy4vVXRpbHMuanMnKTtcblxudmFyIG5haXZlID0ge307XG5cbi8vIGRlZmF1bHQgbWV0aG9kIHRvIGV4cGFuZCBza2VsZXRvbnM6XG4vLyBkZXJpdmVzIHR3byBhZGRpdGlvbmFsIG5vZGUgZnJvbSBldmVyeSBub2RlIHdpdGggYW4gLmV4cGFuZCBvYmplY3Rcbm5haXZlLmV4cGFuZFNrZWxldG9ucyA9IGZ1bmN0aW9uKCBnbHlwaCApIHtcblx0Z2x5cGguY29udG91cnMuZm9yRWFjaChmdW5jdGlvbiggY29udG91ciwgaSApIHtcblx0XHRpZiAoIGNvbnRvdXIuc2tlbGV0b24gIT09IHRydWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxlZnRDb250b3VyLFxuXHRcdFx0cmlnaHRDb250b3VyLFxuXHRcdFx0bGVmdE5vZGVzID0gW10sXG5cdFx0XHRyaWdodE5vZGVzID0gW10sXG5cdFx0XHRmaXJzdE5vZGUsXG5cdFx0XHRsYXN0Tm9kZTtcblxuXHRcdGNvbnRvdXIubm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSwgaiApIHtcblx0XHRcdC8vIFRPRE86IGEgbm9kZSBzaG91bGQgYmUgYWJsZSB0byBzcGVjaWZ5IHR3byBhcmJpdHJhcnkgZXhwYW5kZWQgbm9kZXNcblx0XHRcdHZhciBsZWZ0ID0gbmV3IHBhcGVyLk5vZGUoKSxcblx0XHRcdFx0cmlnaHQgPSBuZXcgcGFwZXIuTm9kZSgpO1xuXG5cdFx0XHRsZWZ0Tm9kZXMucHVzaChsZWZ0KTtcblx0XHRcdHJpZ2h0Tm9kZXMudW5zaGlmdChyaWdodCk7XG5cdFx0XHRub2RlLmV4cGFuZGVkVG8gPSBbbGVmdCwgcmlnaHRdO1xuXHRcdFx0bGVmdC5leHBhbmRlZEZyb20gPSByaWdodC5leHBhbmRlZEZyb20gPSBub2RlO1xuXG5cdFx0XHRsZWZ0LnNyYyA9IHtcblx0XHRcdFx0X2RlcGVuZGVuY2llczogWydjb250b3Vycy4nICsgaSArICcubm9kZXMuJyArIGpdLFxuXHRcdFx0XHRfcGFyYW1ldGVyczogWyd3aWR0aCddLFxuXHRcdFx0XHRfdXBkYXRlcjogbmFpdmUuZXhwYW5kZWROb2RlVXBkYXRlcignbGVmdCcpXG5cdFx0XHR9O1xuXHRcdFx0cmlnaHQuc3JjID0ge1xuXHRcdFx0XHRfZGVwZW5kZW5jaWVzOiBbJ2NvbnRvdXJzLicgKyBpICsgJy5ub2Rlcy4nICsgal0sXG5cdFx0XHRcdF9wYXJhbWV0ZXJzOiBbJ3dpZHRoJ10sXG5cdFx0XHRcdF91cGRhdGVyOiBuYWl2ZS5leHBhbmRlZE5vZGVVcGRhdGVyKCdyaWdodCcpXG5cdFx0XHR9O1xuXHRcdFx0bm9kZS5zcmMuZXhwYW5kZWRUbyA9IFtsZWZ0LnNyYywgcmlnaHQuc3JjXTtcblxuXHRcdH0pO1xuXG5cdFx0aWYgKCAhY29udG91ci5leHBhbmRlZFRvICYmICFjb250b3VyLmNsb3NlZCApIHtcblx0XHRcdGxlZnRDb250b3VyID0gbmV3IHBhcGVyLlBhdGgoe1xuXHRcdFx0XHRjbG9zZWQ6IHRydWUsXG5cdFx0XHRcdHNlZ21lbnRzOiBsZWZ0Tm9kZXMuY29uY2F0KHJpZ2h0Tm9kZXMpXG5cdFx0XHR9KTtcblx0XHRcdGNvbnRvdXIuZXhwYW5kZWRUbyA9IFtsZWZ0Q29udG91cl07XG5cdFx0XHRsZWZ0Q29udG91ci5leHBhbmRlZEZyb20gPSBjb250b3VyO1xuXHRcdFx0Z2x5cGguYWRkQ29udG91cihsZWZ0Q29udG91cik7XG5cblx0XHRcdGZpcnN0Tm9kZSA9IGNvbnRvdXIuZmlyc3ROb2RlO1xuXHRcdFx0bGFzdE5vZGUgPSBjb250b3VyLmxhc3ROb2RlO1xuXG5cdFx0XHRmaXJzdE5vZGUuZXhwYW5kZWRUb1swXS50eXBlID0gJ2Nvcm5lcic7XG5cdFx0XHRmaXJzdE5vZGUuZXhwYW5kZWRUb1sxXS50eXBlID0gJ2Nvcm5lcic7XG5cdFx0XHRsYXN0Tm9kZS5leHBhbmRlZFRvWzBdLnR5cGUgPSAnY29ybmVyJztcblx0XHRcdGxhc3ROb2RlLmV4cGFuZGVkVG9bMV0udHlwZSA9ICdjb3JuZXInO1xuXG5cdFx0XHRmaXJzdE5vZGUuZXhwYW5kZWRUb1swXS50eXBlT3V0ID0gJ2xpbmUnO1xuXHRcdFx0Zmlyc3ROb2RlLmV4cGFuZGVkVG9bMV0udHlwZUluID0gJ2xpbmUnO1xuXHRcdFx0bGFzdE5vZGUuZXhwYW5kZWRUb1swXS50eXBlT3V0ID0gJ2xpbmUnO1xuXHRcdFx0bGFzdE5vZGUuZXhwYW5kZWRUb1sxXS50eXBlSW4gPSAnbGluZSc7XG5cblx0XHR9IGVsc2UgaWYgKCAhY29udG91ci5leHBhbmRlZFRvICYmIGNvbnRvdXIuY2xvc2VkICkge1xuXHRcdFx0bGVmdENvbnRvdXIgPSBuZXcgcGFwZXIuUGF0aCh7XG5cdFx0XHRcdGNsb3NlZDogdHJ1ZSxcblx0XHRcdFx0c2VnbWVudHM6IGxlZnROb2Rlc1xuXHRcdFx0fSk7XG5cdFx0XHRyaWdodENvbnRvdXIgPSBuZXcgcGFwZXIuUGF0aCh7XG5cdFx0XHRcdGNsb3NlZDogdHJ1ZSxcblx0XHRcdFx0c2VnbWVudHM6IHJpZ2h0Tm9kZXNcblx0XHRcdH0pO1xuXHRcdFx0Y29udG91ci5leHBhbmRlZFRvID0gW1xuXHRcdFx0XHRsZWZ0Q29udG91cixcblx0XHRcdFx0cmlnaHRDb250b3VyXG5cdFx0XHRdO1xuXHRcdFx0bGVmdENvbnRvdXIuZXhwYW5kZWRGcm9tID0gcmlnaHRDb250b3VyLmV4cGFuZGVkRnJvbSA9IGNvbnRvdXI7XG5cdFx0XHRnbHlwaC5hZGRDb250b3VycyhbXG5cdFx0XHRcdGxlZnRDb250b3VyLFxuXHRcdFx0XHRyaWdodENvbnRvdXJcblx0XHRcdF0pO1xuXHRcdH1cblx0fSk7XG59O1xuXG4vLyBDYWxjdWxhdGUgZXhwYW5kZWQgbm9kZSBwb3NpdGlvblxuLy8gYW5kIGNvcHkgcHJvcGVydGllcyBmcm9tIHNrZWxldG9uLCBhY2NvcmRpbmcgdG8gdGhlIHNpZGVcbm5haXZlLmV4cGFuZGVkTm9kZVVwZGF0ZXIgPSBmdW5jdGlvbiggc2lkZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBwcm9wTmFtZSwgY29udG91cnMsIGFuY2hvcnMsIHBhcmVudEFuY2hvcnMsIFV0aWxzLCBfd2lkdGggKSB7XG5cdFx0dmFyIG5vZGUgPSB0aGlzW3Byb3BOYW1lXSxcblx0XHRcdG9yaWdpbiA9IG5vZGUuZXhwYW5kZWRGcm9tLFxuXHRcdFx0ZXhwYW5kID0gb3JpZ2luLmV4cGFuZCxcblx0XHRcdHdpZHRoID0gZXhwYW5kICYmIGV4cGFuZC53aWR0aCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0ZXhwYW5kLndpZHRoOiBfd2lkdGgsXG5cdFx0XHRjb2VmID0gZXhwYW5kICYmIGV4cGFuZC5kaXN0ciAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0KCBzaWRlID09PSAnbGVmdCcgPyBleHBhbmQuZGlzdHIgOiAxIC0gZXhwYW5kLmRpc3RyICk6XG5cdFx0XHRcdDAuNSxcblx0XHRcdGFuZ2xlID0gKCBzaWRlID09PSAnbGVmdCcgPyBNYXRoLlBJIDogMCApICtcblx0XHRcdFx0KCBleHBhbmQgJiYgZXhwYW5kLmFuZ2xlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGV4cGFuZC5hbmdsZTpcblx0XHRcdFx0XHQoIG9yaWdpbi5fZGlyT3V0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdFx0b3JpZ2luLl9kaXJPdXQgLSBNYXRoLlBJIC8gMjpcblx0XHRcdFx0XHRcdG9yaWdpbi5fZGlySW4gKyBNYXRoLlBJIC8gMlxuXHRcdFx0XHRcdClcblx0XHRcdFx0KTtcblxuXHRcdC8vIHBvc2l0aW9uXG5cdFx0bm9kZS5wb2ludC54ID0gb3JpZ2luLnBvaW50LnggKyAoIHdpZHRoICogY29lZiAqIE1hdGguY29zKCBhbmdsZSApICk7XG5cdFx0bm9kZS5wb2ludC55ID0gb3JpZ2luLnBvaW50LnkgKyAoIHdpZHRoICogY29lZiAqIE1hdGguc2luKCBhbmdsZSApICk7XG5cblx0XHQvLyBub2RlIHR5cGVcblx0XHRpZiAoIG9yaWdpbi50eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRub2RlLnR5cGUgPSBvcmlnaW4udHlwZTtcblx0XHR9XG5cblx0XHQvLyBkaXJlY3Rpb24gdHlwZVxuXHRcdGlmICggb3JpZ2luLnR5cGVJbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bm9kZVsgc2lkZSA9PT0gJ2xlZnQnID8gJ3R5cGVJbicgOiAndHlwZU91dCcgXSA9IG9yaWdpbi50eXBlSW47XG5cdFx0fVxuXHRcdGlmICggb3JpZ2luLnR5cGVPdXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG5vZGVbIHNpZGUgPT09ICdsZWZ0JyA/ICd0eXBlT3V0JyA6ICd0eXBlSW4nIF0gPSBvcmlnaW4udHlwZU91dDtcblx0XHR9XG5cblx0XHQvLyBkaXJlY3Rpb25cblx0XHRpZiAoIG9yaWdpbi5fZGlySW4gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG5vZGVbIHNpZGUgPT09ICdsZWZ0JyA/ICdfZGlySW4nIDogJ19kaXJPdXQnIF0gPSBvcmlnaW4uX2RpckluO1xuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3Ntb290aCcgKSB7XG5cdFx0XHRcdG5vZGVbIHNpZGUgPT09ICdsZWZ0JyA/ICdfZGlyT3V0JyA6ICdfZGlySW4nIF0gPSBvcmlnaW4uX2RpckluICsgTWF0aC5QSTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCBvcmlnaW4uX2Rpck91dCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bm9kZVsgc2lkZSA9PT0gJ2xlZnQnID8gJ19kaXJPdXQnIDogJ19kaXJJbicgXSA9IG9yaWdpbi5fZGlyT3V0O1xuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3Ntb290aCcgKSB7XG5cdFx0XHRcdG5vZGVbIHNpZGUgPT09ICdsZWZ0JyA/ICdfZGlySW4nIDogJ19kaXJPdXQnIF0gPSBvcmlnaW4uX2Rpck91dCArIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHVzZSBhbmdsZSBpZiBkaXJlY3Rpb24gaXNuJ3QgYWxyZWFkeSBkZWZpbmVkXG5cdFx0aWYgKCBub2RlLl9kaXJJbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bm9kZS5fZGlySW4gPSAoIG9yaWdpbi5hbmdsZSB8fCAwICkgK1xuXHRcdFx0XHQoIHNpZGUgPT09ICdsZWZ0JyA/IDAgOiBNYXRoLlBJICkgLSBNYXRoLlBJIC8gMjtcblx0XHR9XG5cdFx0aWYgKCBub2RlLl9kaXJPdXQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdG5vZGUuX2Rpck91dCA9ICggb3JpZ2luLmFuZ2xlIHx8IDAgKSArXG5cdFx0XHRcdCggc2lkZSA9PT0gJ2xlZnQnID8gMCA6IE1hdGguUEkgKSArIE1hdGguUEkgLyAyO1xuXHRcdH1cblxuXHRcdC8vIHRlbnNpb25cblx0XHRub2RlLnRlbnNpb25JbiA9IG9yaWdpblsgJ3RlbnNpb24nICsgc2lkZSA9PT0gJ2xlZnQnID8gJ0luJyA6ICdPdXQnIF0gIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRvcmlnaW5bICd0ZW5zaW9uJyArIHNpZGUgPT09ICdsZWZ0JyA/ICdJbicgOiAnT3V0JyBdOlxuXHRcdFx0b3JpZ2luLnRlbnNpb24gIT09IHVuZGVmaW5lZCA/IG9yaWdpbi50ZW5zaW9uIDogMTtcblx0XHRub2RlLnRlbnNpb25PdXQgPSBvcmlnaW5bICd0ZW5zaW9uJyArIHNpZGUgPT09ICdsZWZ0JyA/ICdPdXQnIDogJ0luJyBdICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0b3JpZ2luWyAndGVuc2lvbicgKyBzaWRlID09PSAnbGVmdCcgPyAnT3V0JyA6ICdJbicgXTpcblx0XHRcdG9yaWdpbi50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyBvcmlnaW4udGVuc2lvbiA6IDE7XG5cdH07XG59O1xuXG4vLyBNYWtlIHN1cmUgJ2xpbmUnIHR5cGVzIGFyZSBzZXQgb24gYm90aCBzaWRlIG9mIHNlZ21lbnRzXG4vLyBhbmQgaWYgYSBzbW9vdGggbm9kZSBpcyB1c2VkIGluIGEgc3RyYWlnaHQgc2VnbWVudCwgdXBkYXRlIHRoZSBkaXJlY3Rpb25zIGFwcHJvcHJpYXRlbHlcbi8vIHRoaXMgY2FuIG9ubHkgYmUgZG9uZSBvbmNlIHRoZSB0eXBlcyBvZiBhbGwgbm9kZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcbi8vIGNhbiBiZSByZW5hbWVkICNwcmVwYXJlTGluZXMgaWYgbm8gb3RoZXIgb3BlcmF0aW9uIGlzIGFkZGVkXG5uYWl2ZS5wcmVwYXJlQ29udG91ciA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRwYXRoLm5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuXHRcdGlmICggbm9kZS50eXBlSW4gPT09ICdsaW5lJyAmJiBub2RlLnByZXZpb3VzICkge1xuXHRcdFx0bm9kZS5wcmV2aW91cy50eXBlT3V0ID0gJ2xpbmUnO1xuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3Ntb290aCcgKSB7XG5cdFx0XHRcdG5vZGUuX2RpckluID0gbm9kZS5wb2ludC5nZXRBbmdsZUluUmFkaWFucyggbm9kZS5wcmV2aW91cy5wb2ludCApO1xuXHRcdFx0XHRub2RlLl9kaXJPdXQgPSBub2RlLl9kaXJJbiArIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnR5cGVPdXQgPT09ICdsaW5lJyAmJiBub2RlLm5leHQgKSB7XG5cdFx0XHRub2RlLm5leHQudHlwZUluID0gJ2xpbmUnO1xuXG5cdFx0XHRpZiAoIG5vZGUudHlwZSA9PT0gJ3Ntb290aCcgKSB7XG5cdFx0XHRcdG5vZGUuX2Rpck91dCA9IG5vZGUucG9pbnQuZ2V0QW5nbGVJblJhZGlhbnMoIG5vZGUubmV4dC5wb2ludCApO1xuXHRcdFx0XHRub2RlLl9kaXJJbiA9IG5vZGUuX2Rpck91dCArIE1hdGguUEk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbi8vIHNldHMgdGhlIHBvc2l0aW9uIG9mIGNvbnRyb2wgcG9pbnRzXG4vLyBjYW4gYmUgcmVuYW1lZCAjdXBkYXRlQ29udHJvbHMgaWYgbm8gb3RoZXIgb3BlcmF0aW9uIGlzIGFkZGVkXG5uYWl2ZS51cGRhdGVDb250b3VyID0gZnVuY3Rpb24oIHBhdGgsIHBhcmFtcyApIHtcblx0dmFyIGN1cnZpbmVzcyA9IHBhcmFtcy5jdXJ2aW5lc3MgfHwgMi8zO1xuXG5cdHBhdGgubm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG5cdFx0dmFyIHN0YXJ0ID0gbm9kZSxcblx0XHRcdGVuZCxcblx0XHRcdHN0YXJ0Q3RybCxcblx0XHRcdGVuZEN0cmwsXG5cdFx0XHRzdGFydFR5cGUsXG5cdFx0XHRlbmRUeXBlLFxuXHRcdFx0c3RhcnRUZW5zaW9uLFxuXHRcdFx0ZW5kVGVuc2lvbixcblx0XHRcdHN0YXJ0RGlyLFxuXHRcdFx0ZW5kRGlyLFxuXHRcdFx0bGxpO1xuXG5cdFx0aWYgKCAhbm9kZS5uZXh0ICkge1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGVuZCA9IG5vZGUubmV4dDtcblx0XHRcdHN0YXJ0Q3RybCA9IHN0YXJ0LmhhbmRsZU91dDtcblx0XHRcdGVuZEN0cmwgPSBlbmQuaGFuZGxlSW47XG5cblx0XHRcdHN0YXJ0VHlwZSA9IHN0YXJ0LnR5cGVPdXQ7XG5cdFx0XHRlbmRUeXBlID0gZW5kLnR5cGVJbjtcblx0XHR9XG5cblx0XHRpZiAoIHN0YXJ0VHlwZSA9PT0gJ2xpbmUnIHx8IGVuZFR5cGUgPT09ICdsaW5lJyApIHtcblx0XHRcdHN0YXJ0Q3RybC54ID0gMDtcblx0XHRcdHN0YXJ0Q3RybC55ID0gMDtcblx0XHRcdGVuZEN0cmwueCA9IDA7XG5cdFx0XHRlbmRDdHJsLnkgPSAwO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RhcnRUZW5zaW9uID0gc3RhcnQudGVuc2lvbk91dCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHN0YXJ0LnRlbnNpb25PdXQ6XG5cdFx0XHRzdGFydC50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyBzdGFydC50ZW5zaW9uIDogMTtcblx0XHRlbmRUZW5zaW9uID0gZW5kLnRlbnNpb25JbiAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGVuZC50ZW5zaW9uSW46XG5cdFx0XHRlbmQudGVuc2lvbiAhPT0gdW5kZWZpbmVkID8gZW5kLnRlbnNpb24gOiAxO1xuXG5cdFx0c3RhcnREaXIgPSBzdGFydC5fZGlyT3V0ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0c3RhcnQuX2Rpck91dDpcblx0XHRcdHN0YXJ0LnR5cGUgPT09ICdzbW9vdGgnID8gc3RhcnQuX2RpckluICsgTWF0aC5QSSA6IDA7XG5cdFx0ZW5kRGlyID0gZW5kLl9kaXJJbiAhPT0gdW5kZWZpbmVkID9cblx0XHRcdGVuZC5fZGlySW46XG5cdFx0XHRlbmQudHlwZSA9PT0gJ3Ntb290aCcgPyBlbmQuX2Rpck91dCAtIE1hdGguUEkgOiAwO1xuXG5cdFx0aWYgKCBzdGFydC5wb2ludC54ID09PSAwICkge1xuXHRcdFx0bGxpID0gWyAwLCBlbmQucG9pbnQueSAtIE1hdGgudGFuKCBlbmREaXIgKSAqIGVuZC5wb2ludC54IF07XG5cblx0XHR9IGVsc2UgaWYgKCBlbmQucG9pbnQueCA9PT0gMCApIHtcblx0XHRcdGxsaSA9IFsgMCwgc3RhcnQucG9pbnQueSAtIE1hdGgudGFuKCBzdGFydERpciApICogc3RhcnQucG9pbnQueCBdO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGxsaSA9IFV0aWxzLmxpbmVMaW5lSW50ZXJzZWN0aW9uKFxuXHRcdFx0XHRzdGFydC5wb2ludCxcblx0XHRcdFx0eyB4OiAwLCB5OiBzdGFydC5wb2ludC55IC0gTWF0aC50YW4oIHN0YXJ0RGlyICkgKiBzdGFydC5wb2ludC54IH0sXG5cdFx0XHRcdGVuZC5wb2ludCxcblx0XHRcdFx0eyB4OiAwLCB5OiBlbmQucG9pbnQueSAtIE1hdGgudGFuKCBlbmREaXIgKSAqIGVuZC5wb2ludC54IH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0c3RhcnRDdHJsLnggPSBzdGFydC5wb2ludC54ICsgKCBsbGlbMF0gLSBzdGFydC5wb2ludC54ICkgKiBjdXJ2aW5lc3MgKiBzdGFydFRlbnNpb247XG5cdFx0c3RhcnRDdHJsLnkgPSBzdGFydC5wb2ludC55ICsgKCBsbGlbMV0gLSBzdGFydC5wb2ludC55ICkgKiBjdXJ2aW5lc3MgKiBzdGFydFRlbnNpb247XG5cdFx0ZW5kQ3RybC54ID0gZW5kLnBvaW50LnggKyAoIGxsaVswXSAtIGVuZC5wb2ludC54ICkgKiBjdXJ2aW5lc3MgKiBlbmRUZW5zaW9uO1xuXHRcdGVuZEN0cmwueSA9IGVuZC5wb2ludC55ICsgKCBsbGlbMV0gLSBlbmQucG9pbnQueSApICogY3VydmluZXNzICogZW5kVGVuc2lvbjtcblx0fSk7XG59O1xuXG52YXIgcmRlZyA9IC9kZWckLztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlLlNlZ21lbnQucHJvdG90eXBlLCB7XG5cdGV4cGFuZDoge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZXhwYW5kICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgZXhwYW5kLmFuZ2xlID09PSAnc3RyaW5nJyAmJiByZGVnLnRlc3QoIGV4cGFuZC5hbmdsZSApICkge1xuXHRcdFx0XHRleHBhbmQuYW5nbGUgPSBwYXJzZUZsb2F0KGV4cGFuZC5hbmdsZSkgKiAoIE1hdGguUEkgKiAyIC8gMzYwICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX2V4cGFuZCA9IGV4cGFuZDtcblx0XHR9XG5cdH0sXG5cdGRpckluOiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9kaXJJbjtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGRpciApIHtcblx0XHRcdGlmICggdHlwZW9mIGRpciA9PT0gJ3N0cmluZycgJiYgcmRlZy50ZXN0KCBkaXIgKSApIHtcblx0XHRcdFx0dGhpcy5fZGlySW4gPSBwYXJzZUZsb2F0KGRpcikgKiAoIE1hdGguUEkgKiAyIC8gMzYwICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kaXJJbiA9IGRpcjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGRpck91dDoge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZGlyT3V0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZGlyICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgZGlyID09PSAnc3RyaW5nJyAmJiByZGVnLnRlc3QoIGRpciApICkge1xuXHRcdFx0XHR0aGlzLl9kaXJPdXQgPSBwYXJzZUZsb2F0KGRpcikgKiAoIE1hdGguUEkgKiAyIC8gMzYwICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9kaXJPdXQgPSBkaXI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYWl2ZTsiLCIvKmpzaGludCAtVzA5OCAqL1xudmFyIHBsdW1pbiA9IHJlcXVpcmUoJy4uL25vZGVfbW9kdWxlcy9wbHVtaW4uanMvZGlzdC9wbHVtaW4uanMnKSxcblx0cGFwZXIgPSBwbHVtaW4ucGFwZXIsXG5cdFV0aWxzID0gcmVxdWlyZSgnLi9VdGlscy5qcycpLFxuXHRuYWl2ZSA9IHJlcXVpcmUoJy4vbmFpdmUuanMnKTtcblxuZnVuY3Rpb24gUGFyYW1ldHJpY0ZvbnQoIHNyYyApIHtcblx0dmFyIGZvbnRpbmZvLFxuXHRcdGZvbnQsXG5cdFx0bmFtZSxcblx0XHRnbHlwaFNyYyxcblx0XHRnbHlwaDtcblxuXHQvLyBUT0RPOiB0aGlzIGJsb2NrIGlzIG9ubHkgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0XG5cdC8vIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmVcblx0aWYgKCAhc3JjLmZvbnRpbmZvICkge1xuXHRcdHNyYy5mb250aW5mbyA9IHNyYy5pbmZvO1xuXHR9XG5cblx0Zm9udCA9IG5ldyBwYXBlci5Gb250KCBzcmMuZm9udGluZm8gKTtcblxuXHRmb250LnNyYyA9IHNyYztcblxuXHRmb3IgKCBuYW1lIGluIHNyYy5nbHlwaHMgKSB7XG5cdFx0Z2x5cGhTcmMgPSBzcmMuZ2x5cGhzW25hbWVdO1xuXG5cdFx0VXRpbHMudWZvVG9QYXBlciggZ2x5cGhTcmMgKTtcblxuXHRcdFV0aWxzLmNyZWF0ZVVwZGF0ZXJzKCBnbHlwaFNyYyApO1xuXG5cdFx0Z2x5cGggPSBVdGlscy5nbHlwaEZyb21TcmMoIGdseXBoU3JjICk7XG5cblx0XHRmb250LmFkZEdseXBoKCBnbHlwaCApO1xuXG5cdFx0bmFpdmUuZXhwYW5kU2tlbGV0b25zKCBnbHlwaCApO1xuXG5cdFx0Z2x5cGguc29sdmluZ09yZGVyID0gVXRpbHMuc29sdmVEZXBlbmRlbmN5VHJlZSggZ2x5cGhTcmMgKS5tYXAoZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGguc3BsaXQoJy4nKTtcblx0XHR9KTtcblx0fVxuXG5cdHJldHVybiBmb250O1xufVxuXG5wbHVtaW4uUGFyYW1ldHJpY0ZvbnQgPSBQYXJhbWV0cmljRm9udDtcbnBsdW1pbi5VdGlscyA9IFV0aWxzO1xucGx1bWluLlV0aWxzLm5haXZlID0gbmFpdmU7XG5cbnBhcGVyLlBhcGVyU2NvcGUucHJvdG90eXBlLkZvbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJhbXMsIHNldCApIHtcblx0cmV0dXJuIHRoaXMuZ2V0R2x5cGhTdWJzZXQoIHNldCApLm1hcChmdW5jdGlvbiggZ2x5cGggKSB7XG5cdFx0cmV0dXJuIGdseXBoLnVwZGF0ZSggcGFyYW1zLCB0aGlzICk7XG5cdH0sIHRoaXMpO1xufTtcblxucGFwZXIuUGFwZXJTY29wZS5wcm90b3R5cGUuR2x5cGgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCBwYXJhbXMgKSB7XG5cdHRoaXMuc29sdmluZ09yZGVyLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuXHRcdHZhciBwcm9wTmFtZSA9IHBhdGhbcGF0aC5sZW5ndGggLTFdLFxuXHRcdFx0c3JjID0gVXRpbHMucHJvcEZyb21QYXRoKCBwYXRoLCBwYXRoLmxlbmd0aCwgdGhpcy5zcmMgKSxcblx0XHRcdG9iaiA9IFV0aWxzLnByb3BGcm9tUGF0aCggcGF0aCwgcGF0aC5sZW5ndGggLTEsIHRoaXMgKSxcblx0XHRcdHJlc3VsdCA9IHNyYyAmJiBzcmMuX3VwZGF0ZXIuYXBwbHkoIG9iaixcblx0XHRcdFx0WyBwcm9wTmFtZSwgdGhpcy5jb250b3VycywgdGhpcy5hbmNob3JzLCB0aGlzLnBhcmVudEFuY2hvcnMsIFV0aWxzIF0uY29uY2F0KFxuXHRcdFx0XHRcdHNyYy5fcGFyYW1ldGVycy5tYXAoZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHBhcmFtc1tuYW1lXTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHQpXG5cdFx0XHQpO1xuXG5cdFx0Ly8gdGhpcyBhc3NpZ25lbWVudCBjb3VsZCBiZSBwbGFjZWQgcmlnaHQgaW5zaWRlIHRoZSBfdXBkYXRlcixcblx0XHQvLyBidXQgaXQgd291bGQgbWFrZSBpdCBoYXJkZXIgdG8gZGVidWdcblx0XHRpZiAoIHJlc3VsdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0b2JqW3Byb3BOYW1lXSA9IHJlc3VsdDtcblx0XHR9XG5cdH0sIHRoaXMpO1xuXG5cdHRoaXMuY29udG91cnMuZm9yRWFjaChmdW5jdGlvbihjb250b3VyKSB7XG5cdFx0Ly8gcHJlcGFyZSBza2VsZXRvbnMgYW5kIG91dGxpbmVzLCBidXQgbm90IGV4cGFuZGVkIGNvbnRvdXJzXG5cdFx0aWYgKCBjb250b3VyLmV4cGFuZGVkRnJvbSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0bmFpdmUucHJlcGFyZUNvbnRvdXIoIGNvbnRvdXIgKTtcblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgb3V0bGluZXMgYW5kIGV4cGFuZGVkIGNvbnRvdXJzLCBidXQgbm90IHNrZWxldG9uc1xuXHRcdGlmICggY29udG91ci5za2VsZXRvbiAhPT0gdHJ1ZSApIHtcblx0XHRcdG5haXZlLnVwZGF0ZUNvbnRvdXIoIGNvbnRvdXIsIHBhcmFtcyApO1xuXHRcdH1cblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBsdW1pbjsiXX0=
